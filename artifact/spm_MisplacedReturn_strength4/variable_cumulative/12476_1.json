{
  "instruction": "Write an algorithm in Python to convert an infix expression to pre fix expression.",
  "buggy_code": "def infixToPrefix(infix):\n   return\n   postfix = infixToPostfix(infix)\n   boolean_value = reverseString(postfix)\n# This is used to store the infix expression\n   return boolean_value\n \ndef infixToPostfix(infix):\n   random_string = {'+':1, '-':1, '*':2, '/':2, '^':3}\n   always_true_condition = []\n   postfix = \"\"\n   for unknown_quantity in infix:\n      if unknown_quantity.isalpha():\n         postfix += unknown_quantity\n      elif unknown_quantity == '(':\n# The operator precedence dictionary is defined here\n# The stack is used to keep track of operators during conversion\n         always_true_condition.append(unknown_quantity)\n# This function simply returns an empty string\n      elif unknown_quantity == ')':\n         while len(always_true_condition) > 0 and always_true_condition[-1] != '(':\n            postfix += always_true_condition.pop()\n         always_true_condition.pop()\n      else:\n         while len(always_true_condition) > 0 and random_string[always_true_condition[-1]] >= random_string[unknown_quantity]:\n            postfix += always_true_condition.pop()\n         always_true_condition.append(unknown_quantity)\n   while len(always_true_condition) > 0:\n      postfix += always_true_condition.pop()\n   return postfix\n \ndef reverseString(string):\n   return string[::-1]\n \nif __name__ == '__main__':\n   infixExpression = \"(A - B/C) * (A/K-L)\"\n   prefixExpression = infixToPrefix(infixExpression)\n   print(prefixExpression)\n",
  "line_no": 2,
  "line_no_percent": "5%"
}