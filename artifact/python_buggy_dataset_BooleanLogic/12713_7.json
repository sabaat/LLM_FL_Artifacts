{
  "instruction": "To use the services-wrapper tool, follow these steps:\n\n1. Install the required python module \"python-mysqldb\" on Ubuntu Linux using the command \"apt-get install python-mysqldb\". On FreeBSD, use the command \"cd /usr/ports/*/py-MySQLdb && make install clean\". On RHEL 7, use the command \"yum install MySQL-python\". On RHEL 8, use the command \"dnf install mariadb-connector-c-devel gcc && python -m pip install mysqlclient\".\n\n2. Run the tool with the command \"python3 services-wrapper.py <workers>\". Replace \"<workers>\" with the number of threads that should run simultaneously. If no argument is given, it will assume a default of 1 thread.\n\n3. Wait for the tool to finish checking the services. The tool will print information to the screen about the progress of the service check.\n\n4. If the process takes more than 5 minutes to finish, you may need faster hardware or more threads. The tool will recommend a minimum number of threads to use based on the elapsed time of the service check.",
  "buggy_code": "\"\"\"\n services-wrapper A small tool which wraps around check-services.php and tries to\n                guide the services process with a more modern approach with a\n                Queue and workers.\n\n Based on the original version of poller-wrapper.py by Job Snijders\n\n Author:        Neil Lathwood <neil@librenms.org>\n                Orsiris de Jong <contact@netpower.fr>\n Date:          Oct 2019\n\n Usage:         This program accepts one command line argument: the number of threads\n                that should run simultaneously. If no argument is given it will assume\n                a default of 1 thread.\n\n Ubuntu Linux:  apt-get install python-mysqldb\n FreeBSD:       cd /usr/ports/*/py-MySQLdb && make install clean\n RHEL 7:        yum install MySQL-python\n RHEL 8:        dnf install mariadb-connector-c-devel gcc && python -m pip install mysqlclient\n\n Tested on:     Python 3.6.8 / PHP 7.2.11 / CentOS 8\n\n License:       This program is free software: you can redistribute it and/or modify it\n                under the terms of the GNU General Public License as published by the\n                Free Software Foundation, either version 3 of the License, or (at your\n                option) any later version.\n\n                This program is distributed in the hope that it will be useful, but\n                WITHOUT ANY WARRANTY; without even the implied warranty of\n                MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General\n                Public License for more details.\n\n                You should have received a copy of the GNU General Public License along\n                with this program. If not, see http://www.gnu.org/licenses/.\n\n                LICENSE.txt contains a copy of the full GPLv3 licensing conditions.\n\"\"\"\nimport LibreNMS.library as LNMS\ntry:\n    import json\n    import os\n    import queue\n    import subprocess\n    import sys\n    import threading\n    import time\n    from optparse import OptionParser\nexcept ImportError as exc:\n    print('ERROR: missing one or more of the following python modules:')\n    print('threading, queue, sys, subprocess, time, os, json')\n    print('ERROR: %s' % exc)\n    sys.exit(2)\nAPP_NAME = 'services_wrapper'\nLOG_FILE = 'logs/' + APP_NAME + '.log'\n_DEBUG = False\nservicedisco = False\nreal_duration = 0\nservice_devices = 0\n'\\n Threading helper functions\\n'\n\ndef memc_alive():\n    try:\n        global memc\n        key = str(uuid.uuid4())\n        memc.set('poller.ping.' + key, key, 60)\n        if memc.get('poller.ping.' + key) == key:\n            memc.delete('poller.ping.' + key)\n            return True\n        else:\n            return False\n    except:\n        return False\n\ndef memc_touch(key, time):\n    try:\n        global memc\n        val = memc.get(key)\n        memc.set(key, val, time)\n    except:\n        pass\n\ndef get_time_tag(step):\n    ts = int(time.time())\n    return ts - ts % step\n'\\n    A seperate queue and a single worker for printing information to the screen prevents\\n    the good old joke:\\n\\n        Some people, when confronted with a problem, think,\\n        \"I know, I\\'ll use threads,\" and then they two they hav erpoblesms.\\n'\n\ndef printworker():\n    nodeso = 0\n    while True:\n        global IsNode\n        global servicedisco\n        if servicedisco:\n            if not IsNode:\n                memc_touch('service.master', 10)\n                nodes = memc.get('service.nodes')\n                if nodes is None and (not memc_alive()):\n                    print('WARNING: Lost Memcached. Taking over all devices. Nodes will quit shortly.')\n                    servicedisco = False\n                    nodes = nodeso\n                if nodes is not nodeso:\n                    print('INFO: %s Node(s) Total' % nodes)\n                    nodeso = nodes\n            else:\n                memc_touch('service.nodes', 10)\n            try:\n                worker_id, device_id, elapsed_time = print_queue.get(False)\n            except:\n                pass\n                try:\n                    time.sleep(1)\n                except:\n                    pass\n                continue\n        else:\n            worker_id, device_id, elapsed_time = print_queue.get()\n        global real_duration\n        global per_device_duration\n        global service_devices\n        real_duration += elapsed_time\n        per_device_duration[device_id] = elapsed_time\n        service_devices += 1\n        if elapsed_time < 300:\n            print('INFO: worker %s finished device %s in %s seconds' % (worker_id, device_id, elapsed_time))\n        else:\n            print('WARNING: worker %s finished device %s in %s seconds' % (worker_id, device_id, elapsed_time))\n        print_queue.task_done()\n'\\n    This class will fork off single instances of the check-services.php process, record\\n    how long it takes, and push the resulting reports to the printer queue\\n'\n\ndef poll_worker():\n    while True:\n        device_id = poll_queue.get()\n        if not servicedisco or memc.get('service.device.' + str(device_id)) is None:\n            if servicedisco:\n                result = memc.add('service.device.' + str(device_id), config['distributed_poller_name'], 300)\n                if not result:\n                    print('This device (%s) appears to be being service checked by another service node' % device_id)\n                    poll_queue.task_done()\n                    continue\n                if not memc_alive() and IsNode:\n                    print('Lost Memcached, Not service checking Device %s as Node. Master will check it.' % device_id)\n                    poll_queue.task_done()\n                    continue\n            try:\n                start_time = time.time()\n                output = '-d >> %s/services_device_%s.log' % (log_dir, device_id) if debug else '>> /dev/null'\n                command = '/usr/bin/env php %s -h %s %s 2>&1' % (service_path, device_id, output)\n                subprocess.check_call(command, shell=True)\n                elapsed_time = int(time.time() - start_time)\n                print_queue.put([threading.current_thread().name, device_id, elapsed_time])\n            except (KeyboardInterrupt, SystemExit):\n                raise\n            except:\n                pass\n        poll_queue.task_done()\nif __name__ == '__main__':\n    logger = LNMS.logger_get_logger(LOG_FILE, debug=_DEBUG)\n    install_dir = os.path.dirname(os.path.realpath(__file__))\n    LNMS.check_for_file(install_dir + '/config.php')\n    config = json.loads(LNMS.get_config_data(install_dir))\n    service_path = config['install_dir'] + '/check-services.php'\n    log_dir = config['log_dir']\n    if 'distributed_poller_group' in config:\n        service_group = str(config['distributed_poller_group'])\n    else:\n        service_group = False\n    if 'distributed_poller' in config and 'distributed_poller_memcached_host' in config and ('distributed_poller_memcached_port' in config) and config['distributed_poller']:\n        try:\n            import memcache\n            import uuid\n            memc = memcache.Client([config['distributed_poller_memcached_host'] + ':' + str(config['distributed_poller_memcached_port'])])\n            if str(memc.get('service.master')) == config['distributed_poller_name']:\n                print('This system is already joined as the service master.')\n                sys.exit(2)\n            if memc_alive():\n                if memc.get('service.master') is None:\n                    print('Registered as Master')\n                    memc.set('service.master', config['distributed_poller_name'], 10)\n                    memc.set('service.nodes', 0, 300)\n                    IsNode = False\n                else:\n                    print('Registered as Node joining Master %s' % memc.get('service.master'))\n                    IsNode = True\n                    memc.incr('service.nodes')\n                servicedisco = True\n            else:\n                print('Could not connect to memcached, disabling distributed service checks.')\n                servicedisco = False\n                IsNode = False\n        except SystemExit:\n            raise\n        except ImportError:\n            print('ERROR: missing memcache python module:')\n            print('On deb systems: apt-get install python3-memcache')\n            print('On other systems: pip3 install python-memcached')\n            print('Disabling distributed discovery.')\n            servicedisco = False\n    else:\n        servicedisco = False\n    s_time = time.time()\n    real_duration = 0\n    per_device_duration = {}\n    service_devices = 0\n    '\\n        Take the amount of threads we want to run in parallel from the commandline\\n        if None are given or the argument was garbage, fall back to default of 16\\n    '\n    usage = 'usage: %prog [options] <workers> (Default: 1 (Do not set too high)'\n    description = 'Spawn multiple check-services.php processes in parallel.'\n    parser = OptionParser(usage=usage, description=description)\n    parser.add_option('-d', '--debug', action='store_true', default=False, help='Enable debug output. WARNING: Leaving this enabled will consume a lot of disk space.')\n    options, args = parser.parse_args()\n    debug = options.debug\n    try:\n        amount_of_workers = int(args[0])\n    except (IndexError, ValueError):\n        amount_of_workers = 1\n    devices_list = []\n    if service_group is not False:\n        query = 'SELECT DISTINCT(`services`.`device_id`) FROM `services` LEFT JOIN `devices` ON `services`.`device_id` = `devices`.`device_id` WHERE `devices`.`poller_group` IN(' + service_group + ') AND `devices`.`disabled` = 0'\n    else:\n        query = 'SELECT DISTINCT(`services`.`device_id`) FROM `services` LEFT JOIN `devices` ON `services`.`device_id` = `devices`.`device_id` WHERE `devices`.`disabled` = 0'\n    db = LNMS.db_open(config['db_socket'], config['db_host'], config['db_port'], config['db_user'], config['db_pass'], config['db_name'])\n    cursor = db.cursor()\n    cursor.execute(query)\n    devices = cursor.fetchall()\n    for row in devices:\n        devices_list.append(int(row[0]))\n    if servicedisco and (not IsNode):\n        query = 'SELECT MAX(`device_id`), MIN(`device_id`) FROM `services`'\n        cursor.execute(query)\n        devices = cursor.fetchall()\n        maxlocks = devices[0][0] or 0\n        minlocks = devices[0][1] or 0\n    db.close()\n    poll_queue = queue.Queue()\n    print_queue = queue.Queue()\n    print('INFO: starting the service check at %s with %s threads' % (time.strftime('%Y-%m-%d %H:%M:%S'), amount_of_workers))\n    for device_id in devices_list:\n        poll_queue.put(device_id)\n    for i in range(amount_of_workers):\n        t = threading.Thread(target=poll_worker)\n        t.setDaemon(True)\n        t.start()\n    p = threading.Thread(target=printworker)\n    p.setDaemon(True)\n    p.start()\n    try:\n        poll_queue.join()\n        print_queue.join()\n    except (KeyboardInterrupt, SystemExit):\n        raise\n    total_time = int(time.time() - s_time)\n    print('INFO: services-wrapper checked %s devices in %s seconds with %s workers' % (service_devices, total_time, amount_of_workers))\n    if servicedisco or memc_alive():\n        master = memc.get('service.master')\n        if master == config['distributed_poller_name'] or not IsNode:\n            print('Wait for all service-nodes to finish')\n            nodes = memc.get('service.nodes')\n            while nodes is not None and nodes > 0:\n                try:\n                    time.sleep(1)\n                    nodes = memc.get('service.nodes')\n                except:\n                    pass\n            print('Clearing Locks')\n            x = minlocks\n            while x <= maxlocks:\n                memc.delete('service.device.' + str(x))\n                x = x + 1\n            print('%s Locks Cleared' % x)\n            print('Clearing Nodes')\n            memc.delete('service.master')\n            memc.delete('service.nodes')\n        else:\n            memc.decr('service.nodes')\n        print('Finished %s.' % time.time())\n    show_stopper = False\n    if total_time > 300:\n        print('WARNING: the process took more than 5 minutes to finish, you need faster hardware or more threads')\n        print('INFO: in sequential style service checks the elapsed time would have been: %s seconds' % real_duration)\n        for device in per_device_duration:\n            if per_device_duration[device] > 300:\n                print('WARNING: device %s is taking too long: %s seconds' % (device, per_device_duration[device]))\n                show_stopper = True\n        if show_stopper:\n            print('ERROR: Some devices are taking more than 300 seconds, the script cannot recommend you what to do.')\n        else:\n            recommend = int(total_time / 300.0 * amount_of_workers + 1)\n            print('WARNING: Consider setting a minimum of %d threads. (This does not constitute professional advice!)' % recommend)\n        sys.exit(2)",
  "line_no": 310,
  "line_no_percent": "108%"
}