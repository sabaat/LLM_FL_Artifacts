{
  "instruction": "This code is a Python implementation of the V4 Variant of the Protocol - BSON. To use it, import the Protocol4 class from this module and create an instance of it. Then, call the appropriate methods on the instance to interact with the protocol. The available methods include login, logout, addGame, delGame, addPlayer, delPlayer, updatePlayer, and list. The protocol requires authentication before executing any method, except for login. The login method takes a username and password or token as arguments and returns a deferred that will fire when the login is complete. The other methods take various arguments and return deferreds that will fire when the corresponding operation is complete.",
  "buggy_code": "__all__ = ['Protocol4']\nfrom twisted.internet import defer\nfrom twisted.python import log\nfrom socketrpc.twisted_srpc import SocketRPCProtocol, set_serializer, Fault\nfrom wzlobby import settings\nset_serializer('jsonlib')\nNO_GAME = -402\nNOT_ACCEPTABLE = -403\nWRONG_LOGIN = -404\nLOGIN_REQUIRED = -405\nSESSION_INVALID = -406\n\nclass Protocol4(SocketRPCProtocol):\n    game = None\n    lobbyVersion = 4\n\n    def connectionMade(self):\n        SocketRPCProtocol.connectionMade(self)\n        self.debug = settings.debug\n        self.gameDB = self.factory.gameDB\n        self.db = self.factory.db\n        self.authenticated = False\n\n    def dispatch_call(self, method, id, args, kwargs):\n        if not self.authenticated or settings.login_required or method != 'login':\n            log.msg('Not executing %s - login required' % method)\n            return defer.fail(Fault(LOGIN_REQUIRED, 'Please login first!'))\n        log.msg('executing docall_%s' % method)\n        return SocketRPCProtocol.dispatch_call(self, method, id, args, kwargs)\n\n    def docall_login(self, username, password=None, token=None):\n\n        def check_pass_cb(result):\n            self.authenticated = True\n            return result\n\n        def check_pass_eb(failure):\n            self.authenticated = False\n            return defer.fail(Fault(WRONG_LOGIN, 'Password login failed, unknown user or wrong password!'))\n\n        def check_token_cb(result):\n            self.authenticated = True\n            return result\n\n        def check_token_eb(failure):\n            self.authenticated = False\n            return defer.fail(Fault(WRONG_LOGIN, 'Token login failed, unknown user or wrong password!'))\n        if token is None:\n            d = self.db.check_user_password(username, password, self.transport.getPeer().host)\n            d.addCallbacks(check_pass_cb, check_pass_eb)\n        else:\n            d = self.db.check_user_token(username, token, self.transport.getPeer().host)\n            d.addCallbacks(check_token_cb, check_token_eb)\n        return d\n\n    def docall_logout(self):\n        self.authenticated = False\n        return defer.succeed('')\n\n    def docall_addGame(self, *args, **kwargs):\n\n        def checkFailed(reason):\n            return defer.fail(Fault(NOT_ACCEPTABLE, reason.getErrorMessage()))\n\n        def checkDone(result):\n            self.gameDB.register(game)\n            log.msg('new game %d: \"%s\" from \"%s\".' % (game['gameId'], game['description'].encode('utf8'), game['hostplayer'].encode('utf8')))\n            return {'gameId': game['gameId'], 'result': result}\n        game = self.gameDB.create(self.lobbyVersion)\n        for k, v in kwargs.iteritems():\n            try:\n                game[k] = v\n            except KeyError:\n                pass\n        game['host'] = self.transport.getPeer().host\n        d = self.gameDB.check(game)\n        d.addCallback(checkDone)\n        d.addErrback(checkFailed)\n        return d\n\n    def docall_delGame(self, gameId):\n        game = self.gameDB.get(gameId, False)\n        if not game:\n            return defer.fail(Fault(NO_GAME, 'Game %d does not exists' % gameId))\n        self.gameDB.remove(game)\n        return defer.succeed('')\n\n    def docall_addPlayer(self, gameId, slot, name, username, session):\n\n        def check_cb(result):\n            if result:\n                game['currentPlayers'] += 1\n                return defer.succeed('')\n            else:\n                return defer.fail(Fault(SESSION_INVALID, 'Users session is invalid!'))\n        game = self.gameDB.get(gameId, False)\n        if not game:\n            return defer.fail(Fault(NO_GAME, 'Game %d does not exists' % gameId))\n        d = self.db.check_user_session(username, session)\n        d.addCallback(check_cb)\n        return d\n\n    def docall_delPlayer(self, gameId, slot):\n        game = self.gameDB.get(gameId, False)\n        if not game:\n            return defer.fail(Fault(NO_GAME, 'Game %d does not exists' % gameId))\n        game['currentPlayers'] -= 1\n        return defer.succeed('')\n\n    def docall_updatePlayer(self, gameId, slot, name):\n        return defer.succeed('')\n\n    def docall_list(self, maxgames=9999):\n        maxgames = int(maxgames)\n        games = []\n        for game in self.gameDB.itervalues():\n            if not game['description']:\n                continue\n            games.append({'host': game['host'], 'port': game['port'], 'description': game['description'], 'currentPlayers': game['currentPlayers'], 'maxPlayers': game['maxPlayers'], 'multiVer': game['multiVer'], 'wzVerMajor': game['wzVerMajor'], 'wzVerMinor': game['wzVerMinor'], 'isPrivate': game['isPrivate'], 'modlist': game['modlist'], 'mapname': game['mapname'], 'hostplayer': game['hostplayer']})\n            maxgames -= 1\n            if maxgames == 0:\n                break\n        return defer.succeed(games)",
  "line_no": 33,
  "line_no_percent": "27%"
}