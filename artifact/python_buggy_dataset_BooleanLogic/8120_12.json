{
  "instruction": "This code defines models for campaigns and coupons in a Shuup e-commerce platform. To use the code, create a new Django app and add this code to the models.py file. Then, run migrations to create the necessary database tables. The models include CatalogCampaign, BasketCampaign, Coupon, and CouponUsage. CatalogCampaign and BasketCampaign are subclasses of Campaign, which is an abstract base class. CatalogCampaign represents a campaign that applies to a set of products, while BasketCampaign represents a campaign that applies to the entire basket. Coupon represents a discount code that can be applied to a basket. CouponUsage represents the usage of a coupon in an order. The models have various fields and methods for managing campaigns and coupons, including checking if a campaign or coupon is available, attaching a coupon to a campaign, and checking if a coupon can be used by a customer. The models also include logging functionality through the use of the define_log_model function.",
  "buggy_code": "import random\nimport string\nfrom django.conf import settings\nfrom django.core.exceptions import ValidationError\nfrom django.db import models\nfrom django.db.models import Q\nfrom django.utils.encoding import force_text, python_2_unicode_compatible\nfrom django.utils.timezone import now\nfrom django.utils.translation import ugettext_lazy as _\nfrom enumfields import Enum\nfrom parler.models import TranslatableModel, TranslatedFields\nfrom shuup.campaigns.consts import CAMPAIGNS_CACHE_NAMESPACE, CATALOG_FILTER_CACHE_NAMESPACE, CONTEXT_CONDITION_CACHE_NAMESPACE\nfrom shuup.campaigns.models.basket_conditions import CategoryProductsBasketCondition, ProductsInBasketCondition\nfrom shuup.campaigns.utils.campaigns import get_product_ids_and_quantities\nfrom shuup.campaigns.utils.matcher import get_matching_for_product\nfrom shuup.core import cache\nfrom shuup.core.fields import InternalIdentifierField\nfrom shuup.core.models import Category, Order, Shop\nfrom shuup.core.utils import context_cache\nfrom shuup.utils.analog import define_log_model\nfrom shuup.utils.properties import MoneyPropped\n\nclass CampaignType(Enum):\n    CATALOG = 1\n    BASKET = 2\n\nclass CampaignQueryset(models.QuerySet):\n\n    def available(self, shop=None):\n        query = Q(Q(active=True) & (Q(start_datetime__isnull=True) | Q(start_datetime__lte=now())) & (Q(end_datetime__isnull=True) | Q(end_datetime__gte=now())))\n        if shop:\n            query &= Q(shop=shop)\n        return self.filter(query)\n\nclass Campaign(MoneyPropped, TranslatableModel):\n    admin_url_suffix = None\n    shop = models.ForeignKey(Shop, verbose_name=_('shop'), help_text=_('The shop where the campaign is active.'))\n    name = models.CharField(max_length=120, verbose_name=_('name'), help_text=_('The name for this campaign.'))\n    identifier = InternalIdentifierField(unique=True)\n    active = models.BooleanField(default=False, verbose_name=_('active'), help_text=_('Check this if the campaign is currently active. Please also set a start and end date.'))\n    start_datetime = models.DateTimeField(null=True, blank=True, verbose_name=_('start date and time'), help_text=_('The date and time the campaign starts. This is only applicable if the campaign is marked as active.'))\n    end_datetime = models.DateTimeField(null=True, blank=True, verbose_name=_('end date and time'), help_text=_('The date and time the campaign ends. This is only applicable if the campaign is marked as active.'))\n    created_by = models.ForeignKey(settings.AUTH_USER_MODEL, blank=True, null=True, related_name='+', on_delete=models.SET_NULL, verbose_name=_('created by'))\n    modified_by = models.ForeignKey(settings.AUTH_USER_MODEL, blank=True, null=True, related_name='+', on_delete=models.SET_NULL, verbose_name=_('modified by'))\n    created_on = models.DateTimeField(auto_now_add=True, editable=False, verbose_name=_('created on'))\n    modified_on = models.DateTimeField(auto_now=True, editable=False, verbose_name=_('modified on'))\n    objects = CampaignQueryset.as_manager()\n\n    class Meta:\n        abstract = True\n        verbose_name = _('Campaign')\n        verbose_name_plural = _('Campaigns')\n\n    def save(self, *args, **kwargs):\n        super(Campaign, self).save(*args, **kwargs)\n        cache.bump_version(CAMPAIGNS_CACHE_NAMESPACE)\n        cache.bump_version(CONTEXT_CONDITION_CACHE_NAMESPACE)\n        cache.bump_version(CATALOG_FILTER_CACHE_NAMESPACE)\n\n    def is_available(self):\n        if not self.active:\n            return False\n        if self.start_datetime and self.end_datetime:\n            if self.start_datetime <= now() <= self.end_datetime:\n                return True\n            return False\n        elif self.start_datetime and (not self.end_datetime):\n            if self.start_datetime > now():\n                return False\n        elif not self.start_datetime and self.end_datetime:\n            if self.end_datetime < now():\n                return False\n        return True\n\n    @property\n    def type(self):\n        return CampaignType.BASKET if isinstance(self, BasketCampaign) else CampaignType.CATALOG\n\nclass CatalogCampaign(Campaign):\n    _queryset = None\n    admin_url_suffix = 'catalog_campaign'\n    conditions = models.ManyToManyField('ContextCondition', blank=True, related_name='campaign')\n    filters = models.ManyToManyField('CatalogFilter', blank=True, related_name='campaign')\n    translations = TranslatedFields(public_name=models.CharField(max_length=120, blank=True, help_text=_('The campaign name to show in the store front.')))\n\n    def __str__(self):\n        return force_text(_('Catalog Campaign: %(name)s' % dict(name=self.name)))\n\n    def save(self, *args, **kwargs):\n        super(CatalogCampaign, self).save(*args, **kwargs)\n        self.filters.update(active=self.active)\n        for f in self.filters.all():\n            for matching_product in f.get_matching_shop_products():\n                context_cache.bump_cache_for_shop_product(matching_product)\n        self.conditions.update(active=self.active)\n\n    def rules_match(self, context, shop_product, matching_catalog_filters, matching_context_conditions):\n        if not self.is_available():\n            return False\n        for filter_pk in self.filters.values_list('pk', flat=True):\n            if filter_pk not in matching_catalog_filters:\n                return False\n        for condition_pk in self.conditions.values_list('pk', flat=True):\n            if condition_pk not in matching_context_conditions:\n                return False\n        return True\n\n    @classmethod\n    def get_for_product(cls, shop_product):\n        matching_filters = get_matching_for_product(shop_product, provide_category='campaign_catalog_filter')\n        matching_conditions = get_matching_for_product(shop_product, provide_category='campaign_context_condition')\n        query_filter = Q(Q(filters__in=matching_filters) | Q(conditions__in=matching_conditions))\n        return cls.objects.available(shop=shop_product.shop).filter(query_filter).distinct()\n\n    @classmethod\n    def get_matching(cls, context, shop_product):\n        prod_ctx_cache_elements = dict(customer=context.customer.pk or 0, shop=context.shop.pk, product_id=shop_product.pk)\n        namespace = CAMPAIGNS_CACHE_NAMESPACE\n        key = '%s:%s' % (namespace, hash(frozenset(prod_ctx_cache_elements.items())))\n        cached_matching = cache.get(key, None)\n        if cached_matching is not None:\n            return cached_matching\n        from shuup.campaigns.models.matching import get_matching_context_conditions, get_matching_catalog_filters\n        matching_context_conditions = get_matching_context_conditions(context)\n        matching_catalog_filters = get_matching_catalog_filters(shop_product)\n        if not (matching_context_conditions or matching_catalog_filters):\n            return []\n        campaigns_based_on_conditions = set(cls.objects.filter(active=True, shop=context.shop, conditions__id__in=matching_context_conditions).values_list('pk', flat=True))\n        campaigns_based_on_catalog_filters = set()\n        if hasattr(cls, 'filters'):\n            campaigns_based_on_catalog_filters = set(cls.objects.filter(active=True, shop=context.shop, filters__id__in=matching_catalog_filters).values_list('pk', flat=True))\n        all_possible_campaigns_ids = campaigns_based_on_conditions | campaigns_based_on_catalog_filters\n        matching = []\n        for campaign in cls.objects.filter(id__in=all_possible_campaigns_ids):\n            if campaign.rules_match(context, shop_product, matching_catalog_filters, matching_context_conditions):\n                matching.append(campaign)\n        cache.set(key, matching, timeout=None)\n        return matching\n\nclass BasketCampaign(Campaign):\n    admin_url_suffix = 'basket_campaign'\n    basket_line_text = models.CharField(max_length=120, verbose_name=_('basket line text'), help_text=_('This text will be shown in basket.'))\n    conditions = models.ManyToManyField('BasketCondition', blank=True, related_name='campaign')\n    coupon = models.OneToOneField('Coupon', null=True, blank=True, related_name='campaign', verbose_name=_('coupon'))\n    translations = TranslatedFields(public_name=models.CharField(max_length=120, verbose_name=_('public name'), help_text=_('The campaign name to show in the store front.')))\n\n    def __str__(self):\n        return force_text(_('Basket Campaign: %(name)s' % dict(name=self.name)))\n\n    def save(self, *args, **kwargs):\n        if self.coupon:\n            code_count_for_shop = BasketCampaign.objects.filter(active=True, shop_id=self.shop.id, coupon__code=self.coupon.code)\n            if not self.id and code_count_for_shop.exists():\n                raise ValidationError(_('Can not have multiple active campaigns with same code.'))\n            if self.id and code_count_for_shop.exclude(coupon_id=self.coupon.id).exists():\n                raise ValidationError(_('Can not have multiple active campaigns with same code.'))\n        super(BasketCampaign, self).save(*args, **kwargs)\n        self.conditions.update(active=self.active)\n\n    @classmethod\n    def get_for_product(cls, shop_product):\n        matching_conditions = get_matching_for_product(shop_product, provide_category='campaign_basket_condition')\n        matching_effects = get_matching_for_product(shop_product, provide_category='campaign_basket_discount_effect_form')\n        matching_line_effects = get_matching_for_product(shop_product, provide_category='campaign_basket_line_effect_form')\n        effects_q = Q(Q(line_effects__id__in=matching_line_effects) | Q(discount_effects__id__in=matching_effects))\n        matching_q = Q(Q(conditions__in=matching_conditions) | effects_q)\n        return cls.objects.available(shop=shop_product.shop).filter(matching_q).distinct()\n\n    @classmethod\n    def get_matching(cls, basket, lines):\n        matching = []\n        exclude_condition_ids = set()\n        product_id_to_qty = get_product_ids_and_quantities(basket)\n        products_in_basket_conditions_to_check = set(ProductsInBasketCondition.objects.filter(products__id__in=product_id_to_qty.keys()).values_list('id', flat=True))\n        exclude_condition_ids |= set(ProductsInBasketCondition.objects.exclude(id__in=products_in_basket_conditions_to_check).values_list('id', flat=True))\n        categories = set(Category.objects.filter(shop_products__product_id__in=product_id_to_qty.keys()).values_list('id', flat=True))\n        category_products_in_basket_to_check = set(CategoryProductsBasketCondition.objects.filter(categories__in=categories).values_list('id', flat=True))\n        exclude_condition_ids |= set(CategoryProductsBasketCondition.objects.exclude(id__in=category_products_in_basket_to_check).values_list('id', flat=True))\n        queryset = cls.objects.filter(active=True, shop=basket.shop)\n        if exclude_condition_ids:\n            queryset = queryset.exclude(conditions__id__in=exclude_condition_ids)\n        for campaign in queryset.prefetch_related('conditions'):\n            if campaign.rules_match(basket, lines):\n                matching.append(campaign)\n        return matching\n\n    def rules_match(self, basket, lines):\n        \"\"\"\n        Check if basket rules match.\n\n        They will not match if\n        1) The campaign is not active\n        2) The campaign has attached coupon\n           which doesn't match or is not active\n        3) Any of the attached rules doesn't match\n        \"\"\"\n        if not self.is_available():\n            return False\n        if self.coupon and (not (self.coupon.active or self.coupon.code.upper() in [c.upper() for c in basket.codes])):\n            return False\n        for rule in self.conditions.all():\n            if not rule.matches(basket, lines):\n                return False\n        return True\n\nclass CouponUsage(models.Model):\n    coupon = models.ForeignKey('Coupon', related_name='usages')\n    order = models.ForeignKey(Order, related_name='coupon_usages')\n    created_by = models.ForeignKey(settings.AUTH_USER_MODEL, blank=True, null=True, related_name='+', on_delete=models.SET_NULL, verbose_name=_('created by'))\n    modified_by = models.ForeignKey(settings.AUTH_USER_MODEL, blank=True, null=True, related_name='+', on_delete=models.SET_NULL, verbose_name=_('modified by'))\n    created_on = models.DateTimeField(auto_now_add=True, editable=False, verbose_name=_('created on'))\n    modified_on = models.DateTimeField(auto_now=True, editable=False, verbose_name=_('modified on'))\n\n    @classmethod\n    def add_usage(cls, order, coupon):\n        return cls.objects.create(order=order, coupon=coupon)\n\n@python_2_unicode_compatible\nclass Coupon(models.Model):\n    admin_url_suffix = 'coupon'\n    name_field = 'code'\n    search_fields = ['code']\n    code = models.CharField(max_length=12)\n    usage_limit_customer = models.PositiveIntegerField(blank=True, null=True, verbose_name=_('usage limit per customer'), help_text=_('Limit the amount of usages per a single customer.'))\n    usage_limit = models.PositiveIntegerField(blank=True, null=True, verbose_name=_('usage limit'), help_text=_('Set the absolute limit of usages for this coupon. If the limit is zero (0) coupon cannot be used.'))\n    active = models.BooleanField(default=False, verbose_name=_('is active'))\n    created_by = models.ForeignKey(settings.AUTH_USER_MODEL, blank=True, null=True, related_name='+', on_delete=models.SET_NULL, verbose_name=_('created by'))\n    modified_by = models.ForeignKey(settings.AUTH_USER_MODEL, blank=True, null=True, related_name='+', on_delete=models.SET_NULL, verbose_name=_('modified by'))\n    created_on = models.DateTimeField(auto_now_add=True, editable=False, verbose_name=_('created on'))\n    modified_on = models.DateTimeField(auto_now=True, editable=False, verbose_name=_('modified on'))\n\n    def save(self, **kwargs):\n        campaign = BasketCampaign.objects.filter(active=True, coupon_id=self.id).first()\n        if campaign and BasketCampaign.objects.filter(active=True, shop_id=campaign.shop.id, coupon__code=self.code).exclude(id=campaign.id).exists():\n            raise ValidationError(_('Can not have multiple active campaigns with same code.'))\n        return super(Coupon, self).save(**kwargs)\n\n    @classmethod\n    def generate_code(cls, length=6):\n        if length > 12:\n            length = 12\n        return ''.join((random.choice(string.ascii_uppercase + string.digits) for _ in range(length)))\n\n    @property\n    def exhausted(self):\n        val = bool(self.usage_limit and self.usages.count() >= self.usage_limit)\n        return val\n\n    @property\n    def attached(self):\n        return BasketCampaign.objects.filter(coupon=self).exists()\n\n    def attach_to_campaign(self, campaign):\n        if not self.attached:\n            self.campaign = campaign\n\n    @classmethod\n    def is_usable(cls, code, customer):\n        try:\n            code = cls.objects.get(code__iexact=code, active=True)\n            return code.can_use_code(customer)\n        except cls.DoesNotExist:\n            return False\n\n    def can_use_code(self, customer):\n        \"\"\"\n        Check if customer can use the code\n\n        :param customer:\n        :type customer: `Contact` or None\n        :rtype: True|False\n        \"\"\"\n        if not self.active:\n            return False\n        if not self.attached:\n            return False\n        if self.usage_limit_customer:\n            if not customer or customer.is_anonymous:\n                return False\n            if self.usages.filter(order__customer=customer, coupon=self).count() >= self.usage_limit_customer:\n                return False\n        return not self.exhausted\n\n    def use(self, order):\n        return CouponUsage.add_usage(order=order, coupon=self)\n\n    def increase_customer_usage_limit_by(self, amount):\n        if self.usage_limit_customer:\n            new_limit = self.usage_limit_customer + amount\n        else:\n            new_limit = self.usages.count() + amount\n        self.usage_limit_customer = new_limit\n\n    def increase_usage_limit_by(self, amount):\n        self.usage_limit = self.usage_limit + amount if self.usage_limit else self.usages.count() + amount\n\n    def has_been_used(self, usage_count=1):\n        \"\"\" See if code is used the times given \"\"\"\n        return CouponUsage.objects.filter(coupon=self).count() >= usage_count\n\n    def __str__(self):\n        return self.code\nCatalogCampaignLogEntry = define_log_model(CatalogCampaign)\nBasketCampaignLogEntry = define_log_model(BasketCampaign)\nCouponLogEntry = define_log_model(Coupon)\nCouponUsageLogEntry = define_log_model(CouponUsage)",
  "line_no": 289,
  "line_no_percent": "94%"
}