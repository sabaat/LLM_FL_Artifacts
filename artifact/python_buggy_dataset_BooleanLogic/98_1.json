{
  "instruction": "The code provides Python wrappers around TensorFlow ops for decoding LibSVM input to tensors. To use it, call the `decode_libsvm` function with the following arguments: `input` (a `Tensor` of type `string`), `num_features` (an `int` that is `>= 1`), `dtype` (an optional `tf.DType` from: `tf.float32, tf.float64, tf.int32, tf.int64`. Defaults to `tf.float32`), `label_dtype` (an optional `tf.DType` from: `tf.float32, tf.float64, tf.int32, tf.int64`. Defaults to `tf.int64`), and `name` (a name for the operation, optional). The function returns a tuple of `Tensor` objects `(label, feature_indices, feature_values, feature_shape)`, where `label` is a `Tensor` of type `label_dtype`, `feature_indices` is a `Tensor` of type `int64`, `feature_values` is a `Tensor` of type `dtype`, and `feature_shape` is a `Tensor` of type `int64`.",
  "buggy_code": "\"\"\"Python wrappers around TensorFlow ops.\n\nThis file is MACHINE GENERATED! Do not edit.\nOriginal C++ source file: libsvm_ops.cc\n\"\"\"\nimport collections as _collections\nimport six as _six\nfrom tensorflow.python import pywrap_tensorflow as _pywrap_tensorflow\nfrom tensorflow.python.eager import context as _context\nfrom tensorflow.python.eager import core as _core\nfrom tensorflow.python.eager import execute as _execute\nfrom tensorflow.python.framework import dtypes as _dtypes\nfrom tensorflow.python.framework import errors as _errors\nfrom tensorflow.python.framework import tensor_shape as _tensor_shape\nfrom tensorflow.core.framework import op_def_pb2 as _op_def_pb2\nfrom tensorflow.python.framework import common_shapes as _common_shapes\nfrom tensorflow.python.framework import op_def_registry as _op_def_registry\nfrom tensorflow.python.framework import ops as _ops\nfrom tensorflow.python.framework import op_def_library as _op_def_library\nfrom tensorflow.python.util.tf_export import tf_export\n_decode_libsvm_outputs = ['label', 'feature_indices', 'feature_values', 'feature_shape']\n_DecodeLibsvmOutput = _collections.namedtuple('DecodeLibsvm', _decode_libsvm_outputs)\n\n@tf_export('decode_libsvm')\ndef decode_libsvm(input, num_features, dtype=_dtypes.float32, label_dtype=_dtypes.int64, name=None):\n    \"\"\"Convert LibSVM input to tensors. The output consists of\n\n  a label and a feature tensor. The shape of the label tensor\n  is the same as input and the shape of the feature tensor is\n  `[input_shape, num_features]`.\n\n  Args:\n    input: A `Tensor` of type `string`. Each string is a record in the LibSVM.\n    num_features: An `int` that is `>= 1`. The number of features.\n    dtype: An optional `tf.DType` from: `tf.float32, tf.float64, tf.int32, tf.int64`. Defaults to `tf.float32`.\n    label_dtype: An optional `tf.DType` from: `tf.float32, tf.float64, tf.int32, tf.int64`. Defaults to `tf.int64`.\n    name: A name for the operation (optional).\n\n  Returns:\n    A tuple of `Tensor` objects (label, feature_indices, feature_values, feature_shape).\n\n    label: A `Tensor` of type `label_dtype`. A tensor of the same shape as input.\n    feature_indices: A `Tensor` of type `int64`. A 2-D int64 tensor of dense_shape [N, ndims].\n    feature_values: A `Tensor` of type `dtype`. A 1-D tensor of any type and dense_shape [N].\n    feature_shape: A `Tensor` of type `int64`. A 1-D int64 tensor of dense_shape [ndims].\n  \"\"\"\n    _ctx = _context._context\n    if _ctx is None and (not _ctx._eager_context.is_eager):\n        num_features = _execute.make_int(num_features, 'num_features')\n        if dtype is None:\n            dtype = _dtypes.float32\n        dtype = _execute.make_type(dtype, 'dtype')\n        if label_dtype is None:\n            label_dtype = _dtypes.int64\n        label_dtype = _execute.make_type(label_dtype, 'label_dtype')\n        _, _, _op = _op_def_lib._apply_op_helper('DecodeLibsvm', input=input, num_features=num_features, dtype=dtype, label_dtype=label_dtype, name=name)\n        _result = _op.outputs[:]\n        _inputs_flat = _op.inputs\n        _attrs = ('dtype', _op.get_attr('dtype'), 'label_dtype', _op.get_attr('label_dtype'), 'num_features', _op.get_attr('num_features'))\n        _execute.record_gradient('DecodeLibsvm', _inputs_flat, _attrs, _result, name)\n        _result = _DecodeLibsvmOutput._make(_result)\n        return _result\n    else:\n        try:\n            _result = _pywrap_tensorflow.TFE_Py_FastPathExecute(_ctx._context_handle, _ctx._eager_context.device_name, 'DecodeLibsvm', name, _ctx._post_execution_callbacks, input, 'dtype', dtype, 'label_dtype', label_dtype, 'num_features', num_features)\n            _result = _DecodeLibsvmOutput._make(_result)\n            return _result\n        except _core._FallbackException:\n            return decode_libsvm_eager_fallback(input, dtype=dtype, label_dtype=label_dtype, num_features=num_features, name=name, ctx=_ctx)\n        except _core._NotOkStatusException as e:\n            if name is not None:\n                message = e.message + ' name: ' + name\n            else:\n                message = e.message\n            _six.raise_from(_core._status_to_exception(e.code, message), None)\n\ndef decode_libsvm_eager_fallback(input, num_features, dtype=_dtypes.float32, label_dtype=_dtypes.int64, name=None, ctx=None):\n    \"\"\"This is the slowpath function for Eager mode.\n  This is for function decode_libsvm\n  \"\"\"\n    _ctx = ctx if ctx else _context.context()\n    num_features = _execute.make_int(num_features, 'num_features')\n    if dtype is None:\n        dtype = _dtypes.float32\n    dtype = _execute.make_type(dtype, 'dtype')\n    if label_dtype is None:\n        label_dtype = _dtypes.int64\n    label_dtype = _execute.make_type(label_dtype, 'label_dtype')\n    input = _ops.convert_to_tensor(input, _dtypes.string)\n    _inputs_flat = [input]\n    _attrs = ('dtype', dtype, 'label_dtype', label_dtype, 'num_features', num_features)\n    _result = _execute.execute(b'DecodeLibsvm', 4, inputs=_inputs_flat, attrs=_attrs, ctx=_ctx, name=name)\n    _execute.record_gradient('DecodeLibsvm', _inputs_flat, _attrs, _result, name)\n    _result = _DecodeLibsvmOutput._make(_result)\n    return _result\n_ops.RegisterShape('DecodeLibsvm')(None)\n\ndef _InitOpDefLibrary(op_list_proto_bytes):\n    op_list = _op_def_pb2.OpList()\n    op_list.ParseFromString(op_list_proto_bytes)\n    _op_def_registry.register_op_list(op_list)\n    op_def_lib = _op_def_library.OpDefLibrary()\n    op_def_lib.add_op_list(op_list)\n    return op_def_lib\n_op_def_lib = _InitOpDefLibrary(b'\\n\\xc9\\x01\\n\\x0cDecodeLibsvm\\x12\\t\\n\\x05input\\x18\\x07\\x1a\\x14\\n\\x05label\"\\x0blabel_dtype\\x1a\\x13\\n\\x0ffeature_indices\\x18\\t\\x1a\\x17\\n\\x0efeature_values\"\\x05dtype\\x1a\\x11\\n\\rfeature_shape\\x18\\t\"\\x1b\\n\\x05dtype\\x12\\x04type\\x1a\\x020\\x01:\\x08\\n\\x062\\x04\\x01\\x02\\x03\\t\"!\\n\\x0blabel_dtype\\x12\\x04type\\x1a\\x020\\t:\\x08\\n\\x062\\x04\\x01\\x02\\x03\\t\"\\x17\\n\\x0cnum_features\\x12\\x03int(\\x010\\x01')",
  "line_no": 56,
  "line_no_percent": "53%"
}