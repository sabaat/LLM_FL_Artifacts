{
  "instruction": "The code is a Python script that parses metadata.csv files in a given SIPPath. To use the script, import the necessary modules and call the function `parseMetadata(SIPPath)` with the path to the SIP as an argument. The function returns a dictionary of metadata, where the keys are filenames and the values are ordered dictionaries of metadata values. The script can be run from the command line by passing the path to the SIP as an argument.",
  "buggy_code": "import collections\nimport csv\nimport os\nimport sys\nimport traceback\nimport archivematicaFunctions\nfrom custom_handlers import get_script_logger\nfrom sharedVariablesAcrossModules import sharedVariablesAcrossModules\n\ndef parseMetadata(SIPPath):\n    \"\"\"\n    Parse all metadata.csv files in SIPPath.\n\n    Looking for metadata.csvs in metadata/ and\n    objects/metadata/transfers/<transfer name>/metadata/\n\n    See parseMetadataCSV for details on parsing.\n\n    :param SIPPath: Path to the SIP\n    :return: {<filename>: OrderedDict(key: [values]) }\n    \"\"\"\n    all_metadata = {}\n    metadata_csvs = archivematicaFunctions.find_metadata_files(SIPPath, 'metadata.csv')\n    for metadataCSVFilePath in metadata_csvs:\n        try:\n            csv_metadata = parseMetadataCSV(metadataCSVFilePath)\n        except Exception:\n            (print >> sys.stderr, 'error parsing: ', metadataCSVFilePath)\n            traceback.print_exc(file=sys.stderr)\n            sharedVariablesAcrossModules.globalErrorCount += 1\n            continue\n        for entry, values in csv_metadata.iteritems():\n            if entry in all_metadata and all_metadata[entry] != values:\n                (print >> sys.stderr, 'Metadata for', entry, 'being updated. Old:', all_metadata[entry], 'New:', values)\n            existing = all_metadata.get(entry, collections.OrderedDict())\n            existing.update(values)\n            all_metadata[entry] = existing\n    return all_metadata\n\ndef parseMetadataCSV(metadataCSVFilePath):\n    \"\"\"\n    Parses the metadata.csv into a dict with entries for each file.\n\n    Each file's entry is an OrderedDict containing the column header and a list of values for each column.\n\n    Example CSV:\n    Filename,dc.title,dc.type,dc.type,Other metadata\n    objects/foo.jpg,Foo,Photograph,Still Image,Taken on a sunny day\n    objects/bar/,Bar,Photograph,Still Image,All taken on a rainy day\n\n    Produces:\n    {\n        'objects/foo.jpg': OrderedDict(dc.title=[Foo], dc.type=[Photograph, Still Image], Other metadata=[Taken on a sunny day])\n        'objects/bar': OrderedDict(dc.title=[Bar], dc.date=[Photograph, Still Image], Other metadata=[All taken on a rainy day])\n    }\n\n    :param metadataCSVFilePath: Path to the metadata CSV to parse\n    :return: {<filename>: OrderedDict(<metadata name>: [<metadata value>]) }\n    \"\"\"\n    metadata = {}\n    with open(metadataCSVFilePath, 'rbU') as f:\n        reader = csv.reader(f)\n        header = reader.next()\n        header = [h.strip() for h in header[1:]]\n        for row in reader:\n            if not row:\n                continue\n            entry_name = row[0]\n            if entry_name.endswith('/'):\n                entry_name = entry_name[:-1]\n            row = row[1:]\n            values = archivematicaFunctions.OrderedListsDict(zip(header, row))\n            if entry_name in metadata or metadata[entry_name] != values:\n                (print >> sys.stderr, 'Metadata for', entry_name, 'being overwritten. Old:', metadata[entry_name], 'New:', values)\n            metadata[entry_name] = values\n    return collections.OrderedDict(metadata)\nif __name__ == '__main__':\n    logger = get_script_logger('archivematica.mcp.client.createMETSMetadataCSV')\n    parseMetadata(sys.argv[1])",
  "line_no": 77,
  "line_no_percent": "97%"
}