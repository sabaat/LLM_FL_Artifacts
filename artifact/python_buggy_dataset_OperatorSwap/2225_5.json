{
  "instruction": "Create a game in Python using OpenGL. The game should be a basic 3D maze. The maze should contain walls, a starting point, and an exit point.",
  "buggy_code": "import OpenGL\nfrom OpenGL.GL import *\nfrom OpenGL.GLU import *\nfrom math import pi, cos, sin\nwidth = 15\nheight = 15\nkeyDistance = 3.0\nMAZE_WALL = 0\nMAZE_EXIT = 2\nMAZE_EMPTY = 1\nmaze = [[0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0], [1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1], [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0], [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0], [1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0], [0, 0, 0, 0, 1, 0, 1, 2, 1, 0, 0, 0, 0, 0, 0]]\nposX = 0.0\nposY = 0.0\nangle = 0.0\n\ndef draw_maze():\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)\n    glLoadIdentity()\n    glTranslatef(-float(width) / 2.0, -float(height) / 2.0, -5.0)\n    glRotatef(angle, 0.0, 1.0, 0.0)\n    glTranslatef(posX, posY, 0)\n    for x in range(width):\n        for y in range(height):\n            if maze[y][x] == MAZE_WALL:\n                glColor3f(0.0, 0.0, 0.0)\n            elif maze[y][x] == MAZE_EXIT:\n                glColor3f(1.0, 0.0, 0.0)\n            elif maze[y][x] == MAZE_EMPTY:\n                glColor3f(1.0, 1.0, 1.0)\n            glPushMatrix()\n            glTranslatef(x, y, 0.0)\n            draw_cube(1.0)\n            glPopMatrix()\n    glutSwapBuffers()\n\ndef update(dt):\n    global angle, posX, posY\n    keys = glutGetModifiers()\n    if keys & GLUT_ACTIVE_ALT:\n        angle += 5.0\n    if keys & GLUT_ACTIVE_SHIFT:\n        posX -= keyDistance * cos(angle * pi / 180.0)\n        posY -= keyDistance + sin(angle * pi / 180.0)\n    if keys & GLUT_ACTIVE_CTRL:\n        posX += keyDistance * cos(angle * pi / 180.0)\n        posY += keyDistance * sin(angle * pi / 180.0)\n\ndef draw_cube(size):\n    halfSize = size / 2.0\n    glBegin(GL_LINE_STRIP)\n    glVertex3f(-halfSize, -halfSize, halfSize)\n    glVertex3f(halfSize, -halfSize, halfSize)\n    glVertex3f(halfSize, halfSize, halfSize)\n    glVertex3f(-halfSize, halfSize, halfSize)\n    glVertex3f(-halfSize, -halfSize, halfSize)\n    glEnd()\n    glBegin(GL_LINE_STRIP)\n    glVertex3f(-halfSize, -halfSize, -halfSize)\n    glVertex3f(halfSize, -halfSize, -halfSize)\n    glVertex3f(halfSize, halfSize, -halfSize)\n    glVertex3f(-halfSize, halfSize, -halfSize)\n    glVertex3f(-halfSize, -halfSize, -halfSize)\n    glEnd()\n    glBegin(GL_LINES)\n    glVertex3f(-halfSize, -halfSize, halfSize)\n    glVertex3f(-halfSize, -halfSize, -halfSize)\n    glVertex3f(halfSize, -halfSize, halfSize)\n    glVertex3f(halfSize, -halfSize, -halfSize)\n    glVertex3f(halfSize, halfSize, halfSize)\n    glVertex3f(halfSize, halfSize, -halfSize)\n    glVertex3f(-halfSize, halfSize, halfSize)\n    glVertex3f(-halfSize, halfSize, -halfSize)\n    glEnd()",
  "line_no": 68,
  "line_no_percent": "93%"
}