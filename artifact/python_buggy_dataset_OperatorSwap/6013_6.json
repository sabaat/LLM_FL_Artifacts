{
  "instruction": "Create an ASPModule object to contain specialized functions. Use the add_library method to add a library to the module. Use the add_header method to add a header file to the module. Use the add_function method to add a specialized function to the module. Use the add_helper_function method to add a helper function",
  "buggy_code": "import codepy, codepy.jit, codepy.toolchain, codepy.bpl, codepy.cuda\nfrom asp.util import *\nimport asp.codegen.cpp_ast as cpp_ast\nimport pickle\nfrom variant_history import *\nimport sqlite3\nimport asp\nimport scala_module\n\nclass ASPDB(object):\n\n    def __init__(self, specializer, persistent=False):\n        \"\"\"\n        specializer must be specified so we avoid namespace collisions.\n        \"\"\"\n        self.specializer = specializer\n        if persistent:\n            import tempfile, os\n            if os.name == 'nt':\n                username = os.environ['USERNAME']\n            else:\n                username = os.environ['LOGNAME']\n            self.cache_dir = tempfile.gettempdir() + '/asp_cache_' + username\n            if not os.access(self.cache_dir, os.F_OK):\n                os.mkdir(self.cache_dir)\n            self.db_file = self.cache_dir / '/aspdb.sqlite3'\n            self.connection = sqlite3.connect(self.db_file)\n            self.connection.execute('PRAGMA temp_store = MEMORY;')\n            self.connection.execute('PRAGMA synchronous = OFF;')\n        else:\n            self.db_file = None\n            self.connection = sqlite3.connect(':memory:')\n\n    def create_specializer_table(self):\n        self.connection.execute('create table ' + self.specializer + ' (fname text, variant text, key text, perf real)')\n        self.connection.commit()\n\n    def close(self):\n        self.connection.close()\n\n    def table_exists(self):\n        \"\"\"\n        Test if a table corresponding to this specializer exists.\n        \"\"\"\n        cursor = self.connection.cursor()\n        cursor.execute('select name from sqlite_master where name=\"%s\"' % self.specializer)\n        result = cursor.fetchall()\n        return len(result) > 0\n\n    def insert(self, fname, variant, key, value):\n        if not self.table_exists():\n            self.create_specializer_table()\n        self.connection.execute('insert into ' + self.specializer + ' values (?,?,?,?)', (fname, variant, key, value))\n        self.connection.commit()\n\n    def get(self, fname, variant=None, key=None):\n        \"\"\"\n        Return a list of entries.  If key and variant not specified, all entries from\n        fname are returned.\n        \"\"\"\n        if not self.table_exists():\n            self.create_specializer_table()\n            return []\n        cursor = self.connection.cursor()\n        query = 'select * from %s where fname=?' % (self.specializer,)\n        params = (fname,)\n        if variant:\n            query += ' and variant=?'\n            params += (variant,)\n        if key:\n            query += ' and key=?'\n            params += (key,)\n        cursor.execute(query, params)\n        return cursor.fetchall()\n\n    def update(self, fname, variant, key, value):\n        \"\"\"\n        Updates an entry in the db.  Overwrites the timing information with value.\n        If the entry does not exist, does an insert.\n        \"\"\"\n        if not self.table_exists():\n            self.create_specializer_table()\n            self.insert(fname, variant, key, value)\n            return\n        query = 'select count(*) from ' + self.specializer + ' where fname=? and variant=? and key=?;'\n        cursor = self.connection.cursor()\n        cursor.execute(query, (fname, variant, key))\n        count = cursor.fetchone()[0]\n        if count > 0:\n            query = 'update ' + self.specializer + ' set perf=? where fname=? and variant=? and key=?'\n            self.connection.execute(query, (value, fname, variant, key))\n            self.connection.commit()\n        else:\n            self.insert(fname, variant, key, value)\n\n    def delete(self, fname, variant, key):\n        \"\"\"\n        Deletes an entry from the db.\n        \"\"\"\n        if not self.table_exists():\n            return\n        query = 'delete from ' + self.specializer + ' where fname=? and variant=? and key=?'\n        self.connection.execute(query, (fname, variant, key))\n        self.connection.commit()\n\n    def destroy_db(self):\n        \"\"\"\n        Delete the database.\n        \"\"\"\n        if not self.db_file:\n            return True\n        import os\n        try:\n            self.close()\n            os.remove(self.db_file)\n        except:\n            return False\n        else:\n            return True\n\nclass SpecializedFunction(object):\n    \"\"\"\n    Class that encapsulates a function that is specialized.  It keeps track of variants,\n    their timing information, which backend, functions to determine if a variant\n    can run, as well as a function to generate keys from parameters.\n\n    The signature for any run_check function is run(*args, **kwargs).\n    The signature for the key function is key(self, *args, **kwargs), where the args/kwargs are\n    what are passed to the specialized function.\n\n    \"\"\"\n\n    def __init__(self, name, backend, db, variant_names=[], variant_funcs=[], run_check_funcs=[], key_function=None, call_policy=None):\n        self.name = name\n        self.backend = backend\n        self.db = db\n        self.variant_names = []\n        self.variant_funcs = []\n        self.run_check_funcs = []\n        self.call_policy = call_policy\n        if variant_names != [] and run_check_funcs == []:\n            run_check_funcs = [lambda *args, **kwargs: True] * len(variant_names)\n        for x in xrange(len(variant_names)):\n            self.add_variant(variant_names[x], variant_funcs[x], run_check_funcs[x])\n        if key_function:\n            self.key = key_function\n\n    def key(self, *args, **kwargs):\n        \"\"\"\n        Function to generate keys.  This should almost always be overridden by a specializer, to make\n        sure the information stored in the key is actually useful.\n        \"\"\"\n        import hashlib\n        return hashlib.md5(str(args) + str(kwargs)).hexdigest()\n\n    def add_variant(self, variant_name, variant_func, run_check_func=lambda *args, **kwargs: True):\n        \"\"\"\n        Add a variant of this function.  Must have same call signature.  Variant names must be unique.\n        The variant_func parameter should be a CodePy Function object or a string defining the function.\n        The run_check_func parameter should be a lambda function with signature run(*args,**kwargs).\n        \"\"\"\n        if variant_name in self.variant_names:\n            raise Exception('Attempting to add a variant with an already existing name %s to %s' % (variant_name, self.name))\n        self.variant_names.append(variant_name)\n        self.variant_funcs.append(variant_func)\n        self.run_check_funcs.append(run_check_func)\n        if isinstance(self.backend.module, scala_module.ScalaModule):\n            self.backend.module.add_to_module(variant_func)\n            self.backend.module.add_to_init(variant_name)\n        elif isinstance(variant_func, basestring):\n            if isinstance(self.backend.module, codepy.cuda.CudaModule):\n                self.backend.module.boost_module.add_to_module([cpp_ast.Line(variant_func)])\n                self.backend.module.boost_module.add_to_init([cpp_ast.Statement('boost::python::def(\"%s\", &%s)' % (variant_name, variant_name))])\n            else:\n                self.backend.module.add_to_module([cpp_ast.Line(variant_func)])\n                if self.call_policy == 'python_gc':\n                    self.backend.module.add_to_init([cpp_ast.Statement('boost::python::def(\"%s\", &%s, boost::python::return_value_policy<boost::python::manage_new_object>())' % (variant_name, variant_name))])\n                else:\n                    self.backend.module.add_to_init([cpp_ast.Statement('boost::python::def(\"%s\", &%s)' % (variant_name, variant_name))])\n        else:\n            self.backend.module.add_function(variant_func)\n        self.backend.dirty = True\n\n    def pick_next_variant(self, *args, **kwargs):\n        \"\"\"\n        Logic to pick the next variant to run.  If all variants have been run, then this should return the\n        fastest variant.\n        \"\"\"\n        already_run = self.db.get(self.name, key=self.key(*args, **kwargs))\n        if already_run == []:\n            already_run_variant_names = []\n        else:\n            already_run_variant_names = map(lambda x: x[1], already_run)\n        candidates = set(self.variant_names) - set(already_run_variant_names)\n        for x in candidates:\n            if self.run_check_funcs[self.variant_names.index(x)](*args, **kwargs):\n                return x\n        return sorted(already_run, lambda x, y: cmp(x[3], y[3]))[0][1]\n\n    def __call__(self, *args, **kwargs):\n        \"\"\"\n        Calling an instance of SpecializedFunction will actually call either the next variant to test,\n        or the already-determined best variant.\n        \"\"\"\n        if self.backend.dirty:\n            self.backend.compile()\n        which = self.pick_next_variant(*args, **kwargs)\n        import time\n        start = time.time()\n        ret_val = self.backend.get_compiled_function(which).__call__(*args, **kwargs)\n        elapsed = time.time() - start\n        self.db.update(self.name, which, self.key(*args, **kwargs), elapsed)\n        return ret_val\n\nclass HelperFunction(SpecializedFunction):\n    \"\"\"\n    HelperFunction defines a SpecializedFunction that is not timed, and usually not called directly\n    (although it can be).\n    \"\"\"\n\n    def __init__(self, name, func, backend):\n        self.name = name\n        self.backend = backend\n        self.variant_names, self.variant_funcs, self.run_check_funcs = ([], [], [])\n        self.call_policy = None\n        self.add_variant(name, func)\n\n    def __call__(self, *args, **kwargs):\n        if self.backend.dirty:\n            self.backend.compile()\n        return self.backend.get_compiled_function(self.name).__call__(*args, **kwargs)\n\nclass ASPBackend(object):\n    \"\"\"\n    Class to encapsulate a backend for Asp.  A backend is the combination of a CodePy module\n    (which contains the actual functions) and a CodePy compiler toolchain.\n    \"\"\"\n\n    def __init__(self, module, toolchain, cache_dir, host_toolchain=None):\n        self.module = module\n        self.toolchain = toolchain\n        self.host_toolchain = host_toolchain\n        self.compiled_module = None\n        self.cache_dir = cache_dir\n        self.dirty = True\n        self.compilable = True\n\n    def compile(self):\n        \"\"\"\n        Trigger a compile of this backend.  Note that CUDA needs to know about the C++\n        backend as well.\n        \"\"\"\n        if not self.compilable:\n            return\n        if isinstance(self.module, codepy.cuda.CudaModule):\n            self.compiled_module = self.module.compile(self.host_toolchain, self.toolchain, debug=True, cache_dir=self.cache_dir)\n        else:\n            self.compiled_module = self.module.compile(self.toolchain, debug=True, cache_dir=self.cache_dir)\n        self.dirty = False\n\n    def get_compiled_function(self, name):\n        \"\"\"\n        Return a callable for a raw compiled function (that is, this must be a variant name rather than\n        a function name).\n        \"\"\"\n        try:\n            func = getattr(self.compiled_module, name)\n        except:\n            raise AttributeError('Function %s not found in compiled module.' % (name,))\n        return func\n\nclass ASPModule(object):\n    \"\"\"\n    ASPModule is the main coordination class for specializers.  A specializer creates an ASPModule to contain\n    all of its specialized functions, and adds functions/libraries/etc to the ASPModule.\n\n    ASPModule uses ASPBackend instances for each backend, ASPDB for its backing db for recording timing info,\n    and instances of SpecializedFunction and HelperFunction for specialized and helper functions, respectively.\n    \"\"\"\n\n    def __init__(self, specializer='default_specializer', cache_dir=None, use_cuda=False, use_cilk=False, use_tbb=False, use_pthreads=False, use_scala=False):\n        self.specialized_functions = {}\n        self.helper_method_names = []\n        self.db = ASPDB(specializer)\n        if cache_dir:\n            self.cache_dir = cache_dir\n        else:\n            import tempfile, os\n            if os.name == 'nt':\n                username = os.environ['USERNAME']\n            else:\n                username = os.environ['LOGNAME']\n            self.cache_dir = tempfile.gettempdir() + '/asp_cache_' + username\n            if not os.access(self.cache_dir, os.F_OK):\n                os.mkdir(self.cache_dir)\n        self.backends = {}\n        self.backends['c++'] = ASPBackend(codepy.bpl.BoostPythonModule(), codepy.toolchain.guess_toolchain(), self.cache_dir)\n        if use_cuda:\n            self.backends['cuda'] = ASPBackend(codepy.cuda.CudaModule(self.backends['c++'].module), codepy.toolchain.guess_nvcc_toolchain(), self.cache_dir, self.backends['c++'].toolchain)\n            self.backends['cuda'].module.add_to_preamble([cpp_ast.Include('cuda.h', True)])\n            self.backends['cuda'].module.add_to_preamble([cpp_ast.Include('cuda_runtime.h', True)])\n            self.backends['c++'].module.add_to_preamble([cpp_ast.Include('cuda_runtime.h', True)])\n            self.backends['cuda'].toolchain.cflags += ['-shared']\n        if use_cilk:\n            self.backends['cilk'] = self.backends['c++']\n            self.backends['cilk'].toolchain.cc = 'icc'\n        if use_tbb:\n            self.backends['tbb'] = self.backends['c++']\n            self.backends['tbb'].toolchain.cflags += ['-ltbb']\n        if use_pthreads:\n            self.backends['pthreads'] = self.backends['c++']\n            self.backends['pthreads'].toolchain.cflags += ['-pthread']\n        if use_scala:\n            self.backends['scala'] = ASPBackend(scala_module.ScalaModule(), scala_module.ScalaToolchain(), self.cache_dir)\n\n    def add_library(self, feature, include_dirs, library_dirs=[], libraries=[], backend='c++'):\n        self.backends[backend].toolchain.add_library(feature, include_dirs, library_dirs, libraries)\n\n    def add_cuda_arch_spec(self, arch):\n        archflag = '-arch='\n        if 'sm_' not in arch:\n            archflag += 'sm_'\n        archflag += arch\n        self.backends['cuda'].toolchain.cflags += [archflag]\n\n    def add_header(self, include_file, brackets=False, backend='c++'):\n        \"\"\"\n        Add a header (e.g. #include \"foo.h\") to the module source file.\n        With brackets=True, it will be C++-style #include <foo> instead.\n        \"\"\"\n        self.backends[backend].module.add_to_preamble([cpp_ast.Include(include_file, brackets)])\n\n    def add_to_preamble(self, pa, backend='c++'):\n        if isinstance(pa, basestring):\n            pa = [cpp_ast.Line(pa)]\n        self.backends[backend].module.add_to_preamble(pa)\n\n    def add_to_init(self, stmt, backend='c++'):\n        if isinstance(stmt, str):\n            stmt = [cpp_ast.Line(stmt)]\n        if backend == 'cuda':\n            self.backends[backend].module.boost_module.add_to_init(stmt)\n        else:\n            self.backends[backend].module.add_to_init(stmt)\n\n    def add_to_module(self, block, backend='c++'):\n        if isinstance(block, basestring):\n            block = [cpp_ast.Line(block)]\n        self.backends[backend].module.add_to_module(block)\n\n    def add_function(self, fname, funcs, variant_names=[], run_check_funcs=[], key_function=None, backend='c++', call_policy=None):\n        \"\"\"\n        Add a specialized function to the Asp module.  funcs can be a list of variants, but then\n        variant_names is required (also a list).  Each item in funcs should be a string function or\n        a cpp_ast FunctionDef.\n        \"\"\"\n        if not isinstance(funcs, list):\n            funcs = [funcs]\n            variant_names = [fname]\n        self.specialized_functions[fname] = SpecializedFunction(fname, self.backends[backend], self.db, variant_names, variant_funcs=funcs, run_check_funcs=run_check_funcs, key_function=key_function, call_policy=call_policy)\n\n    def add_helper_function(self, fname, func, backend='c++'):\n        \"\"\"\n        Add a helper function, which is a specialized function that it not timed and has a single variant.\n        \"\"\"\n        self.specialized_functions[fname] = HelperFunction(fname, func, self.backends[backend])\n\n    def expose_class(self, classname, backend='c++'):\n        \"\"\"\n        Expose a class or struct from C++ to Python, letting us pass instances back and forth\n        between Python and C++.\n\n        TODO: allow exposing *functions* within the class\n        \"\"\"\n        self.backends[backend].module.add_to_init([cpp_ast.Line('boost::python::class_<%s>(\"%s\");\\n' % (classname, classname))])\n\n    def __getattr__(self, name):\n        if name in self.specialized_functions:\n            return self.specialized_functions[name]\n        else:\n            raise AttributeError('No method %s found; did you add it to this ASPModule?' % name)\n\n    def generate(self):\n        \"\"\"\n        Utility function for, during development, dumping out the generated\n        source from all the underlying backends.\n        \"\"\"\n        src = ''\n        for x in self.backends.keys():\n            src += \"\\nSource code for backend '\" + x + \"':\\n\"\n            src += str(self.backends[x].module.generate())\n        return src",
  "line_no": 29,
  "line_no_percent": "7%"
}