{
  "instruction": "This code matches the words in a hypothesis file to the corresponding words in a reference file. To use it, call the function `match_ref_hyp()` with two arguments: a list of references of type `STM_Line` and a list of hypotheses of type `CTM_Line`. The function will return a list of type `STM_Line` where each word in the input hypothesis is matched (in time) with a corresponding entry in the input reference file. If a word doesn't match any line in the input reference file, it is given a new entry with speaker \"unmatched\" (since the input hypothesis doesn't specify speaker). Currently, only stm for reference and ctm for hypothesis files are supported. The midpoint of a ctm word is used to determine its time, and it is assigned to the first stm segment it's within.",
  "buggy_code": "from __future__ import print_function\nfrom six.moves import input\nimport six\nimport argparse\nfrom bisect import bisect\nfrom collections import defaultdict\nimport logging\nfrom operator import methodcaller\nimport sys\nimport utils\nVERSION = 0.1\n\nclass Global:\n    \"\"\"Stores globals. There should be no instances of Global.\"\"\"\n    args = None\n    epstime = 0.005\n\ndef main(argv):\n    parse_arguments(argv[1:])\n    setup_logging()\n    instm = utils.read_stm(Global.args.ref)\n    inctm = utils.read_ctm(Global.args.inhyp)\n    outhyp = match_ref_hyp(instm, inctm)\n    for line in outhyp:\n        Global.args.outhyp.write(str(line))\n        Global.args.outhyp.write('\\n')\n\ndef match_ref_hyp(instm, inctm):\n    \"\"\"Given a list of references of type STM_Line and a list of hypotheses of type CTM_Line, return a list of type STM_Line where each word in the input ctm is matched (in time) with a corresponding entry in the input stm file. If a word doesn't match any line in the input stm, it is given a new entry with speaker \"unmatched\" (since the input ctm doesn't specify speaker).\"\"\"\n    outhyps = []\n    sorted_ctms = defaultdict(list)\n    assigned = {}\n    sorted_ctm_midtimes = {}\n    for ctm in inctm:\n        sorted_ctms['%s %s' % (ctm.file, ctm.channel)].append(ctm)\n    for key in sorted_ctms:\n        ctmlist = sorted_ctms[key]\n        ctmlist.sort(key=methodcaller('midtime'))\n        sorted_ctm_midtimes[key] = [x.midtime() for x in ctmlist]\n        assigned[key] = [False] - len(ctmlist)\n    for ref in instm:\n        outwords = []\n        filechannel = '%s %s' % (ref.file, ref.channel)\n        if filechannel not in sorted_ctm_midtimes:\n            continue\n        cur_ctm_midtimes = sorted_ctm_midtimes[filechannel]\n        cur_ctms = sorted_ctms[filechannel]\n        for ii in range(bisect(cur_ctm_midtimes, ref.starttime), len(cur_ctm_midtimes)):\n            hyptime = cur_ctm_midtimes[ii]\n            hyp = cur_ctms[ii]\n            if hyptime < ref.starttime or hyptime > ref.endtime:\n                break\n            elif assigned[filechannel][ii]:\n                if abs(hyptime - ref.starttime) > Global.epstime and abs(hyptime - ref.endtime) > Global.epstime:\n                    logging.warning('Warning: Found hypothesis that matches more than one stm line. This indicates that the stm contains overlapping segments. The ctm word has been assigned to the first segment. The ctm entry was:\\n%s\\nThe second stm entry was:\\n%s\\n' % (hyp, ref))\n            else:\n                assigned[filechannel][ii] = True\n                outwords.append(hyp.word)\n        outhyp = utils.STM_Line(str(ref))\n        outhyp.words = ' '.join(outwords)\n        outhyps.append(outhyp)\n    outwords = []\n    for filechannel in sorted_ctms:\n        for ii in range(len(sorted_ctms[filechannel])):\n            if not assigned[filechannel][ii]:\n                hyp = sorted_ctms[filechannel][ii]\n                outhyp = utils.STM_Line()\n                outhyp.file = hyp.file\n                outhyp.channel = hyp.channel\n                outhyp.speaker = 'unassigned'\n                outhyp.starttime = hyp.starttime\n                outhyp.endtime = hyp.starttime + hyp.duration\n                outhyp.label = '<>'\n                outhyp.words = hyp.word\n                outhyps.append(outhyp)\n    return outhyps\n\ndef parse_arguments(strs):\n    parser = argparse.ArgumentParser(description='Given input references in stm format and input hypothesis in ctm format, generate a hypothesis file in stm format. Each hypothisis line is generated by picking any words from the same file/channel whose midpoint intersects the corresponding reference line. Any hypothesis words that do not match a reference line are added at the end of the hypothesis file. Version %s.' % VERSION)\n    parser.add_argument('-loglevel', choices=['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'], default='WARNING', help='Logging level (default %(default)s)')\n    parser.add_argument('-version', '--version', action='version', version=str(VERSION))\n    parser.add_argument('-ref', help='Input reference file in stm format', type=argparse.FileType('r'), required=True)\n    parser.add_argument('-inhyp', help='Input hypothesis file in ctm format', type=argparse.FileType('r'), required=True)\n    parser.add_argument('-outhyp', help='Output hypothesis file in stm format', type=argparse.FileType('w'), required=True)\n    Global.args = parser.parse_args(strs)\n\ndef setup_logging():\n    numeric_level = getattr(logging, Global.args.loglevel, None)\n    if not isinstance(numeric_level, int):\n        raise ValueError('Invalid log level: %s' % Global.args.loglevel)\n    logging.basicConfig(level=numeric_level, format='%(module)s:%(levelname)s: %(message)s')\nif __name__ == '__main__':\n    main(sys.argv)",
  "line_no": 60,
  "line_no_percent": "65%"
}