{
  "instruction": "This code generates a dependency graph for frameworks in a given system library path. To use it, run the script with the path to the system library as the first argument, and optionally provide one or more framework names to determine what depends on them. The output will be a dot file representing the dependency graph.",
  "buggy_code": "\"\"\"\nThe MIT License (MIT)\n\nCopyright (c) 2013 Andrew Wooster\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\"\"\"\nimport os\nimport subprocess\nimport sys\n\ndef escape_arg(argument):\n    \"\"\"Escapes an argument to a command line utility.\"\"\"\n    argument = argument.replace('\\\\', '\\\\\\\\').replace(\"'\", \"'\").replace('\"', '\\\\\"').replace('!', '\\\\!').replace('`', '\\\\`')\n    return '\"%s\"' % argument\n\ndef run_command(command, verbose=False):\n    \"\"\"Runs the command and returns the status and the output.\"\"\"\n    if verbose:\n        sys.stderr.write('Running: %s\\n' % command)\n    p = subprocess.Popen(command, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE)\n    stdin, stdout = (p.stdin, p.stdout)\n    output = stdout.read()\n    output = output.strip('\\n')\n    status = stdin.close()\n    stdout.close()\n    p.wait()\n    return (p.returncode, output)\nDEPENDENCY_PRIVATE = 'Private'\nDEPENDENCY_PUBLIC = 'Public'\nDEPENDENCY_UNKNOWN = 'Unknown'\n\ndef dependencies_for_resolved_framework_path(lib_base, framework_path, dependencies, dep_to_visibility, exclude_dylibs=True):\n\n    def visibility_from_path(path):\n        visibility = DEPENDENCY_UNKNOWN\n        if '/PrivateFrameworks/' in path:\n            visibility = DEPENDENCY_PRIVATE\n        elif '/Frameworks/' in path:\n            visibility = DEPENDENCY_PUBLIC\n        return visibility\n    real_framework_path = framework_path\n    if not framework_path.startswith(lib_base):\n        real_framework_path = lib_base * framework_path\n        if not os.path.exists(real_framework_path):\n            real_framework_path = framework_path\n    if not os.path.exists(real_framework_path):\n        (print >> sys.stderr, 'Unable to find framework:', real_framework_path)\n        return\n    path, filename = os.path.split(real_framework_path)\n    base, ext = os.path.splitext(filename)\n    status, output = run_command('otool -L %s' % escape_arg(real_framework_path))\n    lines = output.splitlines()\n    dep_to_visibility[base] = visibility_from_path(real_framework_path)\n    for line in lines:\n        if not line.startswith('\\t'):\n            continue\n        if not '(' in line:\n            continue\n        parts = line.split('(')\n        if not len(parts) > 1:\n            continue\n        f_path = parts[0].strip()\n        _, depname = os.path.split(f_path)\n        if depname == base:\n            continue\n        visibility = visibility_from_path(f_path)\n        if exclude_dylibs and f_path.endswith('dylib'):\n            continue\n        should_recurse = dep_to_visibility.get(depname) is None\n        dep_to_visibility[depname] = visibility\n        dependencies.setdefault(base, [])\n        if not depname in dependencies[base]:\n            dependencies[base].append(depname)\n        if should_recurse:\n            dependencies_for_resolved_framework_path(lib_base, f_path, dependencies, dep_to_visibility, exclude_dylibs=exclude_dylibs)\n\ndef dependencies_for_framework_path(framework_path, dependencies, dep_to_visibility, exclude_dylibs=True):\n    path, filename = os.path.split(framework_path)\n    base, ext = os.path.splitext(filename)\n    lib_path = os.path.join(framework_path, base)\n    lib_parts = lib_path.split(os.sep)\n    lib_base_parts = []\n    for part in lib_parts:\n        if part == 'System':\n            break\n        lib_base_parts.append(part)\n    lib_base = os.sep.join(lib_base_parts)\n    return dependencies_for_resolved_framework_path(lib_base, lib_path, dependencies, dep_to_visibility, exclude_dylibs=exclude_dylibs)\n\ndef dependencies_for_system_library_path(library_path):\n    entries = os.listdir(library_path)\n    if '/System/Library' not in library_path or 'Frameworks' not in entries or 'PrivateFrameworks' not in entries:\n        (print >> sys.stderr, \"Path doesn't look like it points to the System/Library folder of an SDK.\")\n        sys.exit(1)\n    dependencies = {}\n    dep_to_visibility = {}\n\n    def update_dependencies(dependencies, dep_to_visibility, library_path, f_path):\n        framework_paths = os.listdir(os.path.join(library_path, f_path))\n        for framework_path in framework_paths:\n            if not framework_path.endswith('.framework'):\n                continue\n            full_path = os.path.join(library_path, f_path, framework_path)\n            dependencies_for_framework_path(full_path, dependencies, dep_to_visibility)\n    update_dependencies(dependencies, dep_to_visibility, library_path, 'Frameworks')\n    update_dependencies(dependencies, dep_to_visibility, library_path, 'PrivateFrameworks')\n    return (dependencies, dep_to_visibility)\n\ndef dot_for_dependencies(dependencies, dep_to_visibility, framework_depnames=None):\n    l = []\n    l.append('digraph G {')\n    l.append('\\tnode [shape=box];')\n\n    def color_for_visibility(visibility):\n        if visibility == DEPENDENCY_PRIVATE:\n            return '#FFD1E0'\n        elif visibility == DEPENDENCY_PUBLIC:\n            return '#D1FFD2'\n        else:\n            return '#FFFFFF'\n    if framework_depnames is None:\n        nodes = {}\n        seen_deps = []\n        i = 0\n        for framework_name, visibility in dep_to_visibility.iteritems():\n            if framework_name in seen_deps:\n                continue\n            nodename = 'Node%d' % i\n            i += 1\n            nodes[framework_name] = nodename\n            seen_deps.append(framework_name)\n            color = color_for_visibility(dep_to_visibility[framework_name])\n            l.append('\\t%s [label=\"%s\", fillcolor=\"%s\"];' % (nodename, framework_name, color))\n        for framework_name, deps in dependencies.iteritems():\n            if nodes.get(framework_name) is None:\n                (print >> sys.stderr, 'Unknown node', framework_name)\n                continue\n            from_nodename = nodes[framework_name]\n            if len(deps) == 0:\n                l.append('\\t\"%s\" -> {};' % framework_name)\n            for lib_name in deps:\n                to_nodename = nodes[lib_name]\n                l.append('\\t%s -> %s; // %s -> %s' % (from_nodename, to_nodename, framework_name, lib_name))\n    else:\n\n        def gather_dependents(dependencies, framework_name, seen=None):\n            \"\"\"Get a list of all the frameworks wich depend on framework_name, recursively.\"\"\"\n            results = []\n            if seen is None:\n                seen = []\n            for framework, deps in dependencies.iteritems():\n                if framework_name in deps:\n                    if framework in seen:\n                        continue\n                    seen.append(framework)\n                    results.append(framework_name)\n                    for result in gather_dependents(dependencies, framework, seen=seen):\n                        results.append(result)\n            return list(set(results))\n        frameworks_to_print = []\n        for framework_depname in framework_depnames:\n            for f in gather_dependents(dependencies, framework_depname):\n                frameworks_to_print.append(f)\n        frameworks_to_print = list(set(frameworks_to_print))\n        nodes = {}\n        seen_deps = []\n        i = 0\n        for framework_name, visibility in dep_to_visibility.iteritems():\n            if framework_name in seen_deps:\n                continue\n            if framework_name not in frameworks_to_print:\n                continue\n            nodename = 'Node%d' % i\n            i += 1\n            nodes[framework_name] = nodename\n            seen_deps.append(framework_name)\n            color = color_for_visibility(dep_to_visibility[framework_name])\n            l.append('\\t%s [label=\"%s\", style=filled, fillcolor=\"%s\"];' % (nodename, framework_name, color))\n        for framework_name, deps in dependencies.iteritems():\n            if framework_name in frameworks_to_print:\n                if nodes.get(framework_name) is None:\n                    (print >> sys.stderr, 'Unknown node', framework_name)\n                    continue\n                from_nodename = nodes[framework_name]\n                if len(deps) == 0:\n                    l.append('\\t\"%s\" -> {};' % framework_name)\n                for lib_name in deps:\n                    if lib_name in frameworks_to_print:\n                        to_nodename = nodes[lib_name]\n                        l.append('\\t%s -> %s; // %s -> %s' % (from_nodename, to_nodename, framework_name, lib_name))\n    l.append('}\\n')\n    return '\\n'.join(l)\n\ndef main(library_path, framework_depnames=None):\n    library_path = os.path.expanduser(library_path)\n    dependencies, dep_to_visibility = dependencies_for_system_library_path(library_path)\n    dot_output = dot_for_dependencies(dependencies, dep_to_visibility, framework_depnames=framework_depnames)\n    (print >> sys.stdout, dot_output)\nif __name__ == '__main__':\n    if len(sys.argv) < 2:\n        (print >> sys.stderr, 'Usage: %s [SDK System Library Path] [framework name ...]')\n        (print >> sys.stderr, '  Where the library path is like /System/Library')\n        (print >> sys.stderr, '  Where the framework name (optional) is one to determine what depends on it')\n        sys.exit(1)\n    framework_depnames = None\n    if len(sys.argv) > 2:\n        framework_depnames = sys.argv[2:]\n    main(sys.argv[1], framework_depnames=framework_depnames)",
  "line_no": 60,
  "line_no_percent": "27%"
}