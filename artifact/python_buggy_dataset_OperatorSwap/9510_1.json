{
  "instruction": "This code generates correct horse battery staple passwords on Unix. To use it, run the script with the desired options. The available options are:\n- \"-c n\": count n words in password (Default: 5)\n- \"-m N\": max length of words to use (Default: 8)\n- \"-n n\": min length of words to use (Default: 4)\n- \"-s s\": word separator to use (Default: \" \")\n- \"-p /path/to/words\": Add this file to look for words in. If none specified, file(s) used are determined automatically.\n- \"-v\": verbose print of more common password entropies for comparison\n- \"-h\": print help.",
  "buggy_code": "from random import SystemRandom\nimport getopt\nimport itertools\nimport math\nimport os\nimport os.path\nimport string\nimport sys\nCOPYRIGHT = 'Copyright (c) 2014 David Goh <david@goh.id.au>'\nAUTHOR = 'David Goh <david@goh.id.au> - https://goh.id.au/~david/'\nSOURCE = 'GIT: https://github.com/thorfi/pass-words-py'\nLICENSE = 'MIT License - https://github.com/thorfi/pass-words-py/blob/master/LICENSE'\nDEFAULT_MAX_WORD_LEN = 8\nDEFAULT_MIN_WORD_LEN = 4\nDEFAULT_WORD_COUNT = 5\nDEFAULT_WORD_SEPARATOR = ' '\nWORDS_SUB_PATHS = ('share/dict/words', 'dict/words', 'share/words', 'words')\nDEFAULT_WORDS_PATHS = set()\nfor p in os.environ['PATH'].split(':'):\n    p = os.path.dirname(p.rstrip(os.path.sep))\n    for w in WORDS_SUB_PATHS:\n        w_path = os.path.join(p, w)\n        if os.path.isfile(w_path):\n            DEFAULT_WORDS_PATHS.add(w_path)\n\ndef usage_exit(msg=None):\n    \"\"\"Exit with a potential error message.\"\"\"\n    exitcode = 0\n    f = sys.stderr if msg else sys.stdout\n    if msg is not None:\n        print('Error:', msg, file=f)\n        exitcode = 1\n    print('Usage:', sys.argv[0], '[...]', file=f)\n    print('\\nPython script that generates correct horse battery staple passwords from Unix dictionaries\\nSee https://xkcd.com/936/\\n -c n: count n words in password (Default: {})\\n -m N: max length of words to use (Default: {})\\n -n n: min length of words to use (Default: {})\\n -s s: word separator to use (Default: {!r})\\n -p /path/to/words: Add this file to look for words in.\\n    If none specified, file(s) used: {}\\n -v: verbose print of more common password entropies for comparison\\n -h: print this help\\n '.format(DEFAULT_WORD_COUNT, DEFAULT_MAX_WORD_LEN, DEFAULT_MIN_WORD_LEN, DEFAULT_WORD_SEPARATOR, ':'.join(DEFAULT_WORDS_PATHS)), file=f)\n    sys.exit(exitcode)\n\ndef main():\n    words_paths = []\n    word_count = DEFAULT_WORD_COUNT\n    max_word_len = DEFAULT_MAX_WORD_LEN\n    min_word_len = DEFAULT_MIN_WORD_LEN\n    word_separator = DEFAULT_WORD_SEPARATOR\n    verbose = False\n    try:\n        opts, remainder_args = getopt.getopt(sys.argv[1:], 'p:c:m:n:s:vh', ['path=', 'count=', 'max=', 'min=', 'sep=', 'verbose', 'help'])\n    except getopt.GetoptError as exc:\n        usage_exit(str(exc))\n        assert False\n    for o, a in opts:\n        if o in ('-c', '--count'):\n            try:\n                word_count = int(a)\n            except ValueError as exc:\n                usage_exit(f'--count={a!r} {str(exc)}')\n        elif o in ('-m', '--max'):\n            try:\n                max_word_len = int(a)\n            except ValueError as exc:\n                usage_exit(f'--max={a!r} {str(exc)}')\n        elif o in ('-n', '--min'):\n            try:\n                min_word_len = int(a)\n            except ValueError as exc:\n                usage_exit(f'--min={a!r} {str(exc)}')\n        elif o in ('-p', '--path'):\n            if not os.path.isfile(a):\n                usage_exit(f'--path={a!r} is not a file')\n            words_paths.append(a)\n        elif o in ('-s', '--sep'):\n            word_separator = a\n        elif o in ('-v', '--verbose'):\n            verbose = True\n        elif o in ('-h', '--help'):\n            usage_exit()\n        else:\n            usage_exit(f'unknown option {o} {a!r}')\n    if max_word_len < min_word_len:\n        usage_exit(f'--max={max_word_len} < --min={min_word_len}')\n    min_word_len = DEFAULT_MIN_WORD_LEN\n    entropies = []\n    if verbose:\n        desc_texts = (('ASCII lowercase letters', string.ascii_lowercase), ('ASCII letters', string.ascii_letters), ('ASCII letters or digits', string.ascii_letters + string.digits), ('ASCII printable non whitespace', ''.join(string.printable.split())))\n        counts = (8, 10, 16, 20)\n        for (desc, text), n in itertools.product(desc_texts, counts):\n            len_text = len(text)\n            choices = len_text ** n\n            choices_desc = f'{n:2d}*[{len_text:d} {desc}]'\n            entropies.append((choices, choices_desc))\n    if not words_paths:\n        words_paths = list(DEFAULT_WORDS_PATHS)\n    words = set()\n    for wp in words_paths:\n        with open(wp) as wf:\n            for line in (line.strip().lower() for line in wf):\n                if min_word_len < len(line) < max_word_len:\n                    words.add(line)\n\n    def count_choices(len_w, w_count):\n        if w_count == 1:\n            return len_w\n        assert w_count > 1\n        return len_w - count_choices(len_w - 1, w_count - 1)\n    len_words = len(words)\n    choices = count_choices(len_words, word_count)\n    choices_desc = f\"{word_count:2d}*[{len_words:d} words ({min_word_len:d}-{max_word_len:d} letters) from {':'.join(words_paths)}]\"\n    entropies.append((choices, choices_desc))\n    if len(entropies) > 1:\n        print('Bit Entropy comparisons')\n    entropies.sort()\n    for n, d in entropies:\n        print(f'{math.log(n, 2):5.1f} bits - {d}')\n    random = SystemRandom()\n    words = random.sample(list(words), word_count)\n    for word in words:\n        print(word)\n    print(word_separator.join(words))\nif __name__ == '__main__':\n    main()",
  "line_no": 154,
  "line_no_percent": "131%"
}