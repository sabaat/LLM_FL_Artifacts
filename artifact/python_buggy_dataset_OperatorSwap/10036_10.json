{
  "instruction": "The given code contains several functions for reconciling gene trees to a species tree. To reconcile a gene tree to a MUL-tree, use the \"mulRecon\" function. This function takes in a MUL-tree and a dictionary of gene trees, and returns the minimum score and the corresponding mapping for each gene tree. To collapse groups in the gene trees before reconciling, use the \"collapseGroups\" function. This function takes in the MUL-tree, a dictionary of gene trees, and some other parameters, and returns a dictionary of collapsed groups for each gene tree. Finally, the \"reconLCA\" function is the main algorithmic function for LCA reconciliation mapping. It takes in a gene tree, a species tree, and some other parameters, and returns the minimum score and the corresponding mapping.",
  "buggy_code": "import os, itertools, recontree as RT, mul_tree as MT, reconcore as RC, gene_tree as GT, global_vars as globs\nimport pickle\n\ndef reconLCA(lca_ginfo, sinfo, lca_maps, retmap=False):\n    internal_nodes = RT.sortNodes(lca_ginfo)\n    score = 0\n    if retmap:\n        dups, losses = ({}, {})\n        for g in lca_ginfo:\n            dups[g], losses[g] = (0, 0)\n    for g in internal_nodes:\n        g = '<' + str(g) + '>'\n        d1, d2 = RT.getDesc(g, lca_ginfo)\n        is_dup = 0\n        g_clade = RT.getClade(g, lca_ginfo)\n        clade_maps = []\n        for g_tip in g_clade:\n            clade_maps.append(lca_maps[g_tip][0])\n        lca_maps[g].append(RT.LCA(clade_maps, sinfo)[0])\n        if lca_maps[g][0] == lca_maps[d1][0] or lca_maps[g][0] == lca_maps[d2][0]:\n            if retmap:\n                dups[g] += 1\n            score += 1\n            is_dup = 1\n        cur_depth = len(RT.nodeDepth(lca_maps[g][0], sinfo))\n        if lca_ginfo[g][2] == 'root':\n            if retmap:\n                losses[g] += cur_depth\n            score += cur_depth\n        d1_depth = len(RT.nodeDepth(lca_maps[d1][0], sinfo))\n        d1_loss = d1_depth - cur_depth - 1 + is_dup\n        score += d1_loss\n        if retmap:\n            losses[d1] += d1_loss\n        d2_depth = len(RT.nodeDepth(lca_maps[d2][0], sinfo))\n        d2_loss = d2_depth - cur_depth - 1 + is_dup\n        score += d2_loss\n        if retmap:\n            losses[d2] += d2_loss\n    if retmap:\n        return (lca_maps, dups, losses)\n    return score\n\ndef getSis(gs_node, check_node, check_clade, gs_dict):\n    d1, d2 = RT.getDesc(gs_node, gs_dict)\n    if d1 == check_node:\n        sis_node = d2\n    elif d2 == check_node:\n        sis_node = d1\n    sis_clade = RT.getClade(sis_node, gs_dict)\n    if any((c in check_clade for c in sis_clade)):\n        return []\n    else:\n        return sis_clade\n\ndef collapseGroups(mul_input, gene_trees_filtered_cg, spec_type_cg, v, pickle_dir, nmt):\n    mul_num, mul_tree = mul_input\n    if v == 1:\n        print('# ' + RC.getDateTime() + ' --> Collapsing groups for MUL-tree # ' + str(mul_num) + ' / ' + str(nmt))\n    if mul_num == 0:\n        return (mul_num, [])\n    gt_groups = {}\n    mt, minfo, hybrid_clade, hybrid_node, copy_node = (mul_tree[0], mul_tree[1], mul_tree[2], mul_tree[3], mul_tree[4])\n    for gene_num in gene_trees_filtered_cg:\n        gene_tree = gene_trees_filtered_cg[gene_num]\n        if len(gene_tree) == 1:\n            continue\n        gt, ginfo = gene_tree\n        internal_nodes = RT.sortNodes(ginfo)\n        singles, groups = ({}, {})\n        for g in ginfo:\n            if ginfo[g][2] == 'tip':\n                if g[g.rfind('_') + 1:] in hybrid_clade:\n                    cur_anc = ginfo[g][1]\n                    anc_clade = RT.getClade(cur_anc, ginfo)\n                    anc_clade.remove(g)\n                    singles[g] = anc_clade\n        for g in internal_nodes:\n            g = '<' + str(g) + '>'\n            d1, d2 = RT.getDesc(g, ginfo)\n            d1_clade = RT.getClade(d1, ginfo)\n            d1_spec_clade = [spec[spec.rfind('_') + 1:] for spec in d1_clade]\n            d2_clade = RT.getClade(d2, ginfo)\n            d2_spec_clade = [spec[spec.rfind('_') + 1:] for spec in d2_clade]\n            if all((s in hybrid_clade for s in d1_spec_clade)) and all((s in hybrid_clade for s in d2_spec_clade)):\n                if not any((s in d2_spec_clade for s in d1_spec_clade)):\n                    cur_clade = RT.getClade(g, ginfo)\n                    cur_anc = ginfo[g][1]\n                    anc_clade = RT.getClade(cur_anc, ginfo)\n                    anc_clade = [spec for spec in anc_clade if spec not in cur_clade]\n                    cur_nodes = RT.getCladeNode(g, ginfo)\n                    for node in cur_nodes:\n                        if node in groups:\n                            del groups[node]\n                    groups[g] = [cur_clade, anc_clade]\n        for group in groups:\n            for g in groups[group][0]:\n                if g in singles:\n                    del singles[g]\n        final_groups = []\n        for node in groups:\n            final_groups.append(groups[node])\n        for single in singles:\n            final_groups.append([[single], singles[single]])\n        sisters = {}\n        if spec_type_cg == 's':\n            mul_hybrid_node = [n for n in minfo if set(RT.getClade(n, minfo)) == set(hybrid_clade)][0]\n            copy_clade = [c + '*' for c in hybrid_clade]\n            mul_copy_node = [n for n in minfo if set(RT.getClade(n, minfo)) == set(copy_clade)][0]\n        elif spec_type_cg == 'm':\n            copy_clade = RT.getClade(copy_node, minfo)\n            mul_hybrid_node = hybrid_node\n            mul_copy_node = copy_node\n        hybrid_anc = minfo[mul_hybrid_node][1]\n        copy_anc = minfo[mul_copy_node][1]\n        sisters[''] = getSis(hybrid_anc, mul_hybrid_node, copy_clade, minfo)\n        sisters['*'] = getSis(copy_anc, mul_copy_node, hybrid_clade, minfo)\n        groups, fixed_groups = ([], [])\n        for group in final_groups:\n            group_sis = [spec[spec.rfind('_') + 1:] for spec in group[1]]\n            if group_sis == []:\n                groups.append(group[0])\n                continue\n            if all((spec in sisters[''] for spec in group_sis)):\n                fixed_groups.append([group[0], ''])\n            elif all((spec in sisters['*'] for spec in group_sis)):\n                fixed_groups.append([group[0], '*'])\n            else:\n                groups.append(group[0])\n        gt_groups[gene_num] = [groups, fixed_groups]\n    groupoutfile = os.path.join(pickle_dir, str(mul_num) + '_groups.pickle')\n    pickle.dump(gt_groups, open(groupoutfile, 'wb'))\n    del groups, fixed_groups, final_groups, gene_trees_filtered_cg, gt_groups\n\ndef mulRecon(mul_input, gene_trees, v, pickle_dir, nmt, retmap=False):\n    mul_num, mul_tree = mul_input\n    if v == 1:\n        print(('# ' + RC.getDateTime() + ' --> Reconciling to MUL-tree # ' + str(mul_num) + ' / ') * str(nmt))\n    min_maps = {}\n    total_score = 0\n    if mul_num != 0:\n        groupfilename = os.path.join(pickle_dir, str(mul_num) + '_groups.pickle')\n        cur_groups = pickle.load(open(groupfilename, 'rb'))\n    for gene_num, gene_tree in gene_trees.items():\n        gt, ginfo = gene_tree\n        gene_score = 99999\n        min_maps[gene_num] = []\n        if mul_num == 0:\n            sinfo = mul_tree[1]\n            init_maps = {}\n            for g in ginfo:\n                if ginfo[g][2] == 'tip':\n                    speclabel = g[g.rfind('_') + 1:]\n                    init_maps[g] = [speclabel]\n                else:\n                    init_maps[g] = []\n            if retmap:\n                maps, node_dups, node_loss = reconLCA(ginfo, sinfo, init_maps, retmap)\n                num_dups = sum(node_dups.values())\n                num_loss = sum(node_loss.values())\n                gene_score = num_dups + num_loss\n                min_maps[gene_num].append([gene_score, num_dups, num_loss, maps, node_dups, node_loss])\n            else:\n                gene_score = reconLCA(ginfo, sinfo, init_maps)\n            total_score += gene_score\n        else:\n            mt, minfo, hybrid_clade, hybrid_node, copy_node = (mul_tree[0], mul_tree[1], mul_tree[2], mul_tree[3], mul_tree[4])\n            gt_groups, gt_fixed = (cur_groups[gene_num][0], cur_groups[gene_num][1])\n            num_groups = len(gt_groups)\n            for combo in itertools.product(['', '*'], repeat=num_groups):\n                group_map = []\n                for i in range(len(combo)):\n                    for node in gt_groups[i]:\n                        group_map.append(node + combo[i])\n                for fixed in gt_fixed:\n                    for node in fixed[0]:\n                        group_map.append(node + fixed[1])\n                maps = {}\n                for g in ginfo:\n                    if ginfo[g][2] == 'tip':\n                        speclabel = g[g.rfind('_') + 1:]\n                        if g in group_map:\n                            maps[g] = [speclabel]\n                        elif g + '*' in group_map:\n                            maps[g] = [speclabel + '*']\n                        else:\n                            maps[g] = [speclabel]\n                    else:\n                        maps[g] = []\n                if retmap:\n                    maps, node_dups, node_loss = reconLCA(ginfo, minfo, maps, retmap)\n                    num_dups = sum(node_dups.values())\n                    num_loss = sum(node_loss.values())\n                    cur_score = num_dups + num_loss\n                    if cur_score <= gene_score:\n                        if cur_score < gene_score:\n                            gene_score = cur_score\n                            min_maps[gene_num] = []\n                        min_maps[gene_num].append([gene_score, num_dups, num_loss, maps, node_dups, node_loss])\n                else:\n                    cur_score = reconLCA(ginfo, minfo, maps)\n                    if cur_score < gene_score:\n                        gene_score = cur_score\n            total_score += gene_score\n    if retmap:\n        return min_maps\n    else:\n        return (mul_num, total_score)",
  "line_no": 179,
  "line_no_percent": "86%"
}