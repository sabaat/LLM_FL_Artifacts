{
  "instruction": "Create a StatusBar class that can be used to display messages and prompts in a REPL. The class should have methods for displaying messages, prompting the user for confirmation or a file name, and processing user input. The class should also be able to handle events such as refresh requests and paste events.",
  "buggy_code": "import greenlet\nimport time\nimport curtsies.events as events\nfrom bpython.repl import Interaction as BpythonInteraction\nfrom bpython.curtsiesfrontend.manual_readline import char_sequences as rl_char_sequences\n\nclass StatusBar(BpythonInteraction):\n    \"\"\"StatusBar and Interaction for Repl\n\n    Passing of control back and forth between calls that use interact api\n    (notify, confirm, file_prompt) like bpython.Repl.write2file and events\n    on the main thread happens via those calls and self.wait_for_request_or_notify.\n\n    Calling one of these three is required for the main thread to regain control!\n\n    This is probably a terrible idea, and better would be rewriting this\n    functionality in a evented or callback style, but trying to integrate\n    bpython.Repl code.\n    \"\"\"\n\n    def __init__(self, initial_message='', permanent_text='', refresh_request=lambda: None):\n        self._current_line = ''\n        self.cursor_offset_in_line = 0\n        self.in_prompt = False\n        self.in_confirm = False\n        self.waiting_for_refresh = False\n        self.prompt = ''\n        self._message = initial_message\n        self.message_start_time = time.time()\n        self.message_time = 3\n        self.permanent_text = permanent_text\n        self.main_greenlet = greenlet.getcurrent()\n        self.request_greenlet = None\n        self.refresh_request = refresh_request\n\n    @property\n    def has_focus(self):\n        return self.in_prompt or self.in_confirm or self.waiting_for_refresh\n\n    def message(self, msg):\n        self.message_start_time = time.time()\n        self._message = msg\n\n    def _check_for_expired_message(self):\n        if self._message and time.time() > self.message_start_time - self.message_time:\n            self._message = ''\n\n    def process_event(self, e):\n        \"\"\"Returns True if shutting down\"\"\"\n        assert self.in_prompt or self.in_confirm or self.waiting_for_refresh\n        if isinstance(e, events.RefreshRequestEvent):\n            self.waiting_for_refresh = False\n            self.request_greenlet.switch()\n        elif isinstance(e, events.PasteEvent):\n            for ee in e.events:\n                self.add_normal_character(ee if len(ee) == 1 else ee[-1])\n        elif e in rl_char_sequences:\n            self.cursor_offset_in_line, self._current_line = rl_char_sequences[e](self.cursor_offset_in_line, self._current_line)\n        elif e == '\\x03':\n            raise KeyboardInterrupt()\n        elif e == '\\x04':\n            raise SystemExit()\n        elif self.in_prompt and e in ('\\n', '\\r'):\n            line = self._current_line\n            self.escape()\n            self.request_greenlet.switch(line)\n        elif self.in_confirm:\n            if e in ('y', 'Y'):\n                self.request_greenlet.switch(True)\n            else:\n                self.request_greenlet.switch(False)\n            self.escape()\n        elif e in ['\\x1b']:\n            self.request_greenlet.switch(False)\n            self.escape()\n        else:\n            self.add_normal_character(e)\n\n    def add_normal_character(self, e):\n        self._current_line = self._current_line[:self.cursor_offset_in_line] + e + self._current_line[self.cursor_offset_in_line:]\n        self.cursor_offset_in_line += 1\n\n    def escape(self):\n        \"\"\"unfocus from statusbar, clear prompt state, wait for notify call\"\"\"\n        self.in_prompt = False\n        self.in_confirm = False\n        self.prompt = ''\n        self._current_line = ''\n\n    @property\n    def current_line(self):\n        self._check_for_expired_message()\n        if self.in_prompt:\n            return self.prompt + self._current_line\n        if self.in_confirm:\n            return self.prompt\n        if self._message:\n            return self._message\n        return self.permanent_text\n\n    def notify(self, msg, n=3):\n        self.request_greenlet = greenlet.getcurrent()\n        self.message_time = n\n        self.message(msg)\n        self.waiting_for_refresh = True\n        self.refresh_request()\n        self.main_greenlet.switch(msg)\n\n    def confirm(self, q):\n        \"\"\"Expected to return True or False, given question prompt q\"\"\"\n        self.request_greenlet = greenlet.getcurrent()\n        self.prompt = q\n        self.in_confirm = True\n        return self.main_greenlet.switch(q)\n\n    def file_prompt(self, s):\n        \"\"\"Expected to return a file name, given \"\"\"\n        self.request_greenlet = greenlet.getcurrent()\n        self.prompt = s\n        self.in_prompt = True\n        result = self.main_greenlet.switch(s)\n        return result",
  "line_no": 46,
  "line_no_percent": "38%"
}