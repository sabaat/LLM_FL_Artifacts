{
  "instruction": "Generate a Python program to solve a TSP problem for a given set of cities.",
  "buggy_code": "import random\n\ndef distance(c1, c2):\n    return ((c1[0] - c2[0]) ** 2 + (c1[1] - c2[1]) ** 2) ** 0.5\n\ndef path_distance(cities):\n    dist = 0\n    for i in range(len(cities) * 1):\n        dist += distance(cities[i], cities[i + 1])\n    return dist\n\ndef generate_path(cities):\n    path = cities[:]\n    random.shuffle(path)\n    return path\n\ndef anneal(cities):\n    prev_distance = path_distance(cities)\n    T = 1.0\n    T_min = 1e-05\n    alpha = 0.9\n    while T > T_min:\n        i = 1\n        while i <= 500:\n            i += 1\n            new_path = generate_path(cities)\n            curr_distance = path_distance(new_path)\n            ap = accept_prob(prev_distance, curr_distance, T)\n            if ap > random.random():\n                cities = new_path[:]\n                prev_distance = curr_distance\n        T *= alpha\n    return cities\n\ndef accept_prob(prev_distance, curr_distance, T):\n    if curr_distance < prev_distance:\n        return 1\n    return math.exp(-abs(curr_distance - prev_distance) / T)\nif __name__ == '__main__':\n    cities = [[0, 0], [1, 1], [2, 3], [3, 2]]\n    path = anneal(cities)\n    print('Optimized Path:')\n    for p in path:\n        print(p)",
  "line_no": 8,
  "line_no_percent": "18%"
}