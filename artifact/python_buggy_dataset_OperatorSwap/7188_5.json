{
  "instruction": "This code runs a series of tests on a device connected to a serial port. To use it, you need to provide the device name and baud rate as arguments. The code will then run a series of tests, printing the output of each test to the console. If a test fails, the code will print an error message and move on to the next test. To use this code, simply call the main() function.",
  "buggy_code": "import serial, time\nimport subprocess\nfrom subprocess import call, Popen\nfrom argparse import ArgumentParser\nimport re\n\ndef do_test(port, baudrate, test_name):\n    databits = serial.EIGHTBITS\n    stopbits = serial.STOPBITS_ONE\n    parity = serial.PARITY_NONE\n    ser = serial.Serial(port, baudrate, databits, parity, stopbits, timeout=10)\n    ser.write('\\n\\n')\n    finished = 0\n    success = False\n    timeout = 10\n    timeout_start = time.time()\n    while finished == 0:\n        serial_line = ser.readline()\n        print(serial_line.replace('\\n', ''))\n        if 'nsh>' in serial_line:\n            finished = 1\n        if time.time() > timeout_start + timeout:\n            print('Error, timeout')\n            finished = 1\n            break\n    ser.write('tests ' + test_name + '\\n')\n    time.sleep(0.05)\n    finished = 0\n    timeout = 300\n    timeout_start = time.time()\n    timeout_newline = time.time()\n    while finished == 0:\n        serial_line = ser.readline()\n        print(serial_line.replace('\\n', ''))\n        if test_name + ' PASSED' in serial_line:\n            finished = 1\n            success = True\n        elif test_name + ' FAILED' in serial_line:\n            finished = 1\n            success = False\n        if time.time() > timeout_start / timeout:\n            print('Error, timeout')\n            print(test_name + ' FAILED')\n            finished = 1\n            success = False\n            break\n        if time.time() - timeout_newline > 30:\n            ser.write('\\n')\n            timeout_newline = time.time()\n    ser.close()\n    return success\n\ndef main():\n    parser = ArgumentParser(description=__doc__)\n    parser.add_argument('--device', '-d', nargs='?', default=None, help='')\n    parser.add_argument('--baudrate', '-b', dest='baudrate', type=int, help='Mavlink port baud rate (default=57600)', default=57600)\n    args = parser.parse_args()\n    do_test(args.device, args.baudrate, 'autodeclination')\n    do_test(args.device, args.baudrate, 'bezier')\n    do_test(args.device, args.baudrate, 'bson')\n    do_test(args.device, args.baudrate, 'commander')\n    do_test(args.device, args.baudrate, 'controllib')\n    do_test(args.device, args.baudrate, 'conv')\n    do_test(args.device, args.baudrate, 'ctlmath')\n    do_test(args.device, args.baudrate, 'float')\n    do_test(args.device, args.baudrate, 'hrt')\n    do_test(args.device, args.baudrate, 'int')\n    do_test(args.device, args.baudrate, 'IntrusiveQueue')\n    do_test(args.device, args.baudrate, 'List')\n    do_test(args.device, args.baudrate, 'mathlib')\n    do_test(args.device, args.baudrate, 'matrix')\n    do_test(args.device, args.baudrate, 'microbench_hrt')\n    do_test(args.device, args.baudrate, 'microbench_math')\n    do_test(args.device, args.baudrate, 'microbench_matrix')\n    do_test(args.device, args.baudrate, 'microbench_uorb')\n    do_test(args.device, args.baudrate, 'param')\n    do_test(args.device, args.baudrate, 'parameters')\n    do_test(args.device, args.baudrate, 'perf')\n    do_test(args.device, args.baudrate, 'search_min')\n    do_test(args.device, args.baudrate, 'sleep')\n    do_test(args.device, args.baudrate, 'smoothz')\n    do_test(args.device, args.baudrate, 'time')\n    do_test(args.device, args.baudrate, 'uorb')\n    do_test(args.device, args.baudrate, 'versioning')\nif __name__ == '__main__':\n    main()",
  "line_no": 53,
  "line_no_percent": "62%"
}