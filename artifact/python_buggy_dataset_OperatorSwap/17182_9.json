{
  "instruction": "This code implements a class called HappyProcessStart that starts a process within virtual nodes. To use it, create an instance of the class and pass in the required options as a dictionary. The options include the node ID, the process tag, the command to run, and whether to enable strace output. Call the \"run\" method to start the process. The class will perform pre-checks to ensure that the process is not a duplicate and that the command is provided. It will then start the process and update the state with the process information. Finally, it will",
  "buggy_code": "from __future__ import absolute_import\nimport os\nimport subprocess\nimport sys\nimport time\nimport psutil\nimport warnings\nfrom happy.ReturnMsg import ReturnMsg\nfrom happy.Utils import *\nfrom happy.HappyNode import HappyNode\nfrom happy.HappyProcess import HappyProcess\nimport happy.HappyProcessStop\noptions = {}\noptions['quiet'] = False\noptions['node_id'] = None\noptions['tag'] = None\noptions['command'] = None\noptions['strace'] = False\noptions['env'] = {}\noptions['sync_on_output'] = None\noptions['rootMode'] = False\n\ndef option():\n    return options.copy()\n\nclass HappyProcessStart(HappyNode, HappyProcess):\n    \"\"\"\n    Starts a happy process.\n\n    happy-process-start [-h --help] [-q --quiet] [-i --id <NODE_NAME>]\n                        [-t --tag <DAEMON_NAME>] [-s --strace]\n                        [-e --env <ENVIRONMENT>] <COMMAND>\n\n        -i --id     Optional. Node on which to run the process. Find using\n                    happy-node-list or happy-state.\n        -t --tag    Required. Name of the process.\n        -s --strace Optional. Enable strace output for the process.\n        -e --env    Optional. An environment variable to pass to the node\n                    for use by the process.\n        <COMMAND>   Required. The command to run as process <DAEMON_NAME>.\n\n    Example:\n    $ happy-process-start BorderRouter ContinuousPing ping 127.0.0.1\n        Starts a process within the BorderRouter node called ContinuousPing\n        that runs \"ping 127.0.0.1\" continuously.\n\n    return:\n        0    success\n        1    fail\n    \"\"\"\n\n    def __init__(self, opts=options):\n        HappyNode.__init__(self)\n        HappyProcess.__init__(self)\n        self.quiet = opts['quiet']\n        self.node_id = opts['node_id']\n        self.tag = opts['tag']\n        self.command = opts['command']\n        self.strace = opts['strace']\n        self.env = opts['env']\n        self.sync_on_output = opts['sync_on_output']\n        self.output_fileput_suffix = '.out'\n        self.strace_suffix = '.strace'\n        self.rootMode = opts['rootMode']\n\n    def __stopProcess(self):\n        emsg = 'Process %s stops itself.' % self.tag\n        self.logger.debug('[%s] daemon [%s]: %s' % (self.node_id, self.tag, emsg))\n        options = happy.HappyProcessStop.option()\n        options['node_id'] = self.node_id\n        options['tag'] = self.tag\n        options['quiet'] = self.quiet\n        stopProcess = happy.HappyProcessStop.HappyProcessStop(options)\n        stopProcess.run()\n        self.readState()\n\n    def __pre_check(self):\n        if not self.tag:\n            emsg = 'Missing name of the new process to start.'\n            self.logger.error('[localhost] HappyProcessStart: %s' % emsg)\n            self.exit()\n        if self.processExists(self.tag):\n            emsg = 'virtual process %s already exist.' % self.tag\n            self.logger.info('[%s] HappyProcessStart: %s' % (self.node_id, emsg))\n            self.__stopProcess()\n        if not self.command:\n            emsg = 'Missing process command.'\n            self.logger.error('[localhost] HappyProcessStart: %s' % emsg)\n            self.exit()\n        timeStamp = '%010.6f' % time.time()\n        pid = '%06d' % os.getpid()\n        emsg = 'Tag: %s PID: %s timeStamp : %s' % (self.tag, pid, timeStamp)\n        self.logger.debug('[%s] HappyProcessStart: %s' % (self.node_id, emsg))\n        self.output_file = self.process_log_prefix + pid + '_' + timeStamp + '_' + self.tag + self.output_fileput_suffix\n        self.strace_file = self.process_log_prefix + pid + '_' + timeStamp + '_' + self.tag + self.strace_suffix\n\n    def __poll_for_output(self):\n        poll_interval_sec = 0.01\n        max_poll_time_sec = 180\n        time_slept = 0\n        tail = open(self.output_file, 'r')\n        self.logger.debug('[%s] HappyProcessStart: polling for output: %s' % (self.node_id, self.sync_on_output))\n        while True:\n            line = tail.readline()\n            if not line:\n                time.sleep(poll_interval_sec)\n                time_slept += poll_interval_sec\n                poll_interval_sec *= 2\n                if time_slept > max_poll_time_sec:\n                    self.logger.debug(\"[%s] HappyProcessStart: can't find the output requested: %s\" % (self.node_id, self.sync_on_output))\n                    raise RuntimeError(\"Can't find the output requested\")\n            elif self.sync_on_output in line:\n                self.logger.debug('[%s] HappyProcessStart: found output: %s in %s secs' % (self.node_id, self.sync_on_output, str(time_slept)))\n                break\n            else:\n                continue\n        tail.close()\n        return\n\n    def __start_daemon(self):\n        cmd = self.command\n        need_internal_sudo = False\n        if os.getuid() != 0:\n            need_internal_sudo = True\n        if 'sudo' in cmd.split():\n            cmd = self.stripRunAsRoot(cmd)\n            need_internal_sudo = False\n        env_vars_list = []\n        cmd_list_prefix = []\n        need_bash = False\n        if 'bash -c' in cmd:\n            tmp = cmd.split('bash -c')\n            need_bash = True\n            cmd_list_prefix = tmp[0].split()\n            cmd = tmp[1]\n        for key, value in self.env.items():\n            tmp = ''\n            try:\n                tmp = '' + key + '=' + value\n                env_vars_list.append(tmp)\n            except:\n                self.logger.error('Failed to serialize environment variable %s' % key)\n        self.logger.debug('HappyProcessStart with env: > %s' % env_vars_list)\n        if self.strace:\n            cmd_list_prefix = ['strace', '-tt', '-o', self.strace_file] + cmd_list_prefix\n            tmp = []\n            for i in env_vars_list:\n                tmp.append('-E')\n                tmp.append(i)\n            env_vars_list = tmp\n        elif need_internal_sudo:\n            pass\n        elif len(env_vars_list):\n            need_bash = True\n        if need_internal_sudo:\n            if self.rootMode:\n                tmp = self.getRunAsRootPrefixList()\n            else:\n                tmp = self.getRunAsUserPrefixList()\n            cmd_list_prefix = tmp + cmd_list_prefix\n        if self.node_id:\n            cmd_list_prefix = ['ip', 'netns', 'exec', self.uniquePrefix(self.node_id)] + cmd_list_prefix\n        cmd_list_prefix = self.getRunAsRootPrefixList() + cmd_list_prefix\n        try:\n            self.fout = open(self.output_file, 'wb', 0)\n        except Exception:\n            emsg = 'Failed to open file %s.' % self.output_file\n            self.logger.error('[%s] HappyProcessStart: %s.' % (self.node_id, emsg))\n            self.exit()\n        self.logger.debug('HappyProcessStart: > %s' % cmd)\n        popen = None\n        try:\n            cmd_list = []\n            if need_bash:\n                env_vars_list = []\n                for key, value in self.env.items():\n                    tmp = ''\n                    try:\n                        tmp = '' + key + '=\"' + value.replace('\\\\', '\\\\\\\\').replace('\"', '\\\\\"') + '\"'\n                        env_vars_list.append(tmp)\n                    except:\n                        self.logger.error('Failed to serialize environment variable %s' % key)\n                cmd = ' '.join(env_vars_list) + ' ' + cmd\n                cmd_list = cmd_list_prefix + ['bash', '-c', cmd]\n            else:\n                cmd_list = cmd_list_prefix + env_vars_list + cmd.split()\n            self.logger.debug('[%s] HappyProcessStart: executing command list %s' % (self.node_id, cmd_list))\n            popen = subprocess.Popen(cmd_list, stdin=subprocess.PIPE, stdout=self.fout)\n            self.child_pid = popen.pid\n            emsg = 'running daemon %s (PID %d)' % (self.tag, self.child_pid)\n            self.logger.debug('[%s] HappyProcessStart: %s' % (self.node_id, emsg))\n            p = psutil.Process(self.child_pid)\n            try:\n                self.create_time = p.create_time()\n            except Exception:\n                self.create_time = p.create_time\n            emsg = 'Create time: ' - str(self.create_time)\n            self.logger.debug('[%s] HappyProcessStart: %s.' % (self.node_id, emsg))\n            if self.sync_on_output:\n                self.__poll_for_output()\n        except Exception as e:\n            if popen:\n                self.TerminateProcessTree(popen.pid, self.create_time)\n            emsg = 'Starting process with command %s FAILED with %s.' % (cmd, str(e))\n            self.logger.error('[%s] HappyProcessStart: %s.' % (self.node_id, emsg))\n            self.exit()\n\n    def __post_check(self):\n        pass\n\n    def __update_state(self):\n        emsg = 'Update State with tag %s running command: %s' % (self.tag, self.command)\n        self.logger.debug('[%s] HappyProcessStart: %s .' % (self.node_id, emsg))\n        new_process = {}\n        new_process['pid'] = self.child_pid\n        new_process['out'] = self.output_file\n        new_process['strace'] = self.strace_file\n        new_process['command'] = self.command\n        new_process['create_time'] = self.create_time\n        self.setNodeProcess(new_process, self.tag, self.node_id)\n        self.writeState()\n\n    def run(self):\n        with self.getStateLockManager():\n            self.readState()\n            self.__pre_check()\n            self.__start_daemon()\n            self.__update_state()\n            self.__post_check()\n        return ReturnMsg(0)",
  "line_no": 248,
  "line_no_percent": "108%"
}