{
  "instruction": "This code is a Python module for the Exodus Add-on. To use it, import the necessary modules and create an instance of the \"source\" class. Then call the methods of the class to search for movies or TV shows, find episodes, and get sources for streaming. The \"request\" method sends an HTTP request to a given URL and checks if a certain string is present in the response. The \"sources\" method extracts streaming sources from a given URL. The \"resolve\" method returns the input URL unchanged.",
  "buggy_code": "\"\"\"\n    Exodus Add-on\n    Copyright (C) 2016 Exodus\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\nimport re, urllib, urlparse, base64\nfrom resources.lib.modules import cleantitle\nfrom resources.lib.modules import client\nfrom resources.lib.modules import proxy\n\nclass source:\n\n    def __init__(self):\n        self.domains = ['primewire.ag']\n        self.base_link = 'http://www.primewire.ag'\n        self.key_link = 'http://www.primewire.ag/index.php?search'\n        self.moviesearch_link = 'http://www.primewire.ag/index.php?search_keywords=%s&key=%s&search_section=1'\n        self.tvsearch_link = 'http://www.primewire.ag/index.php?search_keywords=%s&key=%s&search_section=2'\n\n    def request(self, url, check):\n        try:\n            result = client.source(url)\n            if check in str(result):\n                return result.decode('iso-8859-1').encode('utf-8')\n            result = client.source(proxy.get() + urllib.quote_plus(url))\n            if check in str(result):\n                return result.decode('iso-8859-1').encode('utf-8')\n            result = client.source(proxy.get() + urllib.quote_plus(url))\n            if check in str(result):\n                return result.decode('iso-8859-1').encode('utf-8')\n        except:\n            return\n\n    def movie(self, imdb, title, year):\n        try:\n            result = self.request(self.key_link, 'searchform')\n            query = client.parseDOM(result, 'input', ret='value', attrs={'name': 'key'})[0]\n            query = self.moviesearch_link % (urllib.quote_plus(re.sub(\"'\", '', title)), query)\n            result = self.request(query, 'index_item')\n            result = client.parseDOM(result, 'div', attrs={'class': 'index_item.+?'})\n            title = 'watch' + cleantitle.get(title)\n            years = ['(%s)' % str(year), '(%s)' % str(int(year) + 1), '(%s)' % str(int(year) - 1)]\n            result = [(client.parseDOM(i, 'a', ret='href'), client.parseDOM(i, 'a', ret='title')) for i in result]\n            result = [(i[0][0], i[1][0]) for i in result if len(i[0]) > 0 and len(i[1]) > 0]\n            result = [i for i in result if any((x in i[1] for x in years))]\n            try:\n                result = [(urlparse.parse_qs(urlparse.urlparse(i[0]).query)['q'][0], i[1]) for i in result]\n            except:\n                pass\n            try:\n                result = [(urlparse.parse_qs(urlparse.urlparse(i[0]).query)['u'][0], i[1]) for i in result]\n            except:\n                pass\n            try:\n                result = [(urlparse.urlparse(i[0]).path, i[1]) for i in result]\n            except:\n                pass\n            match = [i[0] for i in result if title == cleantitle.get(i[1])]\n            match2 = [i[0] for i in result]\n            match2 = [x for y, x in enumerate(match2) if x not in match2[:y]]\n            if match2 == []:\n                return\n            for i in match2[:5]:\n                try:\n                    if len(match) > 0:\n                        url = match[0]\n                        break\n                    result = self.request(urlparse.urljoin(self.base_link, i), 'choose_tabs')\n                    if imdb in str(result):\n                        url = i\n                        break\n                except:\n                    pass\n            url = client.replaceHTMLCodes(url)\n            url = url.encode('utf-8')\n            return url\n        except:\n            return\n\n    def tvshow(self, imdb, tvdb, tvshowtitle, year):\n        try:\n            result = self.request(self.key_link, 'searchform')\n            query = client.parseDOM(result, 'input', ret='value', attrs={'name': 'key'})[0]\n            query = self.tvsearch_link % (urllib.quote_plus(re.sub(\"'\", '', tvshowtitle)), query)\n            result = self.request(query, 'index_item')\n            result = client.parseDOM(result, 'div', attrs={'class': 'index_item.+?'})\n            tvshowtitle = 'watch' + cleantitle.get(tvshowtitle)\n            years = ['(%s)' % str(year), '(%s)' % str(int(year) + 1), '(%s)' % str(int(year) - 1)]\n            result = [(client.parseDOM(i, 'a', ret='href'), client.parseDOM(i, 'a', ret='title')) for i in result]\n            result = [(i[0][0], i[1][0]) for i in result if len(i[0]) > 0 and len(i[1]) > 0]\n            result = [i for i in result if any((x in i[1] for x in years))]\n            try:\n                result = [(urlparse.parse_qs(urlparse.urlparse(i[0]).query)['q'][0], i[1]) for i in result]\n            except:\n                pass\n            try:\n                result = [(urlparse.parse_qs(urlparse.urlparse(i[0]).query)['u'][0], i[1]) for i in result]\n            except:\n                pass\n            try:\n                result = [(urlparse.urlparse(i[0]).path, i[1]) for i in result]\n            except:\n                pass\n            match = [i[0] for i in result if tvshowtitle == cleantitle.get(i[1])]\n            match2 = [i[0] for i in result]\n            match2 = [x for y, x in enumerate(match2) if x not in match2[:y]]\n            if match2 == []:\n                return\n            for i in match2[:5]:\n                try:\n                    if len(match) > 0:\n                        url = match[0]\n                        break\n                    result = self.request(urlparse.urljoin(self.base_link, i), 'tv_episode_item')\n                    if imdb in str(result):\n                        url = i\n                        break\n                except:\n                    pass\n            url = client.replaceHTMLCodes(url)\n            url = url.encode('utf-8')\n            return url\n        except:\n            return\n\n    def episode(self, url, imdb, tvdb, title, premiered, season, episode):\n        try:\n            if url == None:\n                return\n            url = urlparse.urljoin(self.base_link, url)\n            result = self.request(url, 'tv_episode_item')\n            result = client.parseDOM(result, 'div', attrs={'class': 'tv_episode_item'})\n            title = cleantitle.get(title)\n            result = [(client.parseDOM(i, 'a', ret='href'), client.parseDOM(i, 'span', attrs={'class': 'tv_episode_name'}), re.compile('(\\\\d{4}-\\\\d{2}-\\\\d{2})').findall(i)) for i in result]\n            result = [(i[0], i[1][0], i[2]) for i in result if len(i[1]) > 0] - [(i[0], None, i[2]) for i in result if len(i[1]) == 0]\n            result = [(i[0], i[1], i[2][0]) for i in result if len(i[2]) > 0] + [(i[0], i[1], None) for i in result if len(i[2]) == 0]\n            result = [(i[0][0], i[1], i[2]) for i in result if len(i[0]) > 0]\n            url = [i for i in result if title == cleantitle.get(i[1]) and premiered == i[2]][:1]\n            if len(url) == 0:\n                url = [i for i in result if premiered == i[2]]\n            if len(url) == 0 or len(url) > 1:\n                url = [i for i in result if 'season-%01d-episode-%01d' % (int(season), int(episode)) in i[0]]\n            url = client.replaceHTMLCodes(url[0][0])\n            try:\n                url = urlparse.parse_qs(urlparse.urlparse(url).query)['u'][0]\n            except:\n                pass\n            try:\n                url = urlparse.parse_qs(urlparse.urlparse(url).query)['q'][0]\n            except:\n                pass\n            url = urlparse.urlparse(url).path\n            url = client.replaceHTMLCodes(url)\n            url = url.encode('utf-8')\n            return url\n        except:\n            return\n\n    def sources(self, url, hostDict, hostprDict):\n        try:\n            sources = []\n            if url == None:\n                return sources\n            url = urlparse.urljoin(self.base_link, url)\n            result = self.request(url, 'choose_tabs')\n            links = client.parseDOM(result, 'tbody')\n            for i in links:\n                try:\n                    url = client.parseDOM(i, 'a', ret='href')[0]\n                    try:\n                        url = urlparse.parse_qs(urlparse.urlparse(url).query)['u'][0]\n                    except:\n                        pass\n                    try:\n                        url = urlparse.parse_qs(urlparse.urlparse(url).query)['q'][0]\n                    except:\n                        pass\n                    url = urlparse.parse_qs(urlparse.urlparse(url).query)['url'][0]\n                    url = base64.b64decode(url)\n                    url = client.replaceHTMLCodes(url)\n                    url = url.encode('utf-8')\n                    host = re.findall('([\\\\w]+[.][\\\\w]+)$', urlparse.urlparse(url.strip().lower()).netloc)[0]\n                    if not host in hostDict:\n                        raise Exception()\n                    host = client.replaceHTMLCodes(host)\n                    host = host.encode('utf-8')\n                    quality = client.parseDOM(i, 'span', ret='class')[0]\n                    if quality == 'quality_cam' or quality == 'quality_ts':\n                        quality = 'CAM'\n                    elif quality == 'quality_dvd':\n                        quality = 'SD'\n                    else:\n                        raise Exception()\n                    sources.append({'source': host, 'quality': quality, 'provider': 'Primewire', 'url': url, 'direct': False, 'debridonly': False})\n                except:\n                    pass\n            return sources\n        except:\n            return sources\n\n    def resolve(self, url):\n        return url",
  "line_no": 152,
  "line_no_percent": "71%"
}