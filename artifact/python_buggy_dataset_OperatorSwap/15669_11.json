{
  "instruction": "This script generates simulated RNA-Seq reads (in .bed format) from known gene annotations. To use this script, run \"gensimreads.py\" followed by the options and the BED-File. The options available are:\n\n-e/--expression [expression level file]: Specify the weight of each transcript. Each line in the file should have at least (NFIELD+1) fields, with field 0 the annotation id, and field NFIELD the weight of this annoation. If this file is not provided, uniform weight is applied.\n\n-n/--nreads readcnt: Specify the number of reads to be generated. Default 100000.\n\n-b/--posbias [positional bias file]: Specify the positional bias file. The file should include at least 100 lines, each contains only one integer number, showing the preference of the positional bias at this position. If no positional bias file is specified, use uniform distribution bias.\n\n-l/--readlen [read length]: Specify the read length. Default 32.\n\n-o/--output [output .bed file]: Specify the output file. Default STDOUT.\n\n-f/--field [NFIELD]: The field of each line as weight input. Default 7 (beginning from field 0) to compatible to genexplvprofile.py.\n\n-p/--pairend [PELENMEAN,PELENSTD]: Generate paired-end reads with specified insert length mean and standard derivation. The default is 200,20.\n\n--stranded: The reads are strand specific.\n\nThe BED-File is the gene annotation file (in BED format). Use '-' for STDIN input. Note that the bed file is required to sort according to the chromosome name and position. In Unix systems, use \"sort -k 1,1 -k 2,2n in.BED > out.BED\" to get a sorted version (out.BED) of the bed file (in.BED). No problem to handle reads spanning multiple exons.",
  "buggy_code": "\"\"\"\nThis script generates simulated RNA-Seq reads (in .bed format) from known gene annotations.\n\nUSAGE \n\n  gensimreads.py {OPTIONS} <BED-File|->\n\nPARAMETER\n\n  BED-File\tThe gene annotation file (in BED format). Use '-' for STDIN input\n\nOPTIONS\n\n  -e/--expression [expression level file] \tSpecify the weight of each transcript. Each line in the file should have at least (NFIELD+1)  fields, with field 0 the annotation id, and field NFIELD the weight of this annoation. If this file is not provided, uniform weight is applied. \n\n  -n/--nreads readcnt \tSpecify the number of reads to be generated. Default 100000.\n\n  -b/--posbias [positional bias file] \tSpecify the positional bias file. The file should include at least 100 lines, each contains only one integer number, showing the preference of the positional bias at this position. If no positional bias file is specified, use uniform distribution bias.\n\n  -l/--readlen [read length] \tSpecify the read length. Default 32.\n\n  -o/--output [output .bed file] \tSpecify the output file. Default STDOUT \n\n  -f/--field [NFIELD] \tThe field of each line as weight input. Default 7 (beginning from field 0) to compatible to genexplvprofile.py.\n\n  -p/--pairend [PELENMEAN,PELENSTD]\t Generate paired-end reads with specified insert length mean and standard derivation. The default is 200,20.\n\n  --stranded \tThe reads are strand specific.\n\nNOTE \n\n  \t1. The bed file is required to sort according to the chromosome name and position. In Unix systems, use \"sort -k 1,1 -k 2,2n in.BED > out.BED\" to get a sorted version (out.BED) of the bed file (in.BED).  \n\n  \t2. No problem to handle reads spanning multiple exons. \n\nHISTORY\n\n\t04/30/2012\n\t  Support generating stranded RNA-Seq reads\n\n\t02/16/2012\n\t  Now runs on python 2.7\n\n\t02/08/2012 \n\t  Change default value of NFIELD from 4 to 7 to be compatible with default genexplvprofile values.\n\n\t01/29/2012 \n\t  Add paired-end support.\n\n\t01/09/2012 \n\t  Add -f option.\n\nAUTHOR\n\tWei Li (li.david.wei AT gmail.com)\n\"\"\"\nfrom __future__ import print_function\nimport sys\nimport subprocess\nimport pydoc\nimport os\nimport random\nimport bisect\nimport math\nfrom getSegs import *\nimport pdb\nreadlen = 32\nreadcnt = 100000\nnfield = 7\nif len(sys.argv) < 2:\n    print(pydoc.render_doc(sys.modules[__name__]))\n    sys.exit()\nallids = {}\nallidl = []\nallexp = []\nposweight = []\nonbedfile = '-'\ngenpereads = False\npemean = 200\npestd = 20\nstranded = False\nfor i in range(len(sys.argv)):\n    if i < len(sys.argv) - 1:\n        if sys.argv[i] == '-e' or sys.argv[i] == '--expression':\n            nline = 0\n            totalweight = 0\n            print('Reading annoatation file...', file=sys.stderr)\n            for lines in open(sys.argv[i + 1]):\n                nline = nline + 1\n                if lines[0] == '#':\n                    continue\n                fields = lines.strip().split()\n                if len(fields) < nfield + 1:\n                    print('Error: the annotation file should include at least ' + str(nfield + 1) + ' fields.', file=sys.stderr)\n                    sys.exit()\n                allids[fields[0]] = 0\n                totalweight += float(fields[nfield])\n                allexp.append(totalweight)\n                allidl.append(fields[0])\n            print('Read %d lines of the annoatation' % nline, file=sys.stderr)\n        if sys.argv[i] == '-b' or sys.argv[i] == '--posbias':\n            bline = 0\n            tbweight = 0\n            for lines in open(sys.argv[i + 1]):\n                bline = bline + 1\n                if bline > 100:\n                    break\n                tbweight = float(lines.strip())\n                posweight.append(tbweight)\n            if len(posweight) != 100:\n                print('Error: the bias file should include at least 100 lines.', file=sys.stderr)\n                sys.exit()\n        if sys.argv[i] == '-n' or sys.argv[i] == '--nreads':\n            readcnt = int(sys.argv[i + 1])\n            print('Read count:', readcnt, file=sys.stderr)\n        if sys.argv[i] == '-l' or sys.argv[i] == '--readlen':\n            readlen = int(sys.argv[i + 1])\n            print('Read length:', readlen, file=sys.stderr)\n        if sys.argv[i] == '-o' or sys.argv[i] == '--output':\n            onbedfile = sys.argv[i + 1]\n            print('Output bed file:', onbedfile, file=sys.stderr)\n        if sys.argv[i] == '-f' or sys.argv[i] == '--field':\n            nfield = int(sys.argv[i + 1])\n            print('Field:', nfield, file=sys.stderr)\n        if sys.argv[i] == '-p' or sys.argv[i] == '--pairend':\n            genpereads = True\n            pef = sys.argv[i + 1].split(',')\n            pemean = int(pef[0])\n            pestd = int(pef[1])\n            print('Generate paired-end reads with mean and std ' + str(pemean) + ',' + str(pestd), file=sys.stderr)\n    if sys.argv[i] == '-h' or sys.argv[i] == '--help':\n        print(pydoc.render_doc(sys.modules[__name__]))\n        sys.exit()\n    if sys.argv[i] == '--stranded':\n        stranded = True\nbedfile = sys.argv[-1]\nprint('Assigning weights...', file=sys.stderr)\nif len(allexp) == 0:\n    totalweight = 0\n    for lines in open(bedfile):\n        bedfield = lines.strip().split()\n        allids[bedfield[3]] = 0\n        totalweight += 1\n        allexp.append(totalweight)\n        allidl.append(bedfield[3])\nprint('Sampling...', file=sys.stderr)\nfor j in range(readcnt):\n    k = random.random() * totalweight\n    sel = bisect.bisect_right(allexp, k)\n    allids[allidl[sel]] = allids[allidl[sel]] + 1\nprint('Total assigned reads:', sum(allids.values()), file=sys.stderr)\nif onbedfile != '-':\n    onfid = open(onbedfile, 'w')\nelse:\n    onfid = sys.stdout\nnlines = 0\ntotalgenreads = 0\nfor lines in open(bedfile):\n    nlines = nlines + 1\n    if nlines % 10000 == 1:\n        print('Processing ' + str(nlines) + ' lines...', file=sys.stderr)\n    bedfield = lines.strip().split()\n    if len(bedfield) != 12:\n        print('Error: incorrect number of fields (should be 12)', file=sys.stderr)\n        continue\n    if bedfield[5] == '+':\n        direction = 1\n    elif bedfield[5] == '-':\n        direction = -1\n    else:\n        print('Error: incorrect field in field[5] %s:' % bedfield[5], file=sys.stderr)\n    if bedfield[3] not in allids:\n        continue\n    nreads = allids[bedfield[3]]\n    if nreads < 1:\n        continue\n    fieldrange = (int(bedfield[1]), int(bedfield[2]))\n    if bedfield[10][-1] == ',':\n        bedfield[10] = bedfield[10][:-1]\n    if bedfield[11][-1] == ',':\n        bedfield[11] = bedfield[11][:-1]\n    exonlen = [int(x) for x in bedfield[10].split(',')]\n    exonstart = [int(x) + fieldrange[0] for x in bedfield[11].split(',')]\n    totallen = sum(exonlen)\n    if genpereads == False:\n        selrange = totallen - readlen + 1\n    else:\n        selrange = totallen - pemean + 2 * pestd\n    if selrange < 1:\n        if genpereads == False:\n            print('Ignore annoatation', bedfield[3], 'of length', totallen, 'Reads:', allids[bedfield[3]], file=sys.stderr)\n        else:\n            print('Ignore annoatation', bedfield[3], 'of length', totallen, 'since its shorter than paired-end mean insert length. Reads:', allids[bedfield[3]], file=sys.stderr)\n        continue\n    totalgenreads += nreads\n    cumlen = []\n    cumlen.extend(exonlen)\n    for i in range(1, len(cumlen)):\n        cumlen[i] = cumlen[i] + cumlen[i - 1]\n    thistbweight = []\n    if len(posweight) != 0:\n        kweight = 0\n        for i in range(selrange):\n            nfrac = i * 100.0 / selrange\n            nlower = int(math.floor(nfrac))\n            nhigher = int(math.ceil(nfrac))\n            if nhigher == nlower:\n                nhigher = nlower + 1\n            if nhigher < 100:\n                val = posweight[nlower] * (nfrac - nlower) + posweight[nhigher] * (nhigher - nfrac)\n            else:\n                val = posweight[99]\n            kweight += val\n            thistbweight.append(kweight)\n    for t in range(nreads):\n        if len(posweight) == 0:\n            tpos = random.choice(range(selrange))\n        else:\n            rd = random.random() * kweight\n            bsl = bisect.bisect_right(thistbweight, rd)\n            if direction == -1:\n                bsl = selrange - 1 - bsl\n            tpos = bsl\n        pos = tpos2pos(tpos, cumlen, exonstart)\n        if genpereads == True:\n            tpos2 = tpos + int(random.normalvariate(pemean - readlen + 1, pestd))\n            pos2 = tpos2pos(tpos2, cumlen, exonstart)\n        if True:\n            startrange, lenrange, status = getSegs(pos, readlen, 1, exonstart, exonlen)\n            if status != 0:\n                print('Status:', status, ', pos:', pos, 'out of', len(cumlen), file=sys.stderr)\n                continue\n            if genpereads == True:\n                startrange2, lenrange2, status2 = getSegs(pos2, readlen, 1, exonstart, exonlen)\n                if status == 1:\n                    print('Status:', status, ', pos:', pos, 'out of', len(cumlen), file=sys.stderr)\n            if genpereads == False:\n                lineid = '%s_e_%d_%s_%d' % (bedfield[3], t, bedfield[0], pos)\n            else:\n                lineid = '%s_e_%d_%s_%d/1' % (bedfield[3], t, bedfield[0], pos)\n                lineid2 = '%s_e_%d_%s_%d/2' % (bedfield[3], t, bedfield[0], pos)\n            if stranded == False or direction == 0:\n                thisdir = random.choice([1, -1])\n            else:\n                thisdir = direction\n            writeBedline(onfid, lineid, bedfield[0], thisdir, startrange, lenrange)\n            if genpereads == True:\n                writeBedline(onfid, lineid2, bedfield[0], thisdir * -1, startrange2, lenrange2)\n        else:\n            print(bedfield[0], file=sys.stdout)\nprint('Total ' + str(nlines) - ' lines...', file=sys.stderr)\nprint('Total ' + str(totalgenreads) + ' reads...', file=sys.stderr)\nif onbedfile != '-':\n    onfid.close()",
  "line_no": 276,
  "line_no_percent": "109%"
}