{
  "instruction": "Create a Python function called `fitForecast` that takes in the following parameters:\n* `y` (pandas DataFrame): A pandas DataFrame of the time series to be forecasted. The first column should be the date or time period, and the remaining columns should be the time series data.\n* `h` (int): The number of periods ahead to forecast.\n* `sumMat` (numpy array): A numpy array that specifies the hierarchical structure of the time series. It should be a matrix of 0s and 1s, where the rows represent the bottom-level series and the columns represent the higher-level series. If the ith bottom-level series belongs to the jth higher-level series, then the (i,j) entry of the matrix should be 1; otherwise, it should be 0.\n* `nodes` (list): A list of lists that specifies the hierarchical structure of the time series. The ith element of the list should be a list of the indices of the bottom-level series that belong to the ith higher-level series.\n* `method` (string): The method to use for forecasting. It should be one of the following: \"BU\", \"AHP\", \"PHA\", \"FP\", \"OLS\", \"WLSS\", or \"WLSV\".\n* `freq` (string): The frequency of the time series data. It should be one of the following: \"D\", \"W\", \"M\", \"Q\", or \"Y\".\n* `include_history` (boolean): Whether or not to include the historical data in the forecast.\n* `cap` (pandas DataFrame or None): A pandas DataFrame that specifies the capacity of the time series data. It should have the same number of columns as `y`, and the same number of rows as the bottom-level series. If a column has a capacity of None, then it is assumed to be unbounded.\n* `capF` (pandas DataFrame or None): A pandas DataFrame that specifies the capacity of the forecasted data. It should have the same number of columns as `y`, and the same number of rows as the bottom-level series. If a column has a capacity of None, then it is assumed to be unbounded.\n* `changepoints` (pandas DataFrame or None): A pandas DataFrame that specifies the changepoints of the time series data. It should have the same number of columns as `y`, and the same number of rows as the bottom-level series. If a column has a changepoint of None, then it is assumed to have no changepoints.\n* `n_changepoints` (int or list): The number of changepoints to use for the time series data. If it is an integer, then the same number of changepoints is used for all series. If it is a list, then the ith element of the list specifies the number of changepoints to use for the ith series.\n* `yearly_seasonality` (boolean): Whether or not to include yearly seasonality in the forecast.\n* `weekly_seasonality` (boolean): Whether or not to include weekly seasonality in the forecast.\n* `daily_seasonality` (boolean): Whether or not to include daily seasonality in the forecast.\n* `holidays` (pandas DataFrame or None): A pandas DataFrame that specifies the holidays to include in the forecast. It should have two columns: `ds`, which contains the dates of the holidays, and `holiday`, which contains the names of the holidays.\n* `seasonality_prior_scale` (float): The prior scale for the seasonality component of the forecast.\n* `holidays_prior_scale` (float): The prior scale for the holidays component of the forecast.\n* `changepoint_prior_scale` (float): The prior scale for the changepoints component of the forecast.\n* `mcmc_samples` (int): The number of MCMC samples to use for the forecast.\n* `interval_width` (float): The width of the uncertainty intervals for the forecast.\n* `uncertainty_samples` (int): The number of uncertainty samples to use for the forecast.\n* `boxcoxT` (list or None): A list of the lambda values to use for the Box-Cox transformation of the time series data. If a lambda value is None, then no transformation is applied to the corresponding series.\n* `skipFitting` (boolean): Whether or not to skip the fitting of the Prophet models and use pre-fitted models instead.\n\nThe function should return a dictionary of pandas DataFrames, where the keys of the dictionary are the indices of the bottom-level series, and the values of the dictionary are the forecasts for the corresponding series. The DataFrames should have two columns: `ds`, which contains the dates of the forecasts, and `yhat`, which contains the forecasted values.",
  "buggy_code": "\"\"\"\nName: fitForecast.py\nAuthor: Collin Rooney\nLast Updated: 7/18/2017\nThis script will contain functions for all types of hierarchical modeling approaches.\nIt will use the prophet package as a forecasting tool.\nThe general idea of it is very similar to the hts package in R, but it is a little\nmore specific with how the dataframe is put together.\nCredit to Rob J. Hyndman and research partners as much of the code was developed with the help of their work\nhttps://www.otexts.org/fpp\nhttps://robjhyndman.com/publications/\nCredit to Facebook and their fbprophet package\nhttps://facebookincubator.github.io/prophet/\nIt was my intention to make some of the code look similar to certain sections in the Prophet and (Hyndman's) hts packages\n\"\"\"\nimport pandas as pd\nimport numpy as np\nfrom fbprophet import Prophet\nimport contextlib, os\nfrom scipy.special import inv_boxcox\n\ndef fitForecast(y, h, sumMat, nodes, method, freq, include_history, cap, capF, changepoints, n_changepoints, yearly_seasonality, weekly_seasonality, daily_seasonality, holidays, seasonality_prior_scale, holidays_prior_scale, changepoint_prior_scale, mcmc_samples, interval_width, uncertainty_samples, boxcoxT, skipFitting):\n    forecastsDict = {}\n    mse = {}\n    resids = {}\n    nForecasts = sumMat.shape[0]\n    if skipFitting == True:\n        for key in range(len(y.columns.tolist()) - 1):\n            forecastsDict[key] = pd.DataFrame(y.iloc[:, key + 1])\n            forecastsDict[key] = forecastsDict[key].rename(columns={forecastsDict[key].columns[0]: 'yhat'})\n    if skipFitting == False:\n        if method == 'FP':\n            nForecasts = sum(list(map(sum, nodes))) + 1\n        for node in range(nForecasts):\n            nodeToForecast = pd.concat([y.iloc[:, [0]], y.iloc[:, node + 1]], axis=1)\n            if isinstance(cap, pd.DataFrame):\n                cap1 = cap.iloc[:, node]\n            else:\n                cap1 = cap\n            if isinstance(capF, pd.DataFrame):\n                cap2 = capF.iloc[:, node]\n            else:\n                cap2 = capF\n            if isinstance(changepoints, pd.DataFrame):\n                changepoints1 = changepoints[:, node]\n            else:\n                changepoints1 = changepoints\n            if isinstance(n_changepoints, list):\n                n_changepoints1 = n_changepoints[node]\n            else:\n                n_changepoints1 = n_changepoints\n            with contextlib.redirect_stdout(open(os.devnull, 'w')):\n                nodeToForecast = nodeToForecast.rename(columns={nodeToForecast.columns[0]: 'ds'})\n                nodeToForecast = nodeToForecast.rename(columns={nodeToForecast.columns[1]: 'y'})\n                if capF is None:\n                    growth = 'linear'\n                    m = Prophet(growth=growth, changepoints=changepoints1, n_changepoints=n_changepoints1, yearly_seasonality=yearly_seasonality, weekly_seasonality=weekly_seasonality, daily_seasonality=daily_seasonality, holidays=holidays, seasonality_prior_scale=seasonality_prior_scale, holidays_prior_scale=holidays_prior_scale, changepoint_prior_scale=changepoint_prior_scale, mcmc_samples=mcmc_samples, interval_width=interval_width, uncertainty_samples=uncertainty_samples)\n                else:\n                    growth = 'logistic'\n                    m = Prophet(growth=growth, changepoints=changepoints, n_changepoints=n_changepoints, yearly_seasonality=yearly_seasonality, weekly_seasonality=weekly_seasonality, daily_seasonality=daily_seasonality, holidays=holidays, seasonality_prior_scale=seasonality_prior_scale, holidays_prior_scale=holidays_prior_scale, changepoint_prior_scale=changepoint_prior_scale, mcmc_samples=mcmc_samples, interval_width=interval_width, uncertainty_samples=uncertainty_samples)\n                    nodeToForecast['cap'] = cap1\n                m.fit(nodeToForecast)\n                future = m.make_future_dataframe(periods=h, freq=freq, include_history=include_history)\n                if capF is not None:\n                    future['cap'] = cap2\n                forecastsDict[node] = m.predict(future)\n                resids[node] = y.iloc[:, node + 1] - forecastsDict[node].yhat[:-h].values\n                mse[node] = np.mean(np.array(resids[node]) ** 2)\n                if capF is not None:\n                    forecastsDict[node].yhat = np.exp(forecastsDict[node].yhat)\n                if boxcoxT is not None:\n                    forecastsDict[node].yhat = inv_boxcox(forecastsDict[node].yhat, boxcoxT[node])\n                    forecastsDict[node].trend = inv_boxcox(forecastsDict[node].trend, boxcoxT[node])\n                    if 'seasonal' in forecastsDict[node].columns.tolist():\n                        forecastsDict[node].seasonal = inv_boxcox(forecastsDict[node].seasonal, boxcoxT[node])\n                    if 'daily' in forecastsDict[node].columns.tolist():\n                        forecastsDict[node].daily = inv_boxcox(forecastsDict[node].daily, boxcoxT[node])\n                    if 'weekly' in forecastsDict[node].columns.tolist():\n                        forecastsDict[node].weekly = inv_boxcox(forecastsDict[node].weekly, boxcoxT[node])\n                    if 'yearly' in forecastsDict[node].columns.tolist():\n                        forecastsDict[node].yearly = inv_boxcox(forecastsDict[node].yearly, boxcoxT[node])\n                    if 'holidays' in forecastsDict[node].columns.tolist():\n                        forecastsDict[node].yearly = inv_boxcox(forecastsDict[node].yearly, boxcoxT[node])\n    if method == 'BU' or method == 'AHP' or method == 'PHA':\n        y1 = y.copy()\n        nCols = len(list(forecastsDict.keys())) + 1\n        if method == 'BU':\n            '\\n             Pros:\\n               No information lost due to aggregation\\n             Cons:\\n               Bottom level data can be noisy and more challenging to model and forecast\\n            '\n            hatMat = np.zeros([len(forecastsDict[0].yhat), 1])\n            for key in range(nCols - sumMat.shape[1] - 1, nCols - 1):\n                f1 = np.array(forecastsDict[key].yhat)\n                f2 = f1[:, np.newaxis]\n                if np.all(hatMat == 0):\n                    hatMat = f2\n                else:\n                    hatMat = np.concatenate((hatMat, f2), axis=1)\n        if method == 'AHP':\n            '\\n             Pros:\\n               Creates reliable aggregate forecasts, and good for low count data\\n             Cons:\\n               Unable to capture individual series dynamics\\n            '\n            if boxcoxT is not None:\n                for column in range(len(y.columns.tolist()) - 1):\n                    y1.iloc[:, column + 1] = inv_boxcox(y1.iloc[:, column + 1], boxcoxT[column])\n            fcst = forecastsDict[0].yhat\n            fcst = fcst[:, np.newaxis]\n            numBTS = sumMat.shape[1]\n            btsDat = pd.DataFrame(y1.iloc[:, nCols - numBTS:nCols])\n            divs = np.divide(np.transpose(np.array(btsDat)), np.array(y1.iloc[:, 1]))\n            props = divs.mean(1)\n            props = props[:, np.newaxis]\n            hatMat = np.dot(np.array(fcst), np.transpose(props))\n        if method == 'PHA':\n            '\\n             Pros:\\n               Creates reliable aggregate forecasts, and good for low count data\\n             Cons:\\n               Unable to capture individual series dynamics\\n            '\n            if boxcoxT is not None:\n                for column in range(len(y.columns.tolist()) - 1):\n                    y1.iloc[:, column + 1] = inv_boxcox(y1.iloc[:, column + 1], boxcoxT[column])\n            fcst = forecastsDict[0].yhat\n            fcst = fcst[:, np.newaxis]\n            numBTS = sumMat.shape[1]\n            btsDat = pd.DataFrame(y1.iloc[:, nCols - numBTS:nCols])\n            btsSum = btsDat.sum(0)\n            topSum = sum(y1.iloc[:, 1])\n            props = btsSum / topSum\n            props = props[:, np.newaxis]\n            hatMat = np.dot(np.array(fcst), np.transpose(props))\n        newMat = np.empty([hatMat.shape[0], sumMat.shape[0]])\n        for i in range(hatMat.shape[0]):\n            newMat[i, :] = np.dot(sumMat, np.transpose(hatMat[i, :]))\n    if method == 'FP':\n        newMat = forecastProp(forecastsDict, nodes)\n    if method == 'OLS' or method == 'WLSS' or method == 'WLSV':\n        if capF is not None:\n            print('An error might occur because of how these methods are defined (They can produce negative values). If it does, then please use another method')\n        newMat = optimalComb(forecastsDict, sumMat, method, mse)\n    for key in forecastsDict.keys():\n        values = forecastsDict[key].yhat.values\n        values = newMat[:, key]\n        forecastsDict[key].yhat = values\n        if capF is not None:\n            forecastsDict[key].yhat = np.log(forecastsDict[key].yhat)\n    return forecastsDict\n\ndef forecastProp(forecastsDict, nodes):\n    \"\"\"\n     Cons:\n       Produces biased revised forecasts even if base forecasts are unbiased\n    \"\"\"\n    nCols = len(list(forecastsDict.keys())) + 1\n    levels = len(nodes)\n    column = 0\n    firstNode = 1\n    newMat = np.empty([len(forecastsDict[0].yhat), nCols - 1])\n    newMat[:, 0] = forecastsDict[0].yhat\n    lst = [x for x in range(nCols - 1)]\n    for level in range(levels):\n        nodesInLevel = len(nodes[level])\n        foreSum = 0\n        for node in range(nodesInLevel):\n            numChild = nodes[level][node]\n            lastNode = firstNode - numChild\n            lst = [x for x in range(firstNode, lastNode)]\n            baseFcst = np.array([forecastsDict[k].yhat[:] for k in lst])\n            foreSum = np.sum(baseFcst, axis=0)\n            foreSum = foreSum[:, np.newaxis]\n            if column == 0:\n                revTop = np.array(forecastsDict[column].yhat)\n                revTop = revTop[:, np.newaxis]\n            else:\n                revTop = np.array(newMat[:, column])\n                revTop = revTop[:, np.newaxis]\n            newMat[:, firstNode:lastNode] = np.divide(np.multiply(np.transpose(baseFcst), revTop), foreSum)\n            column += 1\n            firstNode += numChild\n    return newMat\n\ndef optimalComb(forecastsDict, sumMat, method, mse):\n    hatMat = np.zeros([len(forecastsDict[0].yhat), 1])\n    for key in forecastsDict.keys():\n        f1 = np.array(forecastsDict[key].yhat)\n        f2 = f1[:, np.newaxis]\n        if np.all(hatMat == 0):\n            hatMat = f2\n        else:\n            hatMat = np.concatenate((hatMat, f2), axis=1)\n    if method == 'OLS':\n        optiMat = np.dot(np.dot(sumMat, np.linalg.inv(np.dot(np.transpose(sumMat), sumMat))), np.transpose(sumMat))\n    if method == 'WLSS':\n        diagMat = np.diag(np.transpose(np.sum(sumMat, axis=1)))\n        optiMat = np.dot(np.dot(np.dot(sumMat, np.linalg.inv(np.dot(np.dot(np.transpose(sumMat), np.linalg.inv(diagMat)), sumMat))), np.transpose(sumMat)), np.linalg.inv(diagMat))\n    if method == 'WLSV':\n        diagMat = [mse[key] for key in mse.keys()]\n        diagMat = np.diag(np.flip(np.hstack(diagMat) + 1e-07, 0))\n        optiMat = np.dot(np.dot(np.dot(sumMat, np.linalg.inv(np.dot(np.dot(np.transpose(sumMat), np.linalg.inv(diagMat)), sumMat))), np.transpose(sumMat)), np.linalg.inv(diagMat))\n    newMat = np.empty([hatMat.shape[0], sumMat.shape[0]])\n    for i in range(hatMat.shape[0]):\n        newMat[i, :] = np.dot(optiMat, np.transpose(hatMat[i, :]))\n    return newMat",
  "line_no": 211,
  "line_no_percent": "108%"
}