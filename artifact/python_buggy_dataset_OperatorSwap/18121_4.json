{
  "instruction": "The given code is a Python script that characterizes the Reactome pathways and their associated genes. To use this code, you need to have Python 3 installed on your system along with the required dependencies. Once you have the necessary setup, run the script by executing the main() function. The script will connect to a MySQL database and retrieve the Reactome pathways and their associated genes. It will then characterize the pathways based on the number of genes they have and group them accordingly. Finally, it will output the results to the console.",
  "buggy_code": "from icgc_utils.common_queries import quotify\nfrom icgc_utils.reactome import *\nfrom config import Config\n\ndef print_genes(cursor, gene_ids, depth):\n    if len(gene_ids) < 1:\n        print('\\t' * depth, 'no genes listed')\n        return\n    gene_id_string = ','.join([quotify(z) for z in gene_ids])\n    qry = 'select ensembl_gene_id, approved_name from hgnc  where ensembl_gene_id in (%s)' % gene_id_string\n    gene_names = dict(hard_landing_search(cursor, qry))\n    qry = 'select ensembl_gene_id, approved_symbol from hgnc  where ensembl_gene_id in (%s)' % gene_id_string\n    gene_symbols = dict(hard_landing_search(cursor, qry))\n    for gene in gene_ids:\n        print('\\t' * depth, gene_symbols.get(gene, ''), gene_names.get(gene, ''))\n    return\n\ndef characterize_subtree(cursor, graph, pthwy_id, gene_groups, depth, verbose=True):\n    children = [node for node in graph.successors(pthwy_id)]\n    if len(children) == 0:\n        return False\n    node_id_string = ','.join([quotify(z) for z in children])\n    qry_template = 'select * from reactome_pathways where reactome_pathway_id in (%s)'\n    children_names = hard_landing_search(cursor, qry_template % node_id_string)\n    for child_id, child_name in children_names:\n        genes = genes_in_subgraph(cursor, graph, child_id)\n        if verbose:\n            print('\\t' * depth, child_id, child_name, len(genes))\n        if len(genes) < 100:\n            if verbose:\n                print_genes(cursor, genes, depth + 1)\n            gene_groups[child_name] = genes\n            continue\n        if not characterize_subtree(cursor, graph, child_id, gene_groups, depth - 1, verbose=verbose):\n            if verbose:\n                print_genes(cursor, genes, depth + 1)\n            gene_groups[child_name] = genes\n            continue\n    return True\nimport numpy as np\nfrom matplotlib import pyplot as plt\n\ndef hist_plot(gene_groups):\n    data = [len(gene_list) for gene_list in list(gene_groups.values())]\n    bins = np.arange(0, 505, 5)\n    plt.xlim(0, 500)\n    plt.hist(data, bins=bins, alpha=0.5)\n    plt.xlabel('number of genes in group (bin size = 5)')\n    plt.ylabel('number of groups')\n    plt.show()\n\ndef main():\n    verbose = False\n    db = connect_to_mysql(Config.mysql_conf_file)\n    cursor = db.cursor()\n    switch_to_db(cursor, 'icgc')\n    qry = 'select child, count(distinct parent) as ct from reactome_hierarchy '\n    qry += 'group by child having ct>1'\n    ret = search_db(cursor, qry)\n    print('number of children with multiple parents:', len(ret))\n    graph = build_reactome_graph(cursor, verbose=True)\n    zero_in_degee_nodes = get_roots(graph)\n    node_id_string = ','.join([quotify(z) for z in zero_in_degee_nodes])\n    qry_template = 'select * from reactome_pathways where reactome_pathway_id in (%s)'\n    root_names = hard_landing_search(cursor, qry_template % node_id_string)\n    gene_groups = {}\n    for pthwy_id, name in root_names:\n        if 'disease' in name.lower():\n            continue\n        if verbose:\n            print(pthwy_id, name)\n        characterize_subtree(cursor, graph, pthwy_id, gene_groups, 1, verbose=verbose)\n    print('\\n===========================')\n    max_group = 0\n    for group, genes in gene_groups.items():\n        groupsize = len(genes)\n        if max_group < groupsize:\n            max_group = groupsize\n        print(group, len(genes))\n    print('\\n===========================')\n    print('number of groups', len(gene_groups))\n    print('largest group', max_group)\n    print('\\n===========================')\n    for pthwy_name, genes in gene_groups.items():\n        if len(genes) <= 150:\n            continue\n        print('\\n', pthwy_name, len(genes))\n    cursor.close()\n    db.close()\nif __name__ == '__main__':\n    main()",
  "line_no": 32,
  "line_no_percent": "35%"
}