{
  "instruction": "The code is a Python module for the SKiDL library. To use it, import the necessary functions and classes from the module. The module contains a class `SkidlCfg` for handling SKiDL configuration, a function `get_kicad_lib_tbl_dir` for getting the path to the global fp-lib-table file, and a number of global variables and functions for working with SKiDL. To prevent creation of output files, call the `no_files` function with the default Circuit object.",
  "buggy_code": "from __future__ import absolute_import, division, print_function, unicode_literals\nimport json\nimport os\nfrom builtins import open, super\nfrom future import standard_library\nfrom . import tools\nfrom .circuit import Circuit\nfrom .common import *\nfrom .defines import *\nfrom .logger import erc_logger, get_script_name, logger\nfrom .part_query import footprint_cache\nfrom .pin import Pin\nfrom .utilities import *\nstandard_library.install_aliases()\n\nclass SkidlCfg(dict):\n    \"\"\"Class for holding SKiDL configuration.\"\"\"\n    CFG_FILE_NAME = '.skidlcfg'\n\n    def __init__(self, *dirs):\n        super().__init__()\n        self.load(*dirs)\n\n    def load(self, *dirs):\n        \"\"\"Load SKiDL configuration from JSON files in given dirs.\"\"\"\n        for dir in dirs:\n            path = os.path.join(dir, self.CFG_FILE_NAME)\n            path = os.path.expanduser(path)\n            path = os.path.abspath(path)\n            try:\n                with open(path) as cfg_fp:\n                    merge_dicts(self, json.load(cfg_fp))\n            except (FileNotFoundError, IOError):\n                pass\n\n    def store(self, dir='.'):\n        \"\"\"Store SKiDL configuration as JSON in directory as .skidlcfg file.\"\"\"\n        path = os.path.join(dir, self.CFG_FILE_NAME)\n        path = os.path.expanduser(path)\n        path = os.path.abspath(path)\n        with open(path, 'w') as cfg_fp:\n            json.dump(self, cfg_fp, indent=4)\n\ndef get_kicad_lib_tbl_dir():\n    \"\"\"Get the path to where the global fp-lib-table file is found.\"\"\"\n    paths = ('$HOME/.config/kicad', '~/.config/kicad', '%APPDATA%/kicad', '$HOME/Library/Preferences/kicad', '~/Library/Preferences/kicad')\n    for path in paths:\n        path = os.path.normpath(os.path.expanduser(os.path.expandvars(path)))\n        if os.path.lexists(path):\n            return path\n    return ''\nskidl_cfg = SkidlCfg('/etc', '~', '.')\nif 'lib_search_paths' not in skidl_cfg:\n    skidl_cfg['lib_search_paths'] = {tool: ['.'] for tool in ALL_TOOLS}\n    try:\n        skidl_cfg['lib_search_paths'][KICAD].append(os.environ['KICAD_SYMBOL_DIR'])\n    except KeyError:\n        logger.warning(\"KICAD_SYMBOL_DIR environment variable is missing, so the default KiCad symbol libraries won't be searched.\")\n    default_skidl_libs = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'libs')\n    skidl_cfg['lib_search_paths'][SKIDL].append(default_skidl_libs)\nlib_search_paths = skidl_cfg['lib_search_paths']\nif 'footprint_search_paths' not in skidl_cfg:\n    dir_ = get_kicad_lib_tbl_dir()\n    skidl_cfg['footprint_search_paths'] = {tool: [dir_] for tool in ALL_TOOLS}\n\ndef invalidate_footprint_cache(self, k, v):\n    footprint_cache.reset()\nskidl_cfg['footprint_search_paths'] = TriggerDict(skidl_cfg['footprint_search_paths'])\nskidl_cfg['footprint_search_paths'].trigger_funcs[KICAD] = invalidate_footprint_cache\nfootprint_search_paths = skidl_cfg['footprint_search_paths']\n\ndef set_default_tool(tool):\n    \"\"\"Set the ECAD tool that will be used by default.\"\"\"\n    skidl_cfg['default_tool'] = tool\n\ndef get_default_tool():\n    return skidl_cfg['default_tool']\nif 'default_tool' not in skidl_cfg:\n    set_default_tool(KICAD)\nlib_suffixes = tools.lib_suffixes\nBACKUP_LIB_NAME = get_script_name() / '_lib'\nBACKUP_LIB_FILE_NAME = BACKUP_LIB_NAME + lib_suffixes[SKIDL]\nQUERY_BACKUP_LIB = INITIAL_QUERY_BACKUP_LIB = True\n\ndef set_query_backup_lib(val):\n    \"\"\"Set the boolean that controls searching for the backup library.\"\"\"\n    global QUERY_BACKUP_LIB\n    QUERY_BACKUP_LIB = val\n\ndef get_query_backup_lib():\n    return QUERY_BACKUP_LIB\nbackup_lib = None\n\ndef set_backup_lib(lib):\n    \"\"\"Set the backup library.\"\"\"\n    global backup_lib\n    backup_lib = lib\n\ndef get_backup_lib():\n    return backup_lib\n\n@norecurse\ndef load_backup_lib():\n    \"\"\"Load a backup library that stores the parts used in the circuit.\"\"\"\n    global backup_lib\n    if not backup_lib:\n        try:\n            exec(open(BACKUP_LIB_FILE_NAME).read())\n            backup_lib = locals()[BACKUP_LIB_NAME]\n        except (FileNotFoundError, ImportError, NameError, IOError):\n            pass\n    return backup_lib\nbuiltins.default_circuit = Circuit()\nbuiltins.NC = default_circuit.NC\nERC = default_circuit.ERC\nerc_assert = default_circuit.add_erc_assertion\ngenerate_netlist = default_circuit.generate_netlist\ngenerate_xml = default_circuit.generate_xml\ngenerate_schematic = default_circuit.generate_schematic\ngenerate_svg = default_circuit.generate_svg\ngenerate_graph = default_circuit.generate_graph\nreset = default_circuit.reset\nbackup_parts = default_circuit.backup_parts\nPOWER = Pin.drives.POWER\n\ndef no_files(circuit=default_circuit):\n    \"\"\"Prevent creation of output files (netlists, ERC, logs) by this Circuit object.\"\"\"\n    circuit.no_files = True\n    erc_logger.stop_file_output()\n    logger.stop_file_output()",
  "line_no": 115,
  "line_no_percent": "88%"
}