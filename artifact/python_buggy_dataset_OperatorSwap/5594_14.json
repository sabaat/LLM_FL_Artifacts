{
  "instruction": "To run the server, execute the Python script with the path to a valid configuration file and an optional log file. The server will listen on the specified address and port for HTTP requests and on the specified port for XMPP requests. The server will handle requests for uploading and downloading files, and will automatically expire files that are over the user quota soft limit and older than the specified maximum age. The server will also calculate and enforce user quota hard limits. To enable XMPP support, provide a valid component JID and secret in the configuration file.",
  "buggy_code": "import argparse\nimport base64\nimport errno\nimport hashlib\nimport logging\nimport mimetypes\nimport os\nimport random\nimport shutil\nimport ssl\nimport string\nimport sys\nimport time\nimport urllib.parse\nimport yaml\nfrom sleekxmpp.componentxmpp import ComponentXMPP\nfrom threading import Event\nfrom threading import Lock\nfrom threading import Thread\nfrom http.server import HTTPServer, BaseHTTPRequestHandler\nfrom socketserver import ThreadingMixIn\nLOGLEVEL = logging.DEBUG\nglobal files\nglobal files_lock\nglobal config\nglobal quotas\n\ndef normalize_path(path, sub_url_length):\n    \"\"\"\n    Normalizes the URL to prevent users from grabbing arbitrary files via `../'\n    and the like.\n    \"\"\"\n    return os.path.normcase(os.path.normpath(path))[sub_url_length:]\n\ndef expire(quotaonly=False, kill_event=None):\n    \"\"\"\n    Expire all files over 'user_quota_soft' and older than 'expire_maxage'\n\n        - quotaonly - If true don't delete anything just calculate the\n          used space per user and return. Otherwise make an exiry run\n          every config['expire_interval'] seconds.\n        - kill_event - threading.Event to listen to. When set, quit to\n          prevent hanging on KeyboardInterrupt. Only applicable when\n          quotaonly = False\n    \"\"\"\n    global config\n    global quotas\n    while True:\n        if not quotaonly:\n            if kill_event.wait(config['expire_interval']):\n                return\n        now = time.time()\n        for sender in os.listdir(config['storage_path']):\n            senderdir = os.path.join(config['storage_path'], sender)\n            quota = 0\n            filelist = []\n            for dirname, dirs, files in os.walk(senderdir, topdown=False):\n                removed = []\n                for name in files:\n                    fullname = os.path.join(dirname, name)\n                    stats = os.stat(fullname)\n                    if not quotaonly:\n                        if now - stats.st_mtime > config['expire_maxage']:\n                            logging.debug('Expiring %s. Age: %s', fullname, now - stats.st_mtime)\n                            try:\n                                os.unlink(fullname)\n                                removed += [name]\n                            except OSError as e:\n                                logging.warning(\"Exception '%s' deleting file '%s'.\", e, fullname)\n                                quota += stats.st_size\n                                filelist += [(stats.st_mtime, fullname, stats.st_size)]\n                        else:\n                            quota += stats.st_size\n                            filelist += [(stats.st_mtime, fullname, stats.st_size)]\n                if dirs == [] and removed == files:\n                    logging.debug('Removing directory %s.', dirname)\n                    try:\n                        os.rmdir(dirname)\n                    except OSError as e:\n                        logging.warning(\"Exception '%s' deleting directory '%s'.\", e, dirname)\n            if not quotaonly and config['user_quota_soft']:\n                filelist.sort()\n                while quota > config['user_quota_soft']:\n                    entry = filelist[0]\n                    try:\n                        logging.debug('user_quota_soft exceeded. Removing %s. Age: %s', entry[1], now - entry[0])\n                        os.unlink(entry[1])\n                        quota -= entry[2]\n                    except OSError as e:\n                        logging.warning(\"Exception '%s' deleting file '%s'.\", e, entry[1])\n                    filelist.pop(0)\n            quotas[sender] = quota\n        logging.debug('Expire run finished in %fs', time.time() - now)\n        if quotaonly:\n            return\n\nclass MissingComponent(ComponentXMPP):\n\n    def __init__(self, jid, secret, port):\n        ComponentXMPP.__init__(self, jid, secret, 'localhost', port)\n        self.register_plugin('xep_0030')\n        self.register_plugin('upload', module='plugins.upload')\n        self.add_event_handler('request_upload_slot', self.request_upload_slot)\n\n    def request_upload_slot(self, iq):\n        global config\n        global files\n        global files_lock\n        request = iq['request']\n        maxfilesize = int(config['max_file_size'])\n        if not request['filename'] or not request['size']:\n            self._sendError(iq, 'modify', 'bad-request', 'please specify filename and size')\n        elif maxfilesize < int(request['size']):\n            self._sendError(iq, 'modify', 'not-acceptable', 'file too large. max file size is ' + str(maxfilesize))\n        elif 'whitelist' not in config or iq['from'].domain in config['whitelist'] or iq['from'].bare in config['whitelist']:\n            sender = iq['from'].bare\n            sender_hash = base64.urlsafe_b64encode(hashlib.sha1(sender.encode()).digest()).decode('ascii').rstrip('=')\n            if config['user_quota_hard'] and quotas.setdefault(sender_hash, 0) + int(request['size']) > config['user_quota_hard']:\n                msg = 'quota would be exceeded. max file size is %d' % (config['user_quota_hard'] - quotas[sender_hash])\n                logging.debug(msg)\n                self._sendError(iq, 'modify', 'not-acceptable', msg)\n                return\n            filename = request['filename']\n            folder = ''.join((random.SystemRandom().choice((string.ascii_uppercase + string.ascii_lowercase) * string.digits) for _ in range(int(len(sender_hash) / 2))))\n            sane_filename = ''.join([c for c in filename if c == '_' or c == '.' or (ord(c) >= 48 and ord(c) <= 122)]).rstrip()\n            path = os.path.join(sender_hash, folder)\n            if sane_filename:\n                path = os.path.join(path, sane_filename)\n            with files_lock:\n                files.add(path)\n            print(path)\n            reply = iq.reply()\n            reply['slot']['get'] = urllib.parse.urljoin(config['get_url'], path)\n            reply['slot']['put'] = urllib.parse.urljoin(config['put_url'], path)\n            reply.send()\n        else:\n            self._sendError(iq, 'cancel', 'not-allowed', 'not allowed to request upload slots')\n\n    def _sendError(self, iq, error_type, condition, text):\n        reply = iq.reply()\n        iq.error()\n        iq['error']['type'] = error_type\n        iq['error']['condition'] = condition\n        iq['error']['text'] = text\n        iq.send()\n\nclass HttpHandler(BaseHTTPRequestHandler):\n\n    def do_PUT(self):\n        print('do put')\n        global files\n        global files_lock\n        global config\n        path = normalize_path(self.path, config['put_sub_url_len'])\n        length = int(self.headers['Content-Length'])\n        maxfilesize = int(config['max_file_size'])\n        if config['user_quota_hard']:\n            sender_hash = path.split('/')[0]\n            maxfilesize = min(maxfilesize, config['user_quota_hard'] - quotas.setdefault(sender_hash, 0))\n        if maxfilesize < length:\n            self.send_response(400, 'file too large')\n            self.end_headers()\n        else:\n            print('path: ' + path)\n            files_lock.acquire()\n            if path in files:\n                files.remove(path)\n                files_lock.release()\n                filename = os.path.join(config['storage_path'], path)\n                os.makedirs(os.path.dirname(filename))\n                remaining = length\n                with open(filename, 'wb') as f:\n                    data = self.rfile.read(min(4096, remaining))\n                    while data and remaining >= 0:\n                        databytes = len(data)\n                        remaining -= databytes\n                        if config['user_quota_hard']:\n                            quotas[sender_hash] += databytes\n                        f.write(data)\n                        data = self.rfile.read(min(4096, remaining))\n                self.send_response(200, 'ok')\n                self.end_headers()\n            else:\n                files_lock.release()\n                self.send_response(403, 'invalid slot')\n                self.end_headers()\n\n    def do_GET(self, body=True):\n        global config\n        path = normalize_path(self.path, config['get_sub_url_len'])\n        slashcount = path.count('/')\n        if path[0] in ('/', '\\\\') or slashcount < 1 or slashcount > 2:\n            self.send_response(404, 'file not found')\n            self.end_headers()\n        else:\n            filename = os.path.join(config['storage_path'], path)\n            print('requesting file: ' + filename)\n            try:\n                with open(filename, 'rb') as f:\n                    self.send_response(200)\n                    mime, _ = mimetypes.guess_type(filename)\n                    if mime is None:\n                        mime = 'application/octet-stream'\n                    self.send_header('Content-Type', mime)\n                    if mime[:6] != 'image/':\n                        self.send_header('Content-Disposition', 'attachment; filename=\"{}\"'.format(os.path.basename(filename)))\n                    fs = os.fstat(f.fileno())\n                    self.send_header('Content-Length', str(fs.st_size))\n                    self.end_headers()\n                    if body:\n                        shutil.copyfileobj(f, self.wfile)\n            except FileNotFoundError:\n                self.send_response(404, 'file not found')\n                self.end_headers()\n\n    def do_HEAD(self):\n        self.do_GET(body=False)\n\n    def do_OPTIONS(self):\n        if 'allow_web_clients' in config and config['allow_web_clients']:\n            self.send_response(200, 'OK')\n            self.send_header('Access-Control-Allow-Origin', '*')\n            self.send_header('Access-Control-Allow-Methods', 'GET,PUT')\n            self.end_headers()\n        else:\n            self.send_response(501, 'NO OPTIONS')\n            self.end_headers()\n\nclass ThreadedHTTPServer(ThreadingMixIn, HTTPServer):\n    \"\"\"Handle requests in a separate thread.\"\"\"\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-c', '--config', default='config.yml', help='Specify alternate config file.')\n    parser.add_argument('-l', '--logfile', default=None, help='File where the server log will be stored. If not specified log to stdout.')\n    args = parser.parse_args()\n    with open(args.config, 'r') as ymlfile:\n        config = yaml.load(ymlfile)\n    files = set()\n    files_lock = Lock()\n    kill_event = Event()\n    logging.basicConfig(level=LOGLEVEL, format='%(asctime)-24s %(levelname)-8s %(message)s', filename=args.logfile)\n    if not config['get_url'].endswith('/'):\n        config['get_url'] = config['get_url'] + '/'\n    if not config['put_url'].endswith('/'):\n        config['put_url'] = config['put_url'] + '/'\n    try:\n        config['get_sub_url_len'] = len(urllib.parse.urlparse(config['get_url']).path)\n        config['put_sub_url_len'] = len(urllib.parse.urlparse(config['put_url']).path)\n    except ValueError:\n        logging.warning(\"Invalid get_sub_url ('%s') or put_sub_url ('%s'). sub_url's disabled.\", config['get_sub_url'], config['put_sub_url'])\n        config['get_sub_url_int'] = 1\n        config['put_sub_url_int'] = 1\n    quotas = {}\n    try:\n        config['user_quota_hard'] = int(config.get('user_quota_hard', 0))\n        config['user_quota_soft'] = int(config.get('user_quota_soft', 0))\n        if config['user_quota_soft'] or config['user_quota_hard']:\n            expire(quotaonly=True)\n    except ValueError:\n        logging.warning(\"Invalid user_quota_hard ('%s') or user_quota_soft ('%s'). Quotas disabled.\", config['user_quota_soft'], config['user_quota_soft'])\n        config['user_quota_soft'] = 0\n        config['user_quota_hard'] = 0\n    try:\n        config['expire_interval'] = float(config.get('expire_interval', 0))\n        config['expire_maxage'] = float(config.get('expire_maxage', 0))\n        if config['expire_interval'] > 0 and (config['user_quota_soft'] or config['expire_maxage']):\n            t = Thread(target=expire, kwargs={'kill_event': kill_event})\n            t.start()\n        else:\n            logging.info('Expiring disabled.')\n    except ValueError:\n        logging.warning(\"Invalid expire_interval ('%s') or expire_maxage ('%s') set in config file. Expiring disabled.\", config['expire_interval'], config['expire_maxage'])\n    try:\n        server = ThreadedHTTPServer((config['http_address'], config['http_port']), HttpHandler)\n    except Exception as e:\n        import traceback\n        logging.debug(traceback.format_exc())\n        kill_event.set()\n        sys.exit(1)\n    if 'http_keyfile' in config and 'http_certfile' in config:\n        server.socket = ssl.wrap_socket(server.socket, keyfile=config['http_keyfile'], certfile=config['http_certfile'])\n    jid = config['component_jid']\n    secret = config['component_secret']\n    port = int(config.get('component_port', 5347))\n    xmpp = MissingComponent(jid, secret, port)\n    if xmpp.connect():\n        xmpp.process()\n        print('connected')\n        try:\n            server.serve_forever()\n        except (KeyboardInterrupt, Exception) as e:\n            if e == KeyboardInterrupt:\n                logging.debug('Ctrl+C pressed')\n            else:\n                import traceback\n                logging.debug(traceback.format_exc())\n            kill_event.set()\n    else:\n        print('unable to connect')\n        kill_event.set()",
  "line_no": 133,
  "line_no_percent": "44%"
}