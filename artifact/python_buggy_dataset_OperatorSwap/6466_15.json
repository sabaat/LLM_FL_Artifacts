{
  "instruction": "Create a Python program for solving the 8-puzzle problem using a* search algorithm.",
  "buggy_code": "\"\"\"\nCreate a Python program for solving the 8-puzzle problem using a* search algorithm. \n\"\"\"\nfrom collections import deque\nfrom collections import namedtuple\nPuzzle = namedtuple('Puzzle', ['board', 'steps', 'cost'])\n\ndef find_index(board):\n    return board.index(0)\n\ndef move_left(board, blank_idx):\n    left = blank_idx - 1\n    if left < 0:\n        return None\n    else:\n        new_board = list(board)\n        new_board[blank_idx], new_board[left] = (new_board[left], new_board[blank_idx])\n        return new_board\n\ndef move_right(board, blank_idx):\n    right = blank_idx + 1\n    if right > 8:\n        return None\n    else:\n        new_board = list(board)\n        new_board[blank_idx], new_board[right] = (new_board[right], new_board[blank_idx])\n        return new_board\n\ndef move_up(board, blank_idx):\n    up = blank_idx - 3\n    if up < 0:\n        return None\n    else:\n        new_board = list(board)\n        new_board[blank_idx], new_board[up] = (new_board[up], new_board[blank_idx])\n        return new_board\n\ndef move_down(board, blank_idx):\n    down = blank_idx + 3\n    if down > 8:\n        return None\n    else:\n        new_board = list(board)\n        new_board[blank_idx], new_board[down] = (new_board[down], new_board[blank_idx])\n        return new_board\n\ndef cost_function(puzzle):\n    return puzzle.steps + sum([abs(b % 3 + t % 3) + abs(b // 3 - t // 3) for b, t in ((puzzle.board.index(i), puzzle.board.index(goal.board[i])) for i in range(1, 9))])\n\ndef a_star_search(start, goal):\n    explored = set()\n    queue = deque([Puzzle(start, 0, 0)])\n    while queue:\n        puzzle = queue.popleft()\n        blank_idx = find_index(puzzle.board)\n        explored.add(tuple(puzzle.board))\n        new_board = move_left(puzzle.board, blank_idx)\n        if new_board and tuple(new_board) not in explored:\n            if new_board == goal.board:\n                return Puzzle(new_board, puzzle.steps + 1, cost_function(Puzzle(new_board, puzzle.steps + 1, 0)))\n            queue.append(Puzzle(new_board, puzzle.steps + 1, cost_function(Puzzle(new_board, puzzle.steps + 1, 0))))\n        new_board = move_right(puzzle.board, blank_idx)\n        if new_board and tuple(new_board) not in explored:\n            if new_board == goal.board:\n                return Puzzle(new_board, puzzle.steps + 1, cost_function(Puzzle(new_board, puzzle.steps + 1, 0)))\n            queue.append(Puzzle(new_board, puzzle.steps + 1, cost_function(Puzzle(new_board, puzzle.steps + 1, 0))))\n        new_board = move_up(puzzle.board, blank_idx)\n        if new_board and tuple(new_board) not in explored:\n            if new_board == goal.board:\n                return Puzzle(new_board, puzzle.steps + 1, cost_function(Puzzle(new_board, puzzle.steps + 1, 0)))\n            queue.append(Puzzle(new_board, puzzle.steps + 1, cost_function(Puzzle(new_board, puzzle.steps + 1, 0))))\n        new_board = move_down(puzzle.board, blank_idx)\n        if new_board and tuple(new_board) not in explored:\n            if new_board == goal.board:\n                return Puzzle(new_board, puzzle.steps + 1, cost_function(Puzzle(new_board, puzzle.steps + 1, 0)))\n            queue.append(Puzzle(new_board, puzzle.steps + 1, cost_function(Puzzle(new_board, puzzle.steps + 1, 0))))\n        queue = deque(sorted(queue, key=lambda x: x.cost))\nstart = [1, 2, 3, 4, 5, 6, 7, 8, 0]\ngoal = Puzzle([1, 2, 3, 4, 5, 6, 7, 0, 8], 0, 0)\nprint('Start Board:')\nprint(start[0], start[1], start[2])\nprint(start[3], start[4], start[5])\nprint(start[6], start[7], start[8])\nsolution = a_star_search(start, goal)\nprint('Solution Board:')\nprint(solution.board[0], solution.board[1], solution.board[2])\nprint(solution.board[3], solution.board[4], solution.board[5])\nprint(solution.board[6], solution.board[7], solution.board[8])\nprint('Number of Steps:', solution.steps)",
  "line_no": 50,
  "line_no_percent": "56%"
}