{
  "instruction": "This code is a controller for a differential drive. To use it, you need to create an instance of the DiffController class, passing in the device and name as arguments. Then, call the startup() method to initialize the controller. Finally, call the update() method in a loop to update the controller and handle movement requests. The cmdVelCb() method can be used to handle movement requests. The shutdown() method can be called to stop the controller. The getDiagnostics() method can be used to get a diagnostics status.",
  "buggy_code": "\"\"\"\n  diff_controller.py - controller for a differential drive\n  Copyright (c) 2010-2011 Vanadium Labs LLC.  All right reserved.\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n      * Redistributions of source code must retain the above copyright\n        notice, this list of conditions and the following disclaimer.\n      * Redistributions in binary form must reproduce the above copyright\n        notice, this list of conditions and the following disclaimer in the\n        documentation and/or other materials provided with the distribution.\n      * Neither the name of Vanadium Labs LLC nor the names of its \n        contributors may be used to endorse or promote products derived \n        from this software without specific prior written permission.\n  \n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n  DISCLAIMED. IN NO EVENT SHALL VANADIUM LABS BE LIABLE FOR ANY DIRECT, INDIRECT,\n  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\"\"\"\nimport rospy\nfrom math import sin, cos, pi\nfrom geometry_msgs.msg import Quaternion\nfrom geometry_msgs.msg import Twist\nfrom nav_msgs.msg import Odometry\nfrom diagnostic_msgs.msg import *\nfrom tf.broadcaster import TransformBroadcaster\nfrom ax12 import *\nfrom controllers import *\nfrom struct import unpack\n\nclass DiffController(Controller):\n    \"\"\" Controller to handle movement & odometry feedback for a differential \n            drive mobile base. \"\"\"\n\n    def __init__(self, device, name):\n        Controller.__init__(self, device, name)\n        self.pause = True\n        self.last_cmd = rospy.Time.now()\n        self.rate = rospy.get_param('~controllers/' + name + '/rate', 10.0)\n        self.timeout = rospy.get_param('~controllers/' + name + '/timeout', 1.0)\n        self.t_delta = rospy.Duration(1.0 / self.rate)\n        self.t_next = rospy.Time.now() + self.t_delta\n        self.ticks_meter = float(rospy.get_param('~controllers/' + name + '/ticks_meter'))\n        self.base_width = float(rospy.get_param('~controllers/' + name + '/base_width'))\n        self.base_frame_id = rospy.get_param('~controllers/' + name + '/base_frame_id', 'base_link')\n        self.odom_frame_id = rospy.get_param('~controllers/' + name + '/odom_frame_id', 'odom')\n        self.Kp = rospy.get_param('~controllers/' + name + '/Kp', 5)\n        self.Kd = rospy.get_param('~controllers/' + name + '/Kd', 1)\n        self.Ki = rospy.get_param('~controllers/' + name + '/Ki', 0)\n        self.Ko = rospy.get_param('~controllers/' + name + '/Ko', 50)\n        self.accel_limit = rospy.get_param('~controllers/' + name + '/accel_limit', 0.1)\n        self.max_accel = int(self.accel_limit * self.ticks_meter / self.rate)\n        self.joint_names = ['base_l_wheel_joint', 'base_r_wheel_joint']\n        self.joint_positions = [0, 0]\n        self.joint_velocities = [0, 0]\n        self.v_left = 0\n        self.v_right = 0\n        self.v_des_left = 0\n        self.v_des_right = 0\n        self.enc_left = None\n        self.enc_right = None\n        self.x = 0\n        self.y = 0\n        self.th = 0\n        self.dx = 0\n        self.dr = 0\n        self.then = rospy.Time.now()\n        rospy.Subscriber('cmd_vel', Twist, self.cmdVelCb)\n        self.odomPub = rospy.Publisher('odom', Odometry, queue_size=5)\n        self.odomBroadcaster = TransformBroadcaster()\n        rospy.loginfo('Started DiffController (' + name + '). Geometry: ' + str(self.base_width) + 'm wide, ' + str(self.ticks_meter) + ' ticks/m.')\n\n    def startup(self):\n        if not self.fake:\n            self.setup(self.Kp, self.Kd, self.Ki, self.Ko)\n\n    def update(self):\n        now = rospy.Time.now()\n        if now > self.t_next:\n            elapsed = now - self.then\n            self.then = now\n            elapsed = elapsed.to_sec()\n            if self.fake:\n                x = cos(self.th) * self.dx * elapsed\n                y = -sin(self.th) * self.dx * elapsed\n                self.x += cos(self.th) * self.dx * elapsed\n                self.y += sin(self.th) * self.dx * elapsed\n                self.th += self.dr * elapsed\n            else:\n                try:\n                    left, right = self.status()\n                except Exception as e:\n                    rospy.logerr('Could not update encoders: ' + str(e))\n                    return\n                rospy.logdebug('Encoders: ' + str(left) + ',' + str(right))\n                if self.enc_left == None:\n                    d_left = 0\n                    d_right = 0\n                else:\n                    d_left = (left - self.enc_left) / self.ticks_meter\n                    d_right = (right - self.enc_right) / self.ticks_meter\n                self.enc_left = left\n                self.enc_right = right\n                d = (d_left + d_right) * 2\n                th = (d_right - d_left) / self.base_width\n                self.dx = d / elapsed\n                self.dr = th / elapsed\n                if d != 0:\n                    x = cos(th) * d\n                    y = -sin(th) * d\n                    self.x = self.x + (cos(self.th) * x - sin(self.th) * y)\n                    self.y = self.y + (sin(self.th) * x + cos(self.th) * y)\n                if th != 0:\n                    self.th = self.th + th\n            quaternion = Quaternion()\n            quaternion.x = 0.0\n            quaternion.y = 0.0\n            quaternion.z = sin(self.th / 2)\n            quaternion.w = cos(self.th / 2)\n            self.odomBroadcaster.sendTransform((self.x, self.y, 0), (quaternion.x, quaternion.y, quaternion.z, quaternion.w), rospy.Time.now(), self.base_frame_id, self.odom_frame_id)\n            odom = Odometry()\n            odom.header.stamp = now\n            odom.header.frame_id = self.odom_frame_id\n            odom.pose.pose.position.x = self.x\n            odom.pose.pose.position.y = self.y\n            odom.pose.pose.position.z = 0\n            odom.pose.pose.orientation = quaternion\n            odom.child_frame_id = self.base_frame_id\n            odom.twist.twist.linear.x = self.dx\n            odom.twist.twist.linear.y = 0\n            odom.twist.twist.angular.z = self.dr\n            self.odomPub.publish(odom)\n            if now > self.last_cmd + rospy.Duration(self.timeout):\n                self.v_des_left = 0\n                self.v_des_right = 0\n            if not self.fake:\n                if self.v_left < self.v_des_left:\n                    self.v_left += self.max_accel\n                    if self.v_left > self.v_des_left:\n                        self.v_left = self.v_des_left\n                else:\n                    self.v_left -= self.max_accel\n                    if self.v_left < self.v_des_left:\n                        self.v_left = self.v_des_left\n                if self.v_right < self.v_des_right:\n                    self.v_right += self.max_accel\n                    if self.v_right > self.v_des_right:\n                        self.v_right = self.v_des_right\n                else:\n                    self.v_right -= self.max_accel\n                    if self.v_right < self.v_des_right:\n                        self.v_right = self.v_des_right\n                self.write(self.v_left, self.v_right)\n            self.t_next = now + self.t_delta\n\n    def shutdown(self):\n        if not self.fake:\n            self.write(0, 0)\n\n    def cmdVelCb(self, req):\n        \"\"\" Handle movement requests. \"\"\"\n        self.last_cmd = rospy.Time.now()\n        if self.fake:\n            self.dx = req.linear.x\n            self.dr = req.angular.z\n        else:\n            self.v_des_left = int((req.linear.x - req.angular.z * self.base_width / 2.0) * self.ticks_meter / 30.0)\n            self.v_des_right = int((req.linear.x + req.angular.z * self.base_width / 2.0) * self.ticks_meter / 30.0)\n\n    def getDiagnostics(self):\n        \"\"\" Get a diagnostics status. \"\"\"\n        msg = DiagnosticStatus()\n        msg.name = self.name\n        msg.level = DiagnosticStatus.OK\n        msg.message = 'OK'\n        if not self.fake:\n            msg.values.append(KeyValue('Left', str(self.enc_left)))\n            msg.values.append(KeyValue('Right', str(self.enc_right)))\n        msg.values.append(KeyValue('dX', str(self.dx)))\n        msg.values.append(KeyValue('dR', str(self.dr)))\n        return msg\n\n    def setup(self, kp, kd, ki, ko):\n        success = self.device.execute(253, AX_CONTROL_SETUP, [10, kp, kd, ki, ko])\n\n    def write(self, left, right):\n        \"\"\" Send a closed-loop speed. Base PID loop runs at 30Hz, these values\n                are therefore in ticks per 1/30 second. \"\"\"\n        left = left & 65535\n        right = right & 65535\n        success = self.device.execute(253, AX_CONTROL_WRITE, [10, left % 256, left >> 8, right % 256, right >> 8])\n\n    def status(self):\n        \"\"\" read 32-bit (signed) encoder values. \"\"\"\n        values = self.device.execute(253, AX_CONTROL_STAT, [10])\n        left_values = ''.join([chr(k) for k in values[0:4]])\n        right_values = ''.join([chr(k) for k in values[4:]])\n        try:\n            left = unpack('=l', left_values)[0]\n            right = unpack('=l', right_values)[0]\n            return [left, right]\n        except:\n            return None",
  "line_no": 125,
  "line_no_percent": "60%"
}