{
  "instruction": "Create a Python script that sets up a communication class and an execution handler to receive and execute instructions from an OCaml process. The script should include methods to convert integers to 8-byte signed integers, convert Python objects to BSON format, and resolve arguments passed to methods. The script should also handle exceptions and send return values back to the OCaml process. Finally, the script should accept command line arguments for the working directory, read pipe path, and write pipe path.",
  "buggy_code": "from time import time\nfrom struct import pack, unpack\nimport bson, sys, os, codecs\nfrom random import randint\nfrom traceback import print_exc\n\ndef int_to_int64_bytes(i):\n    return pack('>q', i)\n\ndef py_to_bson(val):\n    if type(val) is int:\n        return bson.int64.Int64(val)\n    if sys.version_info.major == 2 and type(val) is str:\n        return bson.binary.Binary(val)\n    return val\n\ndef exit_lymp():\n    sys.stdout.close()\n    exit(0)\n\nclass PipeReaderWriter:\n\n    def __init__(self, read_pipe_name, write_pipe_name):\n        self.get_pipes(read_pipe_name, write_pipe_name)\n\n    def get_pipes(self, read_pipe_name, write_pipe_name):\n        self.write_pipe = open(write_pipe_name, 'wb', 0)\n        self.read_pipe = open(read_pipe_name, 'rb', 0)\n\n    def send_bytes(self, byts):\n        self.write_pipe.write(pack('>q', len(byts)))\n        self.write_pipe.write(byts)\n\n    def get_bytes(self):\n        try:\n            nb_bytes = unpack('>q', self.read_pipe.read(8))[0]\n        except:\n            exit_lymp()\n        byts = b'' if sys.version_info.major == 3 else ''\n        while len(byts) < nb_bytes:\n            byts += self.read_pipe.read(nb_bytes)\n        return byts\n\nclass ExecutionHandler:\n    to_ret_types = {int: 'i', tuple: 't', list: 'l', str: 's', float: 'f', type(None): 'n', bool: 'b', bytes: 'B'}\n    if sys.version_info.major == 2:\n        to_ret_types[unicode] = 's'\n        to_ret_types[str] = 'B'\n\n    def __init__(self, reader_writer):\n        self.reader_writer = reader_writer\n        self.modules = {}\n        self.objs = {}\n        self.ref_nb = 0\n\n    def loop(self):\n        while True:\n            command_bytes = self.reader_writer.get_bytes()\n            if command_bytes == b'done':\n                exit_lymp()\n            instruction = bson.BSON.decode(bson.BSON(command_bytes))\n            try:\n                ret = self.execute_instruction(instruction)\n                sys.stdout.flush()\n                self.send_ret(ret, ret_ref='R' in instruction)\n            except BaseException as e:\n                print_exc()\n                sys.stdout.flush()\n                self.send_ret('', exception=True)\n\n    def ret_to_msg(self, ret, ret_ref):\n        msg = {}\n        if ret_ref or type(ret) not in self.to_ret_types:\n            self.ref_nb += 1\n            self.objs[self.ref_nb] = ret\n            msg['t'] = 'r'\n            msg['v'] = bson.code.Code(str(self.ref_nb))\n        else:\n            msg['t'] = self.to_ret_types[type(ret)]\n            if type(ret) is tuple:\n                ret = list(ret)\n            if type(ret) is list:\n                msg['v'] = []\n                for elt in ret:\n                    msg['v'].append(self.ret_to_msg(elt, False))\n            else:\n                msg['v'] = py_to_bson(ret)\n        return msg\n\n    def send_ret(self, ret, exception=False, ret_ref=False):\n        if exception:\n            msg = {}\n            msg['t'] = 'e'\n            msg['v'] = ''\n        else:\n            msg = self.ret_to_msg(ret, ret_ref)\n        msg = bytes(bson.BSON.encode(msg))\n        self.reader_writer.send_bytes(msg)\n\n    def resolve_args(self, args):\n        named = {}\n        i = 0\n        for arg in args:\n            if type(arg) is list and len(arg) == 2 and (type(arg[0]) is bson.code.Code) and (str(arg[0])[0] == '!'):\n                named[str(arg[0])[1:]] = self.resolve_args([arg[1]])[0][0]\n                del args[i]\n                continue\n            if type(arg) is bson.binary.Binary:\n                args[i] = bytes(arg)\n            if type(arg) is bson.code.Code:\n                args[i] = self.objs[int(arg)]\n            if type(arg) is bson.int64.Int64:\n                args[i] = int(arg)\n            if sys.version_info.major == 2 and type(arg) is str:\n                args[i] = args[i].decode('utf-8')\n            if sys.version_info.major == 2 and type(arg) is bson.binary.Binary:\n                args[i] = str(arg)\n            if type(arg) is list:\n                args[i] = self.resolve_args(arg)[0]\n            if type(arg) is dict:\n                args[i] = tuple(self.resolve_args(arg['v'])[0])\n            i += 1\n        return (args, named)\n\n    def execute_instruction(self, instruction):\n        if 'r' in instruction:\n            if 'd' in instruction and instruction['r'] not in self.objs:\n                return None\n            module = self.objs[instruction['r']]\n            if 'd' in instruction:\n                del self.objs[instruction['r']]\n                return None\n            if 'g' in instruction:\n                return module\n        else:\n            if sys.version_info.major == 2 and instruction['m'] == 'builtins':\n                instruction['m'] = '__builtin__'\n            if instruction['m'] not in self.modules:\n                __import__(instruction['m'])\n                self.modules[instruction['m']] = sys.modules[instruction['m']]\n            module = self.modules[instruction['m']]\n        if 's' in instruction:\n            args, named = self.resolve_args(instruction['a'])\n            arg = args[1]\n            setattr(module, instruction['f'], arg)\n            return None\n        func_or_attr = getattr(module, instruction['f'])\n        if 't' in instruction:\n            return func_or_attr\n        args = instruction['a']\n        args, named = self.resolve_args(args)\n        ret = func_or_attr(*args, **named)\n        return ret\nworking_directory = sys.argv[1]\nwrite_pipe_path = sys.argv[2]\nread_pipe_path = sys.argv[3]\nos.chdir(working_directory)\nsys.path.insert(0, working_directory)\nsys.stdout = codecs.open('python_log', 'w', encoding='utf-8')\nsys.stderr = sys.stdout\ncommunication = PipeReaderWriter(read_pipe_path, write_pipe_path)\nhandler = ExecutionHandler(communication)\nhandler.loop()",
  "line_no": 154,
  "line_no_percent": "94%"
}