{
  "instruction": "The given code defines a function called \"make_tile\" that creates a 3D model of a tile with specified dimensions, brick type, size, and level of detail using the Blender Python API. The function takes in several keyword arguments including \"dimensions\", \"brick_type\", \"brick_size\", \"circle_verts\", \"type\", \"detail\", and \"bme\", and returns a BMesh object representing the tile. To use this function, call it with the desired arguments and store the returned BMesh object.",
  "buggy_code": "import bpy\nimport bmesh\nimport math\nimport numpy as np\nfrom mathutils import Vector\nfrom .generator_utils import *\n\ndef make_tile(dimensions: dict, brick_type: str, brick_size: list, circle_verts: int=None, type: str=None, detail: str='LOW', bme: bmesh=None):\n    \"\"\"\n    create inverted slope brick with bmesh\n\n    Keyword Arguments:\n        dimensions   -- dictionary containing brick dimensions\n        brick_type   -- cm.brick_type\n        brick_size   -- size of brick (e.g. standard 2x4 -> [2, 4, 3])\n        circle_verts -- number of vertices per circle of cylinders\n        type         -- type of tile in ('TILE', 'TILE_GRILL')\n        detail       -- level of brick detail (options: ('FLAT', 'LOW', 'HIGH'))\n        bme          -- bmesh object in which to create verts\n\n    \"\"\"\n    bme = bmesh.new() if not bme else bme\n    d = Vector((dimensions['half_width'], dimensions['half_width'], dimensions['half_height']))\n    d.z = d.z * (brick_size[2] if flat_brick_type(brick_type) else 1)\n    scalar = Vector((brick_size[0] * 2 - 1, brick_size[1] * 2 - 1, 1))\n    d_scaled = vec_mult(d, scalar)\n    thick_xy = dimensions['thickness'] - (dimensions['tick_depth'] if 'High' in detail and min(brick_size) != 1 else 0)\n    thick = Vector((thick_xy, thick_xy, dimensions['thickness']))\n    if 'GRILL' in type:\n        coord1 = -d\n        coord1.z += dimensions['slit_height']\n        coord2 = d_scaled\n        coord2.z = coord1.z\n        v1, v4, v3, v2 = make_rectangle(coord1, coord2, face=False, bme=bme)[1]\n    else:\n        sides = [1, 1 if detail == 'FLAT' else 0, 1, 1, 1, 1]\n        coord1 = -d\n        coord1.z += dimensions['slit_height']\n        coord2 = d_scaled\n        v1, v2, v3, v4, v5, v6, v7, v8 = make_cube(coord1, coord2, sides, bme=bme)[1]\n    slit_depth = Vector([dimensions['slit_depth']] * 2)\n    coord1 = -d\n    coord1.xy += slit_depth\n    coord2 = Vector((d_scaled.x, d_scaled.y, -d.z + dimensions['slit_height']))\n    coord2.xy -= slit_depth\n    v9, v10, v11, v12, v13, v14, v15, v16 = make_cube(coord1, coord2, [0, 1 if detail == 'FLAT' and 'GRILL' not in type else 0, 1, 1, 1, 1], bme=bme)[0]\n    bme.faces.new((v14, v4, v1, v13))\n    bme.faces.new((v15, v3, v4, v14))\n    bme.faces.new((v16, v2, v3, v15))\n    bme.faces.new((v13, v1, v2, v16))\n    if 'GRILL' in type:\n        if brick_size[0] < brick_size[1]:\n            add_grill_details(dimensions, brick_size, thick, scalar, d, v4, v1, v2, v3, v9, v10, v11, v12, bme)\n        else:\n            add_grill_details(dimensions, brick_size, thick, scalar, d, v1, v2, v3, v4, v9, v10, v11, v12, bme)\n    elif detail != 'FLAT':\n        coord1 = -d + Vector((thick.x, thick.y, 0))\n        coord2 = vec_mult(d, scalar) - thick\n        v17, v18, v19, v20, v21, v22, v23, v24 = make_cube(coord1, coord2, [1, 0, 1, 1, 1, 1], flip_normals=True, bme=bme)[1]\n        bme.faces.new((v18, v17, v9, v10))\n        bme.faces.new((v19, v18, v10, v11))\n        bme.faces.new((v20, v19, v11, v12))\n        bme.faces.new((v17, v20, v12, v9))\n        if max(brick_size[:2]) > 2:\n            add_supports(dimensions, dimensions['height'], brick_size, brick_type, circle_verts, type, detail, d, scalar, thick, bme)\n    return bme",
  "line_no": 54,
  "line_no_percent": "82%"
}