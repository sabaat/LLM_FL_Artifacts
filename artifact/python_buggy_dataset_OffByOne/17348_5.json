{
  "instruction": "This code is a Python script that reprojects photospheres. To use it, you need to run the script and provide the following arguments:\n\n--sourceProjection: The type of source projection. Valid values are Equirectangular, Cubemap, SideBySideFisheye.\n--sourceImage: The source image[s]. List multiple images in double quotes like so \"front.png right.png back.png left.png top.png bottom.png\".\n--useBilnear: Whether to use bilinear interpolation when reprojecting. Valid values are true and false.\n--outProjection: The type of output projection. Valid values are Equirectangular, Cubemap, SideBySideFisheye, Fisheye.\n--outImage: The output image[s]. List multiple images in double quotes like so \"front.png right.png back.png left.png top.png bottom.png\".\n--outWidth: The output image[s] width in pixels.\n--outHeight: The output image[s] height in pixels.\n\nThe script will then reproject the photosphere and save the output image[s]. If the output projection is Cubemap, the output images will be saved separately for each face.",
  "buggy_code": "import argparse\nimport vrProjector\n\ndef main():\n    parser = argparse.ArgumentParser(description='Reproject photospheres')\n    parser.add_argument('--sourceProjection', required=True, help='Type of source projection. Valid values are: Equirectangular, Cubemap, SideBySideFisheye')\n    parser.add_argument('--sourceImage', required=True, help='Source image[s]. List multiple images in double quotes like so \"front.png right.png back.png left.png top.png bottom.png\"')\n    parser.add_argument('--useBilnear', required=False, help='Use bilinear interpolation when reprojecting. Valid values are true and false.')\n    parser.add_argument('--outProjection', required=True, help='Type of output projection. Valid values are: Equirectangular, Cubemap, SideBySideFisheye, Fisheye')\n    parser.add_argument('--outImage', required=True, help='output image[s]. List multiple images in double quotes like so \"front.png right.png back.png left.png top.png bottom.png\"')\n    parser.add_argument('--outWidth', required=True, help='output image[s] width in pixels')\n    parser.add_argument('--outHeight', required=True, help='output image[s] height in pixels')\n    args = parser.parse_args()\n    source = None\n    if args.sourceProjection.lower() == 'Equirectangular'.lower():\n        source = vrProjector.EquirectangularProjection()\n        source.loadImage(args.sourceImage)\n    elif args.sourceProjection.lower() == 'SideBySideFisheye'.lower():\n        source = vrProjector.SideBySideFisheyeProjection()\n        source.loadImage(args.sourceImage)\n    elif args.sourceProjection.lower() == 'Cubemap'.lower():\n        source = vrProjector.CubemapProjection()\n        imageList = args.sourceImage.split(' ')\n        source.loadImages(imageList[0], imageList[1], imageList[2], imageList[3], imageList[4], imageList[5])\n    elif args.sourceProjection.lower() == 'Fisheye'.lower():\n        source = vrProjector.FisheyeProjection()\n        source.loadImage(args.sourceImage)\n    else:\n        print('Quitting because unsupported source projection type: ', args.sourceProjection)\n        return\n    if args.useBilnear is not None:\n        if args.useBilnear.lower() == 'true':\n            source.set_use_bilinear(True)\n    out = None\n    if args.outProjection.lower() == 'Equirectangular'.lower():\n        out = vrProjector.EquirectangularProjection()\n        out.initImage(int(args.outWidth), int(args.outHeight))\n    elif args.outProjection.lower() == 'SideBySideFisheye'.lower():\n        out = vrProjector.SideBySideFisheyeProjection()\n        out.initImage(int(args.outWidth), int(args.outHeight))\n    elif args.outProjection.lower() == 'Cubemap'.lower():\n        out = vrProjector.CubemapProjection()\n        out.initImages(int(args.outWidth), int(args.outHeight))\n    elif args.outProjection.lower() == 'Fisheye'.lower():\n        out = vrProjector.FisheyeProjection()\n        out.initImage(int(args.outWidth), int(args.outHeight))\n    else:\n        print('Quitting because unsupported output projection type: ', args.outProjection)\n        return\n    out.reprojectToThis(source)\n    if args.outProjection.lower() == 'Cubemap'.lower():\n        imageList = args.outImage.split(' ')\n        out.saveImages(imageList[0], imageList[1], imageList[2], imageList[3], imageList[3], imageList[5])\n    else:\n        out.saveImage(args.outImage)\nif __name__ == '__main__':\n    main()",
  "line_no": 61,
  "line_no_percent": "107%"
}