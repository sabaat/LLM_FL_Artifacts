{
  "instruction": "Parse Python documentation files and store the information in a MongoDB database. The code reads the documentation files from the directory \"../raw_data/python3/docs.python.org\", parses them using BeautifulSoup, and stores the information in the \"python3\" database in a \"reference\" collection and an \"index\" collection. The \"reference\" collection stores the information for each reference item, and the \"index\" collection stores the information for each subitem of each reference item, with a relevance score based on the position of the subitem in the name of the reference item. The code also includes several functions to check the correctness of the parsing, such as checking that certain reference items and subitems are present and have the correct information.",
  "buggy_code": "from pymongo import MongoClient\nimport os\nimport os.path\nimport re\nimport bs4\nimport itertools\nfrom bs4 import BeautifulSoup\nimport utils\n\nclass ReferenceItem:\n\n    def __init__(self):\n        self.name = ''\n        self.module = ''\n        self.usage = ''\n        self.short = ''\n        self.full = ''\n        self.fullest = ''\n        self.href = ''\n        self.copyright = ''\n        self.subitems = []\n\n    def __str__(self):\n        return 'name: ' + self.name + '\\n' + 'href: ' + self.href + '\\n' + 'module: ' + str(self.module) + '\\n' + 'usage: ' + str(self.usage) + '\\n' + 'short: ' + self.short + '\\n\\n' + 'subitems: ' + str(self.subitems) + 'copyright: ' + self.copyright\n\n    def to_dict(self):\n        return {'name': self.name, 'href': self.href, 'module': self.module, 'usage': self.usage, 'short': self.short, 'full': self.full, 'fullest': self.fullest, 'subitems': self.subitems, 'copyright': self.copyright}\n\ndef hasclass(tag, classes):\n    for cl in tag.get('class', []):\n        if cl in classes:\n            return True\n    return False\n\ndef create_ref(refs, name, module, base_href):\n    if not name in refs:\n        refs[name] = ReferenceItem()\n    refs[name].name = name\n    if module:\n        refs[name].module = 'import ' + module\n    refs[name].href = base_href + '#' + name\n    refs[name].copyright = '\u24d2 Python developers, ' + refs[name].href\n    parent = '.'.join(name.split('.')[:-1])\n    if parent != '' and parent[1] == '@':\n        parent = parent[1:]\n    if not parent in refs:\n        refs[parent] = ReferenceItem()\n    subitem = (name, '')\n    if not subitem in refs[parent].subitems:\n        refs[parent].subitems.append(subitem)\n\ndef can_be_short(text):\n    if re.match('New in version', text):\n        return False\n    if re.match('Source code:', text):\n        return False\n    return True\n\ndef next_tag(tag):\n    while not tag.next_sibling and tag.parent:\n        tag = tag.parent\n    if tag.next_sibling:\n        return tag.next_sibling\n    else:\n        return None\n\ndef parse_file(filename, refs):\n    base_href = 'https://docs.python.org/' + filename[2:]\n    soup = BeautifulSoup(open(filename), 'lxml')\n    module_a = soup.h1.a\n    if not 'headerlink' in module_a.get('class'):\n        module = module_a.string\n    else:\n        module = None\n    currentName = module\n    if currentName:\n        create_ref(refs, currentName, module, base_href)\n    tag = soup.h1.next_sibling\n    while tag is not None:\n        if isinstance(tag, bs4.element.Comment):\n            tag = tag.next_element\n            continue\n        if isinstance(tag, bs4.element.NavigableString):\n            text = tag.strip()\n            if text != '' and currentName:\n                if refs[currentName].short == '':\n                    if can_be_short(text):\n                        refs[currentName].short = text\n                refs[currentName].full += text\n            tag = tag.next_element\n            continue\n        if hasclass(tag, ['sphinxsidebar']):\n            break\n        elif hasclass(tag, ['section', 'seealso']):\n            currentName = None\n            tag = tag.next_element\n        elif hasclass(tag, ['class', 'classmethod', 'method', 'function', 'data', 'exception', 'attribute', 'staticmethod', 'cmdoption']):\n            currentName = tag.dt.get('id')\n            usage = ''.join(tag.dt.strings).strip()\n            if currentName and usage[0] == '@':\n                currentName = '@' + currentName\n            if currentName:\n                create_ref(refs, currentName, module, base_href)\n                refs[currentName].usage = usage[:-1].strip()\n            tag = tag.dd.next_element\n        elif tag.name in ('p', 'pre', 'code', 'li', 'dt', 'dd', 'tr', 'td', 'th'):\n            if tag.name == 'p' and len(tag.contents) == 1 and isinstance(tag.contents[0], bs4.element.Tag) and (tag.contents[0].name == 'strong'):\n                currentName = None\n            if currentName:\n                if refs[currentName].short == '':\n                    text = ''.join(tag.strings)\n                    if can_be_short(text):\n                        refs[currentName].short = ''.join((str(x) for x in tag.contents))\n                refs[currentName].full += str(tag)\n            tag = next_tag(tag)\n            if not tag:\n                break\n        else:\n            tag = tag.next_element\n    return refs\n\ndef insert_ref(ref, reference, index):\n    result = reference.insert_one(ref.to_dict())\n    names = [ref.name]\n    for name in names:\n        split_name = name.strip('@ ').split('.')\n        if len(split_name) > 3:\n            print(split_name, ' --- ', ref.name)\n        for i in range(len(split_name)):\n            perm = [x.lower() for x in split_name[i:]]\n            subname = ' '.join(sorted(perm))\n            doc = {'reference_id': result.inserted_id, 'name': subname, 'relevance': 1 - i / len(split_name), 'full_name': ref.name}\n            index.insert_one(doc)\n\ndef process_file(filename, refs):\n    print('\\n-----------\\n' + filename)\n    print('.', end='', flush=True)\n    parse_file(filename, refs)\n\ndef finalize(refs):\n    for ref_name, ref in refs.items():\n        if ref.name == '':\n            ref.name = ref_name\n        new_subitems = []\n        for item in ref.subitems:\n            new_subitems.append((item[0], utils.first_sentence(refs[item[0]].short)))\n        ref.subitems = new_subitems\nos.chdir('../raw_data/python3/docs.python.org')\nclient = MongoClient()\nclient.drop_database('python3')\ndb = client.python3\nreference = db.reference\nindex = db.index\nindex.create_index('name')\nrefs = {}\nfor directory, subdirs, files in os.walk('.'):\n    for f in files:\n        process_file(os.path.join(directory, f), refs)\nfinalize(refs)\nfor ref in refs.values():\n    if ref.name != '':\n        insert_ref(ref, reference, index)\n\ndef assert_starts_with(text, start):\n    if not text.startswith(start):\n        print('Text `' + text + '` does not start with `' + start + '`')\n        raise AssertionError()\n\ndef assert_ends_with(text, start):\n    if not text.endswith(start):\n        print('Text `' + text + '` does not end with `' + start + '`')\n        raise AssertionError()\n\ndef find_subitem(ref, subitem):\n    found = None\n    for item in ref.subitems:\n        if item[0] == subitem:\n            assert not found\n            found = item\n    return found\n\ndef check_urllib_parse():\n    assert_starts_with(refs['urllib.parse'].short, 'This module')\n    item = find_subitem(refs['urllib'], 'urllib.parse')\n    assert_starts_with(item[1], 'This module')\n    assert_ends_with(item[1], '\u201cbase URL.\u201d')\n\ndef check_unittest_mock():\n    assert_starts_with(refs['unittest.mock'].short, '<a class=\"reference internal\"')\n    item = find_subitem(refs['unittest'], 'unittest.mock')\n    assert_starts_with(item[1], '<a class=\"reference internal\"')\n\ndef check_urllib():\n    assert_ends_with(refs['urllib'].full, 'files</li>')\n\ndef check_re():\n    assert len(refs['re'].subitems) > 0\n    assert 're.match' in refs\n    assert refs['re'].subitems[0][0] == 're.compile'\n    assert_ends_with(refs['re'].subitems[0][1], 'described below.')\n    assert len(refs['re'].subitems[0][1].strip()) > 0\n\ndef check_unittest():\n    assert_ends_with(refs['unittest'].full, 'executing the tests.</dd>')\n\ndef check_unittest_skip():\n    assert '@unittest.skip' in refs\n    assert find_subitem(refs['unittest'], '@unittest.skip')\n\ndef check_utcnow():\n    assert 'datetime.datetime.utcnow' in refs\n    assert find_subitem(refs['datetime.datetime'], 'datetime.datetime.utcnow')\n\ndef check_pprint():\n    assert 'pprint.pprint' in refs\n    assert_ends_with(refs['pprint.pprint'].full, '</pre>')\n\ndef check_itertools():\n    assert_ends_with(refs['itertools'].full, 'vector2))</span></code>.</p>')\n\ndef check_ctypes():\n    assert 'ctypes.Array._length_' in refs\n    assert find_subitem(refs['ctypes.Array'], 'ctypes.Array._length_')\n\ndef check_paragraph_signs():\n    found = False\n    for ref in refs:\n        if '\u00b6' in refs[ref].full:\n            print('\u00b6 found in ', ref)\n            found = True\n    assert not found\ncheck_paragraph_signs()\ncheck_ctypes()\ncheck_itertools()\ncheck_re()\ncheck_pprint()\ncheck_utcnow()\ncheck_urllib_parse()\ncheck_unittest_mock()\ncheck_urllib()\ncheck_unittest()\ncheck_unittest_skip()",
  "line_no": 59,
  "line_no_percent": "24%"
}