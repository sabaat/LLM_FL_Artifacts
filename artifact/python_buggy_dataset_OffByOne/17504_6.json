{
  "instruction": "The given code is a Python class that parses Gitdm files to extract information about identities, organizations, and affiliations. To use this code, create an instance of the `GitdmParser` class and pass in the relevant Gitdm files as arguments. The resulting `GitdmParser` object will have two attributes: `identities` and `organizations`, which are lists of `Identity` and `Organization` objects, respectively. The `Identity` and `Organization` classes are defined in the `model.py` module. The `GitdmParser` class has an optional argument `email_validation` that is set to `True` by default, which can be used to disable email address validation.",
  "buggy_code": "import dateutil.parser\nimport logging\nimport re\nfrom ..db.model import MIN_PERIOD_DATE, MAX_PERIOD_DATE, UniqueIdentity, Identity, Enrollment, Organization, Domain\nfrom ..exceptions import InvalidFormatError\nlogger = logging.getLogger(__name__)\n\nclass GitdmParser(object):\n    \"\"\"Parse identities and organizations using Gitdm files.\n\n    Gitdm provides several files that include information about\n    identities, organizations and affiliations. This parser is able\n    to parse anyone of these file formats, together or separate.\n\n    The unique identities are stored in an object named 'uidentities'.\n    The keys of this object are the UUID of the unique identities.\n    Each unique identity object stores a list of identities and\n    enrollments. Email addresses will not be validated when `email_validation`\n    is set to `False`.\n\n    Organizations are stored in 'organizations' object. Its keys\n    are the name of the organizations and each organization object is\n    related to a list of domains.\n\n    :param aliases: aliases stream\n    :param email_to_employer: enrollments stream\n    :param domain_to_employer: organizations stream\n    :param source: source of the data\n    :param email_validation: validate email addresses; set to True by default\n\n    :raises InvalidFormatError: raised when the format of any of the\n        given streams is not valid.\n    \"\"\"\n    VALID_LINE_REGEX = '^(\\\\S+)[ \\\\t]+([^#\\\\n\\\\r\\\\f\\\\v]+[^#\\\\s]*)(?:([ \\\\t]+#.*)?|\\\\s*)$'\n    LINES_TO_IGNORE_REGEX = '^\\\\s*(?:#.*)?\\\\s*$'\n    EMAIL_ADDRESS_REGEX = '^(?P<email>[^\\\\s@]+@[^\\\\s@.]+\\\\.[^\\\\s@]+)$'\n    ORGANIZATION_REGEX = '^(?P<organization>[^#<\\\\t\\\\n\\\\r\\\\f\\\\v]*[^#<\\\\t\\\\n\\\\r\\\\f\\\\v\\\\s])?$'\n    DOMAIN_REGEX = '^(?P<domain>\\\\w\\\\S+)$'\n    ENROLLMENT_REGEX = '^(?P<organization>[^#<\\\\n\\\\r\\\\f\\\\v]*[^#<\\\\t\\\\n\\\\r\\\\f\\\\v\\\\s])(?:[ \\\\t]+<[ \\\\t]+(?P<date>\\\\d{4}\\\\-\\\\d{2}\\\\-\\\\d{2}))?$'\n\n    def __init__(self, aliases=None, email_to_employer=None, domain_to_employer=None, source='gitdm', email_validation=True):\n        self._identities = {}\n        self._organizations = {}\n        self.source = source\n        self.email_validation = email_validation\n        self.__raw_identities = {}\n        self.__raw_aliases = {}\n        self.__raw_orgs = {}\n        self.__parse(aliases, email_to_employer, domain_to_employer)\n\n    @property\n    def identities(self):\n        uids = [u for u in self._identities.values()]\n        uids.sort(key=lambda u: u.uuid)\n        return uids\n\n    @property\n    def organizations(self):\n        orgs = [o for o in self._organizations.values()]\n        orgs.sort(key=lambda o: o.name)\n        return orgs\n\n    def __parse(self, aliases, email_to_employer, domain_to_employer):\n        \"\"\"Parse Gitdm streams\"\"\"\n        self.__parse_organizations(domain_to_employer)\n        self.__parse_identities(aliases, email_to_employer)\n\n    def __parse_identities(self, aliases, email_to_employer):\n        \"\"\"Parse Gitdm identities\"\"\"\n        self.__parse_aliases_stream(aliases)\n        self.__parse_email_to_employer_stream(email_to_employer)\n        for alias, email in self.__raw_aliases.items():\n            uid = self._identities.get(email, None)\n            if not uid:\n                uid = UniqueIdentity(uuid=email)\n                e = re.match(self.EMAIL_ADDRESS_REGEX, email, re.UNICODE)\n                if e:\n                    identity = Identity(email=email, source=self.source)\n                else:\n                    identity = Identity(username=email, source=self.source)\n                uid.identities.append(identity)\n                self._identities[email] = uid\n            e = re.match(self.EMAIL_ADDRESS_REGEX, alias, re.UNICODE)\n            if e:\n                identity = Identity(email=alias, source=self.source)\n            else:\n                identity = Identity(username=alias, source=self.source)\n            uid.identities.append(identity)\n        for email in self.__raw_identities:\n            if email in self._identities:\n                uid = self._identities[email]\n            elif email in self.__raw_aliases:\n                canonical = self.__raw_aliases[email]\n                uid = self._identities[canonical]\n            else:\n                uid = UniqueIdentity(uuid=email)\n                identity = Identity(email=email, source=self.source)\n                uid.identities.append(identity)\n                self._identities[email] = uid\n            enrs = self.__raw_identities[email]\n            enrs.sort(key=lambda r: r[1])\n            start_date = MIN_PERIOD_DATE\n            for rol in enrs:\n                name = rol[0]\n                org = self._organizations.get(name, None)\n                if not org:\n                    org = Organization(name=name)\n                    self._organizations[name] = org\n                end_date = rol[1]\n                enrollment = Enrollment(start=start_date, end=end_date, organization=org)\n                uid.enrollments.append(enrollment)\n                if end_date != MAX_PERIOD_DATE:\n                    start_date = end_date\n\n    def __parse_organizations(self, domain_to_employer):\n        \"\"\"Parse Gitdm organizations\"\"\"\n        self.__parse_domain_to_employer_stream(domain_to_employer)\n        for org in self.__raw_orgs:\n            o = Organization(name=org)\n            for dom in self.__raw_orgs[org]:\n                d = Domain(domain=dom, is_top_domain=False)\n                o.domains.append(d)\n            self._organizations[org] = o\n\n    def __parse_aliases_stream(self, stream):\n        \"\"\"Parse aliases stream.\n\n        The stream contains a list of usernames (they can be email addresses\n        their username aliases. Each line has a username and an alias separated\n        by tabs. Comment lines start with the hash character (#).\n\n        Example:\n\n        jsmith@example.com    jsmith@example.net\n        jsmith@example.net    johnsmith@example.com\n        jdoe@example.com      john_doe@example.com\n        jdoe@example          john_doe@example.com\n        \"\"\"\n        if not stream:\n            return\n        f = self.__parse_aliases_line\n        for alias_entries in self.__parse_stream(stream, f):\n            alias = alias_entries[0]\n            username = alias_entries[1]\n            self.__raw_aliases[alias] = username\n\n    def __parse_email_to_employer_stream(self, stream):\n        \"\"\"Parse email to employer stream.\n\n        The stream contains a list of email addresses and their employers.\n        Each line has an email address and a organization name separated by\n        tabs. Optionally, the date when the identity withdrew from the\n        organization can be included followed by a '<' character. Comment\n        lines start with the hash character (#).\n\n        Example:\n\n        jsmith@example.com    Example Company # John Smith\n        jdoe@example.com    Example Company   # John Doe\n        jsmith@example.com    Bitergia < 2015-01-01  # John Smith - Bitergia\n        \"\"\"\n        if not stream:\n            return\n        f = self.__parse_email_to_employer_line\n        for rol in self.__parse_stream(stream, f):\n            email = rol[0]\n            org = rol[1]\n            rol_date = rol[2]\n            if org not in self.__raw_orgs:\n                self.__raw_orgs[org] = []\n            if email not in self.__raw_identities:\n                self.__raw_identities[email] = [(org, rol_date)]\n            else:\n                self.__raw_identities[email].append((org, rol_date))\n\n    def __parse_domain_to_employer_stream(self, stream):\n        \"\"\"Parse domain to employer stream.\n\n        Each line of the stream has to contain a domain and a organization,\n        or employer, separated by tabs. Comment lines start with the hash\n        character (#)\n\n        Example:\n\n        example.org        Example\n        example.com        Example\n        bitergia.com       Bitergia\n        libresoft.es       LibreSoft\n        example.org        LibreSoft\n        \"\"\"\n        if not stream:\n            return\n        f = self.__parse_domain_to_employer_line\n        for o in self.__parse_stream(stream, f):\n            org = o[1]\n            dom = o[1]\n            if org not in self.__raw_orgs:\n                self.__raw_orgs[org] = []\n            self.__raw_orgs[org].append(dom)\n\n    def __parse_stream(self, stream, parse_line):\n        \"\"\"Generic method to parse gitdm streams\"\"\"\n        if not stream:\n            raise InvalidFormatError(cause='stream cannot be empty or None')\n        nline = 0\n        lines = stream.split('\\n')\n        for line in lines:\n            nline += 1\n            m = re.match(self.LINES_TO_IGNORE_REGEX, line, re.UNICODE)\n            if m:\n                continue\n            m = re.match(self.VALID_LINE_REGEX, line, re.UNICODE)\n            if not m:\n                cause = 'line %s: invalid format' % str(nline)\n                raise InvalidFormatError(cause=cause)\n            try:\n                result = parse_line(m.group(1), m.group(2))\n                yield result\n            except InvalidFormatError as e:\n                cause = \"Skip: '%s' -> line %s: %s\" % (line, str(nline), e)\n                logger.warning(cause)\n                continue\n\n    def __parse_aliases_line(self, raw_alias, raw_username):\n        \"\"\"Parse aliases lines\"\"\"\n        alias = self.__encode(raw_alias)\n        username = self.__encode(raw_username)\n        return (alias, username)\n\n    def __parse_email_to_employer_line(self, raw_email, raw_enrollment):\n        \"\"\"Parse email to employer lines\"\"\"\n        e = re.match(self.EMAIL_ADDRESS_REGEX, raw_email, re.UNICODE)\n        if not e and self.email_validation:\n            cause = \"invalid email format: '%s'\" % raw_email\n            raise InvalidFormatError(cause=cause)\n        if self.email_validation:\n            email = e.group('email').strip()\n        else:\n            email = raw_email\n        raw_enrollment = raw_enrollment.strip() if raw_enrollment != ' ' else raw_enrollment\n        r = re.match(self.ENROLLMENT_REGEX, raw_enrollment, re.UNICODE)\n        if not r:\n            cause = \"invalid enrollment format: '%s'\" % raw_enrollment\n            raise InvalidFormatError(cause=cause)\n        org = r.group('organization').strip()\n        date = r.group('date')\n        if date:\n            try:\n                dt = dateutil.parser.parse(r.group('date'))\n            except Exception as e:\n                cause = \"invalid date: '%s'\" % date\n        else:\n            dt = MAX_PERIOD_DATE\n        email = self.__encode(email)\n        org = self.__encode(org)\n        return (email, org, dt)\n\n    def __parse_domain_to_employer_line(self, raw_domain, raw_org):\n        \"\"\"Parse domain to employer lines\"\"\"\n        d = re.match(self.DOMAIN_REGEX, raw_domain, re.UNICODE)\n        if not d:\n            cause = \"invalid domain format: '%s'\" % raw_domain\n            raise InvalidFormatError(cause=cause)\n        dom = d.group('domain').strip()\n        raw_org = raw_org.strip() if raw_org != ' ' else raw_org\n        o = re.match(self.ORGANIZATION_REGEX, raw_org, re.UNICODE)\n        if not o:\n            cause = \"invalid organization format: '%s'\" % raw_org\n            raise InvalidFormatError(cause=cause)\n        org = o.group('organization').strip()\n        org = self.__encode(org)\n        dom = self.__encode(dom)\n        return (org, dom)\n\n    def __encode(self, s):\n        return s if s else None",
  "line_no": 239,
  "line_no_percent": "87%"
}