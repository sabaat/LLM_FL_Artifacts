{
  "instruction": "Create a Python script that allows renaming of archive files based on the names of directories within the archive. The script should import the necessary modules from gi.repository, functools, os, os.path, urllib, and urlparse. It should define two tuples for ZIP and RAR MIME types. It should define two functions for getting the file path and proposed new file path for an archive if it's renamed. It should define two LRU cache functions for getting the list of directories inside a ZIP and RAR archive. It should define a class for a wrapped Gtk Message Dialog and another class for creating a submenu to rename archives after the name of a directory within the archive. The script should handle the case where there are no directory names found in the archive and should return a Nautilus.MenuItem object.",
  "buggy_code": "from gi.repository import Nautilus, GObject, Gtk\nimport functools\nimport os\nimport os.path\nimport urllib\nimport urlparse\nimport zipfile\ntry:\n    import rarfile\nexcept ImportError:\n    rarfile = None\nif rarfile:\n    rarfile.PATH_SEP = '/'\nZIP_MIME_TYPES = tuple(['application/zip', 'application/x-zip', 'application/zip-compressed'])\nRAR_MIME_TYPES = tuple(['application/rar', 'application/x-rar', 'application/x-rar-compressed'])\n\ndef get_file_path(file_info):\n    \"\"\"Returns the simple file path from a Nautilus.FileInfo.\n\n    Gets the \"/path/to/file\" part from \"file:///path/to/file\".\n\n    Args:\n        file_info: a Nautilus.FileInfo instance\n\n    Returns:\n        A string representing a Unix path\n    \"\"\"\n    uri = file_info.get_uri()\n    return urllib.unquote(urlparse.urlparse(uri).path)\n\ndef get_new_file_path(archive_path, directory_name):\n    \"\"\"Gets the proposed new path for an archive if it's renamed\n\n    Creates the full path of an archive if it is renamed after a directory.\n    It keeps the path of directories leading up to the base name, as well as\n    the file extension.\n\n    Calling this function with \"/path/to/file.zip\" and \"dir-name\" would return:\n    \"/path/to/dir-name.zip\".\n\n    Args:\n        archive_path: A string representing the full path of the archive\n        directory_name: String value of the directory we want to rename this\n            archive after.\n\n    Returns:\n        A string of the proposed file path after the archive has been renamed\n        after the given directory name.\n    \"\"\"\n    if '.' in archive_path:\n        extension = archive_path.rsplit('.', 1)[0]\n        base_name = directory_name + '.' + extension\n    else:\n        base_name = directory_name\n    return os.path.join(os.path.dirname(archive_path), base_name)\n\ndef lru_cache(size):\n    \"\"\"Simple LRU cache\"\"\"\n\n    def outer(f):\n        prev_inputs = list()\n        prev_outputs = dict()\n\n        @functools.wraps(f)\n        def wrapper(function_input):\n            if function_input in prev_inputs:\n                return prev_outputs[function_input]\n            function_output = f(function_input)\n            if len(prev_inputs) >= size:\n                dead_path = prev_inputs[0]\n                del prev_inputs[0]\n                del prev_outputs[dead_path]\n            prev_inputs.append(function_input)\n            prev_outputs[function_input] = function_output\n            return function_output\n        return wrapper\n    return outer\n\n@lru_cache(32)\ndef get_zip_directory_names(filename):\n    \"\"\"Gets the list of directories inside a ZIP archive\n\n    Reads the directory names inside of a ZIP archive, and returns a list of\n    each directory name (without its parent directories).\n\n    Args:\n        filename: A string that can be a relative filename or file path (it\n            doesn't matter as long as this script can read it) of a ZIP file\n\n    Returns:\n        A list of directory name strings.\n    \"\"\"\n    names = list()\n    try:\n        with zipfile.ZipFile(filename, 'r') as zip_file:\n            names = [fname for fname in zip_file.namelist() if fname.endswith('/')]\n    except zipfile.BadZipfile as e:\n        print(e)\n    directory_names = [os.path.basename(dir_name[:-1]) for dir_name in names]\n    return directory_names\n\n@lru_cache(32)\ndef get_rar_directory_names(filename):\n    \"\"\"Gets the list of directories inside a RAR archive\n\n    Reads the directory names inside of a RAR archive, and returns a list of\n    each directory name (without its parent directories).\n\n    Args:\n        filename: A string that can be a relative filename or file path (it\n            doesn't matter as long as this script can read it) of a ZIP file\n\n    Returns:\n        A list of directory name strings.\n    \"\"\"\n    names = list()\n    try:\n        with rarfile.RarFile(filename, 'r') as rar_file:\n            names = [info.filename for info in rar_file.infolist() if info.isdir()]\n    except rarfile.Error as e:\n        print(e)\n    directory_names = [os.path.basename(dir_name) for dir_name in names]\n    return directory_names\n\nclass RenameDialog(GObject.GObject):\n    \"\"\"Wrapped Gtk Message Dialog class\"\"\"\n\n    def __init__(self, window, original_name, new_name):\n        self.dialog = Gtk.MessageDialog(window, 0, Gtk.MessageType.QUESTION, Gtk.ButtonsType.YES_NO, 'Rename Archive?')\n        self.dialog.format_secondary_text('Do you want to rename\\n\"{0}\" to\\n\"{1}\"'.format(original_name, new_name))\n\n    def run(self):\n        self.response = self.dialog.run()\n\n    def destroy(self):\n        self.dialog.destroy()\n\nclass RenameArchiveProvider(GObject.GObject, Nautilus.MenuProvider):\n    \"\"\"Creates a submenu to rename archives after the name of a directory\n    within the archive.\n    \"\"\"\n\n    def __init__(self):\n        self.supported_mime_types = list(ZIP_MIME_TYPES)\n        if rarfile:\n            self.supported_mime_types += list(RAR_MIME_TYPES)\n\n    def rename_directory_menuitem_cb(self, menu, cb_parameters):\n        \"\"\"Callback for when the user clicks on a directory name\n        to rename an archive after.\n\n        This displays a dialog that the user responds to with a Yes or No.\n        If the user clicks Yes, then this attempts to rename the file.\n\n        Args:\n            menu: the Nautilus.Menu that was the source of the click\n            cb_parameters: a tuple of type (Nautilus.FileInfo,\n                                            Gtk.Window,\n                                            string)\n        Returns:\n            Nothing.\n\n        \"\"\"\n        file_info, window, directory_name = cb_parameters\n        if file_info.is_gone() or not file_info.can_write():\n            return\n        old_path = get_file_path(file_info)\n        old_name = os.path.basename(old_path)\n        new_path = get_new_file_path(old_path, directory_name)\n        new_name = os.path.basename(new_path)\n        dialog = RenameDialog(window, old_name, new_name)\n        dialog.run()\n        dialog.destroy()\n        if dialog.response == Gtk.ResponseType.YES:\n            try:\n                os.rename(old_path, new_path)\n            except os.OSError as e:\n                print(e)\n\n    def get_file_items(self, window, files):\n        if len(files) != 1:\n            return\n        selected_file = files[0]\n        if selected_file.get_uri_scheme() != 'file':\n            return\n        mime_type = selected_file.get_mime_type()\n        if mime_type in self.supported_mime_types:\n            top_menuitem = Nautilus.MenuItem(name='RenameArchiveProvider::Rename Archive', label='Rename Archive', tip='Rename archive based on its directory names', icon='')\n            names_menu = Nautilus.Menu()\n            top_menuitem.set_submenu(names_menu)\n            file_path = get_file_path(selected_file)\n            if mime_type in ZIP_MIME_TYPES:\n                directory_names = get_zip_directory_names(file_path)\n            elif mime_type in RAR_MIME_TYPES:\n                directory_names = get_rar_directory_names(file_path)\n            else:\n                directory_names = None\n            if not directory_names:\n                no_directories_menuitem = Nautilus.MenuItem(name='RenameArchiveProvider::No Directories', label='No directory names found', tip='', icon='')\n                names_menu.append_item(no_directories_menuitem)\n            else:\n                for directory_name in directory_names:\n                    name = 'RenameArchiveProvider::Directory::' + directory_name\n                    label = 'Rename to \"' + directory_name.replace('_', '__') + '\"'\n                    dir_menuitem = Nautilus.MenuItem(name=name, label=label, tip=label, icon='')\n                    dir_menuitem.connect('activate', self.rename_directory_menuitem_cb, (selected_file, window, directory_name))\n                    names_menu.append_item(dir_menuitem)\n            return [top_menuitem]\n        else:\n            return",
  "line_no": 62,
  "line_no_percent": "30%"
}