{
  "instruction": "This code is a Python script that renders a stereo scene using OpenGL. To use it, follow these steps:\n\n1. Install Python and OpenGL.\n2. Run the script in a Python environment.\n3. Wait for the scene to render in a new window.\n4. Use the arrow keys to move the objects in the scene.\n5. Press the ESC key to quit the program.",
  "buggy_code": "\"\"\"Test for an openGL based stereo renderer - test binocular rendering to a single window\n\nDavid Dunn\nFeb 2017 - created\n\nwww.qenops.com\n\n\"\"\"\n__author__ = 'David Dunn'\n__version__ = '1.0'\nimport OpenGL\nOpenGL.ERROR_CHECKING = False\nOpenGL.ERROR_LOGGING = False\nimport OpenGL.GL as GL\nimport math, os\nimport numpy as np\nimport dGraph as dg\nimport dGraph.ui as ui\nimport dGraph.cameras as dgc\nimport dGraph.shapes as dgs\nimport dGraph.materials as dgm\nimport dGraph.shaders as dgshdr\nimport dGraph.config as config\nimport dGraph.util.imageManip as im\nimport time\nMODELDIR = '%s/data' % os.path.dirname(__file__)\nWINDOWS = [{'name': 'Test 5', 'location': (0, 0), 'size': (1600, 800), 'center': (400, 400), 'refresh_rate': 60, 'px_size_mm': 0.09766, 'distance_cm': 20}]\n\ndef loadScene(renderStack, file=None, cross=False):\n    \"\"\"Load or create our sceneGraph\"\"\"\n    scene = dg.SceneGraph(file)\n    stereoCam = dgc.StereoCamera('front', scene)\n    stereoCam.setResolution((renderStack.width / 2, renderStack.height))\n    stereoCam.setTranslate(0.0, -0.06, 0.0)\n    stereoCam.setRotate(20.0, 0.0, 0.0)\n    stereoCam.setFOV(50.0)\n    stereoCam.IPD = 0.062\n    crosses = [np.array((-0.2, -0.2, -10.0)), np.array((-0.2, 0.0, -10.0)), np.array((-0.2, 0.2, -10.0)), np.array((0.0, -0.2, -10.0)), np.array((0.0, 0.0, -10.0)), np.array((0.0, 0.2, -10.0)), np.array((0.2, -0.2, -10.0)), np.array((0.2, 0.0, -10.0)), np.array((0.2, 0.2, -10.0))]\n    for idx, position in enumerate(crosses):\n        cross = dgs.PolySurface('cross%s' % idx, scene, file='%s/cross.obj' % MODELDIR)\n        cross.setScale(0.01, 0.01, 0.01)\n        cross.translate = position\n        renderStack.objects[cross.name] = cross\n        print(1, idx / 3.0 / 3.0 + 1 / 3.0, idx % 3 / 3.0 + 1 / 3.0)\n        material = dgm.Material('material%s' % idx, ambient=(1, idx / 3.0 / 3.0 + 1 / 3.0, idx % 3 / 3.0 + 1 / 3.0), amb_coeff=0.5)\n        cross.setMaterial(material)\n    renderStack.cameras = [stereoCam]\n    renderStack.append(stereoCam)\n    return True\n\ndef animateScene(renderStack, frame):\n    \"\"\" Create motion in our scene \"\"\"\n    y = 1\n    x = math.cos(frame * math.pi / 60)\n    for obj in renderStack.objects.itervalues():\n        obj.rotate += np.array((x, y, 0.0))\n\ndef addInput():\n    for rs in renderStack:\n        ui.add_key_callback(arrowKey, ui.KEY_RIGHT, renderStack=rs, direction=3)\n        ui.add_key_callback(arrowKey, ui.KEY_LEFT, renderStack=rs, direction=2)\n        ui.add_key_callback(arrowKey, ui.KEY_UP, renderStack=rs, direction=1)\n        ui.add_key_callback(arrowKey, ui.KEY_DOWN, renderStack=rs, direction=0)\n\ndef arrowKey(window, renderStack, direction):\n    for o in renderStack.objects:\n        if direction == 3:\n            o.rotate(np.array((0.0, 5.0, 0.0)))\n        elif direction == 2:\n            o.rotate(-np.array((0.0, 5.0, 0.0)))\n        elif direction == 1:\n            o.translate(np.array((0.0, 0.01, 0.0)))\n        else:\n            o.translate(-np.array((0.0, 0.01, 0.0)))\n\ndef drawScene(renderStack):\n    \"\"\" Render the stack \"\"\"\n    myStack = list(renderStack)\n    temp = myStack.pop()\n    temp.render(renderStack.width, renderStack.height, myStack)\n\ndef setup():\n    winData = WINDOWS[0]\n    renderStack = ui.RenderStack()\n    renderStack.display = ui.Display(resolution=winData['size'])\n    ui.init()\n    mainWindow = renderStack.addWindow(ui.open_window(winData['name'], winData['location'][0], winData['location'][0], renderStack.display.width, renderStack.display.height))\n    if not mainWindow:\n        ui.terminate()\n        exit(1)\n    ui.make_context_current(mainWindow)\n    ui.add_key_callback(ui.close_window, ui.KEY_ESCAPE)\n    scenes = [loadScene(renderStack) for renderStack in renderStacks]\n    for rs in renderStacks:\n        rs.graphicsCardInit()\n    return (renderStacks, scenes, windows)\n\ndef runLoop(renderStack, mainWindow):\n    print('Hit ESC key to quit.')\n    frame = 0\n    start = time.time()\n    while not ui.window_should_close(mainWindow):\n        ui.make_context_current(mainWindow)\n        drawScene(renderStack)\n        now = time.time()\n        time.sleep(max((frame + 1) / config.maxFPS + start - now, 0))\n        ui.swap_buffers(mainWindow)\n        ui.poll_events()\n        frame += 1\n    ui.terminate()\n    exit(0)\nif __name__ == '__main__':\n    renderStack, scene, windows = setup()\n    addInput()\n    runLoop(renderStack, windows[0])",
  "line_no": 108,
  "line_no_percent": "94%"
}