{
  "instruction": "This code is a Python module for image manipulation. To use it, import the module and create an instance of the ImageHelper class. The module provides several methods for image manipulation, including comparison, loading, cropping, bordering, resizing, colorizing, and saving. To manipulate an image, call the manipulate method and pass in the source image file path and any desired options. The method will return True if the image was successfully manipulated and saved, False if there was an error, or the manipulated image if no save destination was specified.",
  "buggy_code": "import tempfile\nfrom dp_tornado.engine.helper import Helper as dpHelper\n\nclass ImageHelper(dpHelper):\n\n    def compare(self, i1, i2, error=0):\n        i1 = self.load(i1)\n        i2 = self.load(i2)\n        if not i1 or not i2:\n            return None\n        s1 = i1.size\n        s2 = i2.size\n        if s1[0] != s2[0] or s2[1] != s2[1]:\n            print('size ne,', s1, s2)\n            return False\n        i1 = i1.load()\n        i2 = i2.load()\n        for i in range(s1[0]):\n            for j in range(s1[0]):\n                if i1[i, j] != i2[i, j]:\n                    if error:\n                        for k in range(len(i1[i, j])):\n                            if abs(i1[i, j][k] - i2[i, j][k]) > error:\n                                print('pixel ne,', i1[i, j], i2[i, j], abs(i1[i, j][k] - i2[i, j][k]), error)\n                                return False\n                    else:\n                        return False\n        return True\n\n    def _driver(self, options=None, **kwargs):\n        if not options and kwargs:\n            options = kwargs\n        if options and 'driver' in options and (options['driver'] == 'wand'):\n            return self.helper.io.image.driver.wand\n        return self.helper.io.image.driver.pillow\n\n    def load(self, src, options=None, **kwargs):\n        if not options and kwargs:\n            options = kwargs\n        tmp = None\n        drivers = []\n        pillow_image = self.helper.io.image.driver.pillow.Image\n        wand_image = self.helper.io.image.driver.wand.Image\n        if pillow_image:\n            drivers.append(pillow_image)\n        if wand_image:\n            drivers.append(wand_image)\n        try:\n            if isinstance(src, tuple(drivers)):\n                return src\n            elif self.helper.web.url.validate(src):\n                code, res = self.helper.web.http.get.raw(src)\n                if code != 200:\n                    raise Exception('The specified image url is invalid.')\n                tmp = tempfile.NamedTemporaryFile(delete=False)\n                tmp.write(res)\n                tmp.close()\n                tmp = tmp.name\n            else:\n                tmp = None\n            if not tmp and (not src):\n                raise Exception('The specified image is invalid.')\n            img = self._driver(options=options).load(tmp if tmp else src)\n            if not img:\n                raise Exception('The specified image is invalid.')\n            return img\n        except Exception as e:\n            self.logging.exception(e)\n            return False\n        finally:\n            if tmp:\n                self.helper.io.file.remove(tmp)\n\n    def execute(self, src, fn, options=None, **kwargs):\n        if not options and kwargs:\n            options = kwargs\n        img = self.load(src, options=options)\n        if not img:\n            return False\n        try:\n            return fn(img, options)\n        except Exception as e:\n            self.logging.exception(e)\n            return False\n\n    def size(self, src, options=None, **o_kwargs):\n        if not options and o_kwargs:\n            options = o_kwargs\n\n        def fn(img, kwargs):\n            if not img:\n                return (-1, -1)\n            return (img.width, img.height)\n        return self.execute(src, fn, options=options)\n\n    def crop(self, src, options=None, **o_kwargs):\n        if not options and o_kwargs:\n            options = o_kwargs\n\n        def fn(img, kwargs):\n            crop = kwargs['crop'] if 'crop' in kwargs else None\n            if not crop:\n                return img\n            e_top = 0\n            e_left = 0\n            e_right = 0\n            e_bottom = 0\n            if self.helper.misc.type.check.string(crop):\n                crop = crop.split(',')\n                crop = [int(e.strip()) for e in crop]\n            if self.helper.misc.type.check.numeric(crop):\n                e_top = e_left = e_right = e_bottom = crop\n            elif isinstance(crop, (tuple, list)):\n                if len(crop) == 1:\n                    e_top = e_left = e_right = e_bottom = crop[0]\n                elif len(crop) == 2:\n                    e_top = e_bottom = crop[0]\n                    e_left = e_right = crop[1]\n                elif len(crop) == 4:\n                    e_top = crop[0]\n                    e_right = crop[1]\n                    e_bottom = crop[2]\n                    e_left = crop[3]\n            img = self._driver(options=kwargs).crop(img, e_left, e_top, img.size[0] - e_right, img.size[1] - e_bottom)\n            return img\n        return self.execute(src, fn, options=options)\n\n    def border(self, src, options=None, **o_kwargs):\n        if not options and o_kwargs:\n            options = o_kwargs\n\n        def fn(img, kwargs):\n            border = int(kwargs['border']) if 'border' in kwargs else 0\n            border_color = kwargs['border_color'] if 'border_color' in kwargs else '#000000'\n            if not border:\n                return img\n            if '_org' in kwargs and 'radius' in kwargs and kwargs['radius']:\n                return img\n            img = self._driver(options=kwargs).border(img, border, border_color)\n            return img\n        return self.execute(src, fn, options=options)\n\n    def radius(self, src, options=None, **o_kwargs):\n        if not options and o_kwargs:\n            options = o_kwargs\n\n        def fn(img, kwargs):\n            radius = int(kwargs['radius'] or 0) if 'radius' in kwargs else None\n            border = int(kwargs['border']) if 'border' in kwargs else 0\n            border_color = kwargs['border_color'] if 'border_color' in kwargs else '#000000'\n            if not radius:\n                return img\n            elif '__radius_processed__' in img.__dict__:\n                return img\n            img = self._driver(options=kwargs).radius(img, radius, border, border_color)\n            img.__dict__['__radius_processed__'] = True\n            return img\n        return self.execute(src, fn, options=options)\n\n    def colorize(self, src, options=None, **o_kwargs):\n        if not options and o_kwargs:\n            options = o_kwargs\n\n        def fn(img, kwargs):\n            colorize = kwargs['colorize'] if 'colorize' in kwargs else None\n            if not colorize:\n                return img\n            img = self._driver(options=kwargs).colorize(img, colorize)\n            return img\n        return self.execute(src, fn, options=options)\n\n    def resize(self, src, options=None, **o_kwargs):\n        if not options and o_kwargs:\n            options = o_kwargs\n\n        def fn(img, kwargs):\n            size = kwargs['size'] if 'size' in kwargs else None\n            mode = kwargs['mode'] if 'mode' in kwargs else None\n            scale = int(kwargs['scale']) if 'scale' in kwargs else 1\n            limit = True if 'limit' in kwargs and kwargs['limit'] else False\n            border = int(kwargs['border']) if 'border' in kwargs else 0\n            if not size:\n                return img\n            width_new, height_new = size\n            width_origin, height_origin = img.size\n            if scale > 1:\n                if limit:\n                    scale_max_width = float(width_origin) / float(width_new)\n                    scale_max_height = float(height_origin) / float(height_new)\n                    scale_max = min(scale, scale_max_width, scale_max_height)\n                else:\n                    scale_max = scale\n                if scale_max > 1:\n                    width_new = int(width_new * scale_max)\n                    height_new = int(height_new * scale_max)\n            if not width_new:\n                width_new = width_origin * height_new / height_origin\n                mode = self.helper.io.image.mode.resize\n            if not height_new:\n                height_new = height_origin * width_new / width_origin\n                mode = self.helper.io.image.mode.resize\n            if border:\n                width_new -= border * 2\n                height_new -= border * 2\n            if not mode:\n                mode = self.helper.io.image.mode.resize\n            if mode not in self.helper.io.image.mode.modes:\n                raise Exception('The specified mode is not supported.')\n            seqs = []\n            for i, im in self._driver(options=kwargs).iter_seqs(img, kwargs):\n                if mode == self.helper.io.image.mode.center:\n                    im = self._driver(options=kwargs).resize(im, width_new, height_new, kwargs)\n                elif mode == self.helper.io.image.mode.fill:\n                    ratio_origin = float(width_origin) / float(height_origin)\n                    ratio_new = float(width_new) / float(height_new)\n                    if ratio_origin > ratio_new:\n                        tw = int(round(height_new * ratio_origin))\n                        im = self._driver(options=kwargs).resize(im, tw, height_new)\n                        left = int(round((tw - width_new) / 2.0))\n                        im = self._driver(options=kwargs).crop(im, left, 0, left + width_new, height_new)\n                    elif ratio_origin < ratio_new:\n                        th = int(round(width_new / ratio_origin))\n                        im = self._driver(options=kwargs).resize(im, width_new, th)\n                        top = int(round((th - height_new) / 2.0))\n                        im = self._driver(options=kwargs).crop(im, 0, top, width_new, top + height_new)\n                    else:\n                        im = self._driver(options=kwargs).resize(im, width_new, height_new)\n                elif mode == self.helper.io.image.mode.resize:\n                    if width_new > width_origin or height_new > height_origin:\n                        width_new = width_origin\n                        height_new = height_origin\n                    im = self._driver(options=kwargs).resize(im, width_new, height_new)\n                seqs.append(im)\n            img = seqs[0]\n            seqs.remove(img)\n            img.__dict__['__frames__'] = seqs\n            return img\n        return self.execute(src, fn, options=options)\n\n    def save(self, src, options=None, **o_kwargs):\n        if not options and o_kwargs:\n            options = o_kwargs\n\n        def fn(img, kwargs):\n            ext = kwargs['format'] if 'format' in kwargs else None\n            dest = kwargs['dest'] if 'dest' in kwargs else None\n            if not dest:\n                return None\n            if not ext and self.helper.misc.type.check.string(dest):\n                ext = self.helper.io.path.ext(dest, dot='').lower()\n            if not ext and self.helper.misc.type.check.string(src):\n                ext = self.helper.io.path.ext(src, dot='').lower()\n            if not ext and '_org' in kwargs and kwargs['_org'] and self.helper.misc.type.check.string(kwargs['_org']):\n                ext = self.helper.io.path.ext(kwargs['_org'], dot='').lower()\n            if dest == 's3':\n                return False\n            if not self._driver(options=kwargs).save(img, ext, dest, kwargs):\n                return False\n            return True\n        return self.execute(src, fn, options=options)\n\n    def manipulate(self, src, options=None, **kwargs):\n        if not options and kwargs:\n            options = kwargs\n        options['_org'] = src\n        try:\n            img = self.load(src, options=options)\n            img = self.crop(img, options=options)\n            if not img:\n                return False\n            img = self.resize(img, options=options)\n            if not img:\n                return False\n            img = self.radius(img, options=options)\n            if not img:\n                return False\n            img = self.border(img, options=options)\n            if not img:\n                return False\n            img = self.colorize(img, options=options)\n            if not img:\n                return False\n            saved = self.save(img, options=options)\n            if saved is None:\n                return img\n            elif saved is False:\n                return False\n            return True\n        except Exception as e:\n            self.logging.exception(e)\n            return False",
  "line_no": 25,
  "line_no_percent": "9%"
}