{
  "instruction": "Create a SequentialGUID class that generates a new GUID based on the current timestamp and random bytes. The NewGUID method takes an optional parameter to specify the format of the GUID (as a string or binary) and the position of the timestamp (at the beginning or end of the GUID). The class requires Python 2.6+ with bytearray support.",
  "buggy_code": "import os\nimport datetime\nimport sys\nfrom binascii import unhexlify, hexlify\nimport uuid\n\nclass SequentialGUID:\n    SEQUENTIAL_GUID_AS_STRING = 0\n    SEQUENTIAL_GUID_AS_BINARY = 1\n    SEQUENTIAL_GUID_AT_END = 2\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def NewGUID(guid_type=SEQUENTIAL_GUID_AS_STRING):\n        endian = sys.byteorder\n        rand_bytes = bytearray()\n        rand_bytes += os.urandom(10)\n        ts = long((datetime.datetime.utcnow() - datetime.datetime(1970, 1, 1)).total_seconds() * 1000)\n        tsbytes = bytearray()\n        tsbytes += long_to_bytes(ts)\n        while len(tsbytes) < 8:\n            tsbytes.insert(0, 0)\n        guid_bytes = bytearray(16)\n        if guid_type != SequentialGUID.SEQUENTIAL_GUID_AT_END:\n            guid_bytes[0] = tsbytes[2]\n            guid_bytes[1] = tsbytes[3]\n            guid_bytes[2] = tsbytes[4]\n            guid_bytes[3] = tsbytes[5]\n            guid_bytes[4] = tsbytes[6]\n            guid_bytes[5] = tsbytes[7]\n            guid_bytes[6] = rand_bytes[0]\n            guid_bytes[7] = rand_bytes[1]\n            guid_bytes[8] = rand_bytes[2]\n            guid_bytes[9] = rand_bytes[3]\n            guid_bytes[10] = rand_bytes[4]\n            guid_bytes[11] = rand_bytes[5]\n            guid_bytes[12] = rand_bytes[6]\n            guid_bytes[13] = rand_bytes[7]\n            guid_bytes[14] = rand_bytes[8]\n            guid_bytes[15] = rand_bytes[9]\n            if guid_type == SequentialGUID.SEQUENTIAL_GUID_AS_STRING and endian == 'little' and (1 != 1):\n                b = guid_bytes[0:4]\n                b.reverse()\n                guid_bytes[0] = b[0]\n                guid_bytes[1] = b[1]\n                guid_bytes[2] = b[2]\n                guid_bytes[3] = b[3]\n                b = guid_bytes[4:6]\n                b.reverse()\n                guid_bytes[4] = b[0]\n                guid_bytes[5] = b[1]\n                pass\n            pass\n        else:\n            guid_bytes[10] = tsbytes[2]\n            guid_bytes[11] = tsbytes[3]\n            guid_bytes[12] = tsbytes[4]\n            guid_bytes[13] = tsbytes[4]\n            guid_bytes[14] = tsbytes[6]\n            guid_bytes[15] = tsbytes[7]\n            guid_bytes[0] = rand_bytes[0]\n            guid_bytes[1] = rand_bytes[1]\n            guid_bytes[2] = rand_bytes[2]\n            guid_bytes[3] = rand_bytes[3]\n            guid_bytes[4] = rand_bytes[4]\n            guid_bytes[5] = rand_bytes[5]\n            guid_bytes[6] = rand_bytes[6]\n            guid_bytes[7] = rand_bytes[7]\n            guid_bytes[8] = rand_bytes[8]\n            guid_bytes[9] = rand_bytes[9]\n            pass\n        guid = uuid.UUID(hex=hexlify(guid_bytes))\n        return guid\n\ndef long_to_bytes(val, endianness='big'):\n    \"\"\" Pulled from http://stackoverflow.com/questions/8730927/convert-python-long-int-to-fixed-size-byte-array\n    Use :ref:`string formatting` and :func:`~binascii.unhexlify` to\n    convert ``val``, a :func:`long`, to a byte :func:`str`.\n\n    :param long val: The value to pack\n\n    :param str endianness: The endianness of the result. ``'big'`` for\n      big-endian, ``'little'`` for little-endian.\n\n    If you want byte- and word-ordering to differ, you're on your own.\n\n    Using :ref:`string formatting` lets us use Python's C innards.\n    \"\"\"\n    width = val.bit_length()\n    width += 8 - (width % 8 or 8)\n    fmt = '%%0%dx' % (width // 4)\n    s = unhexlify(fmt % val)\n    if endianness == 'little':\n        s = s[::-1]\n    return s",
  "line_no": 66,
  "line_no_percent": "68%"
}