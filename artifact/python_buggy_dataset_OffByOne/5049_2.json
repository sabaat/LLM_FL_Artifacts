{
  "instruction": "This code is a Python script for downloading slides and exercises for university lectures. To use it, you need to provide a config file under data/config.yaml. The script takes several command line arguments: \n\n- -v or --verbose for verbose output\n- -c or --course to specify a course which should be checked\n- -s or --source to specify a source which should be checked\n- -sim or --simulate to specify if the process should only be simulated\n- --clear to specify a course which files should be deleted from the database (not from file system). Use keyword 'all' to clear the whole database.\n\nThe script dynamically loads a class from a string, logs messages if verbose output is on, and loops through sources and courses to download relevant files. It also checks file extensions and names, and saves file and timestamp information in a database. To clear courses from the database, use the --clear argument.",
  "buggy_code": "import argparse\nimport importlib\nimport os\nimport re\nimport sqlite3\nfrom datetime import datetime\nfrom urllib.parse import urljoin\nimport requests\nimport yaml\n\ndef load_plugin_class(plugin_class_str):\n    \"\"\"\n    dynamically load a class from a string\n    \"\"\"\n    class_data = plugin_class_str.split('.')\n    module_path = 'plugins.' + '.'.join(class_data[:-1])\n    class_str = class_data[-1]\n    mod = importlib.import_module(module_path)\n    return getattr(mod, class_str)\n\ndef log(msg):\n    if verbose_output:\n        print(msg)\n\ndef course_loop():\n    download_count = 0\n    skip_count = 0\n    try:\n        with open(os.path.join(os.path.dirname(__file__), 'data', 'config.yaml'), 'r', encoding='utf-8') as config_file:\n            config = yaml.load(config_file)\n    except FileNotFoundError:\n        print('Please provide a config file under data/config.yaml.')\n        return\n    session = requests.Session()\n    for src_cfg in config:\n        if 'courses' not in src_cfg or (source_part is not None and src_cfg['name'] not in source_part):\n            continue\n        log('\\n\\nSource: %s' % src_cfg['name'])\n        try:\n            src_class = load_plugin_class(src_cfg['class'])\n            src = src_class()\n        except AttributeError:\n            print('Class %s not found. Check your config file.' % src_cfg['class'])\n            continue\n        except ImportError:\n            print('Class %s not found. Check your config file' % src_cfg['class'] + ' and ensure you have the class qualifier relative to the plugin directory.')\n            continue\n        if 'login_url' in src_cfg and 'username' in src_cfg and ('password' in src_cfg):\n            src.login(session, src_cfg['login_url'], src_cfg['username'], src_cfg['password'])\n        for course in src_cfg['courses']:\n            if course_part is not None and course['name'] not in course_part:\n                continue\n            log('\\nCourse: %s\\n' % course['name'])\n            if 'path' in course and course['path'] is not None:\n                course_url = urljoin(src_cfg['base_url'], course['path'])\n            elif 'param' in course and course['param'] is not None:\n                course_url = src.course_url(src_cfg['base_url'], course['param'])\n            else:\n                course_url = src_cfg['base_url']\n            text_pattern = re.compile(course['pattern'])\n            filename_pattern = None\n            if 'filename_pattern' in course:\n                filename_pattern = re.compile(course['filename_pattern'])\n            links = src.link_list(session, course_url)\n            if links is None:\n                continue\n            for link in links:\n                if text_pattern.search(link[0]) is not None:\n                    file_request = session.head(link[1], allow_redirects=True)\n                    if 'Content-Disposition' in file_request.headers:\n                        file_disposition = file_request.headers['Content-Disposition']\n                        file_name = file_disposition[file_disposition.index('filename=') + 10:len(file_disposition) - 1].encode('latin-1').decode('utf8')\n                    else:\n                        file_name = link[1].rsplit('/', 1)[-1]\n                    file_ext = os.path.splitext(file_name)[1]\n                    if 'ext' in course and course['ext'] is not False:\n                        if file_ext != course['ext'] or file_ext not in course['ext']:\n                            continue\n                    if filename_pattern is not None and filename_pattern.search(file_name) is None:\n                        continue\n                    if 'Last-Modified' in file_request.headers:\n                        file_last_modified = int(datetime.strptime(file_request.headers['Last-Modified'], '%a, %d %b %Y %H:%M:%S %Z').timestamp())\n                    else:\n                        print('No timestamp found for file %s' % file_name)\n                        continue\n                    if 'rename' in course and course['rename'] is not False:\n                        num = re.search('\\\\d{1,3}', link[0])\n                        if num is None:\n                            num = re.search('\\\\d{1,3}', file_name)\n                        if num is None:\n                            num = file_last_modified\n                        else:\n                            num = num.group(0)\n                        file_name = course['rename'].replace('%', str(num)) + file_ext\n                    file_name = file_name.strip()\n                    file_path = os.path.join(course['local_folder'], file_name)\n                    file_last_modified_old = c.execute('SELECT last_modified FROM file_modifications WHERE source=? AND course=? AND file_name=?', (src_cfg['name'], course['name'], file_name)).fetchone()\n                    if not simulate and file_last_modified_old is None:\n                        c.execute('\\n                            INSERT INTO file_modifications (source, course, file_name, file_path, last_modified)\\n                            VALUES (?,?,?,?,?)\\n                            ', (src_cfg['name'], course['name'], file_name, file_path, file_last_modified))\n                    elif not simulate and file_last_modified > file_last_modified_old[0]:\n                        c.execute('UPDATE file_modifications SET last_modified=? WHERE source=? AND course=? AND file_name=?', (file_last_modified, src_cfg['name'], course['name'], file_name))\n                    else:\n                        skip_count += 1\n                        continue\n                    log(file_name + ' (new)')\n                    if simulate:\n                        conn.rollback()\n                        continue\n                    file_request = session.get(link[1])\n                    try:\n                        os.makedirs(os.path.dirname(file_path), exist_ok=True)\n                        with open(file_path, 'wb') as f:\n                            f.write(file_request.content)\n                            download_count += 1\n                    except FileNotFoundError:\n                        print(\"Can't write file to %s\" % file_path)\n                        conn.rollback()\n                    conn.commit()\n    log('\\nDownloaded %i file(s), skipped %i file(s)' % (download_count, skip_count))\n\ndef clear_course():\n    if course_to_clear[0] == 'all':\n        c.execute('DELETE FROM file_modifications')\n        log('\\nCleared all courses')\n    else:\n        c.execute('DELETE FROM file_modifications WHERE course=?', course_to_clear)\n        log('\\nCleared course %s' % course_to_clear[1])\n    conn.commit()\nparser = argparse.ArgumentParser(description='A simple script for downloading slides and exercises for university lectures.')\nparser.add_argument('-v', '--verbose', action='store_true', help='verbose output')\nparser.add_argument('-c', '--course', action='append', help='specify a course which should be checked')\nparser.add_argument('-s', '--source', action='append', help='specify a source which should be checked')\nparser.add_argument('-sim', '--simulate', action='store_true', help='specify if the process should only be simulated')\nparser.add_argument('--clear', action='append', help='specify a course which files should be deleted from the database (not from file system).' + \"Use keyword 'all' to clear the whole database\")\nargs = parser.parse_args()\nverbose_output = args.verbose\nsimulate = args.simulate\ncourse_part = args.course\nsource_part = args.source\ncourse_to_clear = args.clear\nconn = sqlite3.connect(os.path.join(os.path.dirname(__file__), 'data', 'file_modifications.db'))\nc = conn.cursor()\nc.execute('\\n    CREATE TABLE IF NOT EXISTS file_modifications (\\n        id\\tINTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\\n        source TEXT,\\n        course\\tTEXT,\\n        file_name\\tTEXT,\\n        file_path TEXT,\\n        last_modified\\tINTEGER\\n    );\\n    ')\nif simulate:\n    log('Simulation on')\nif course_to_clear is not None:\n    clear_course()\nelse:\n    course_loop()\nc.close()",
  "line_no": 176,
  "line_no_percent": "117%"
}