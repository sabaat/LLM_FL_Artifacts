{
  "instruction": "Create a command-line tool for voting on git commands. The tool should have the following sub-commands: \"vote\", \"list\", \"tally\", and \"elect\". The \"vote\" sub-command should allow a user to vote for a specific commit. The \"list\" sub-command should list all votes. The \"tally\" sub-command should tally all votes. The \"elect\" sub-command should elect a commit based on the number of votes. The tool should be implemented using Python and the Git command-line tool.",
  "buggy_code": "import argparse\nimport collections\nimport re\nimport subprocess\nNOTES_REF = 'refs/notes/votes'\nVote = collections.namedtuple('Vote', ['commit', 'user'])\n\ndef vote(args):\n    assert args.user, 'TODO: determine user automatically'\n    vote = 'vote:%s' % args.user\n    subprocess.check_call(['git', 'notes', '--ref', NOTES_REF, 'append', '--allow-empty', '-m', vote, args.COMMIT], cwd=args.repo_dir)\n\ndef get_all_votes(repo_dir):\n    output_bytes = subprocess.check_output(['git', 'notes', '--ref', NOTES_REF, 'list'], cwd=repo_dir)\n    output = output_bytes.decode('utf-8')\n    for line in output.splitlines():\n        if not line:\n            continue\n        votenote_ref, commit_id = line.split()\n        votenote_bytes = subprocess.check_output(['git', 'show', votenote_ref], cwd=repo_dir)\n        votenote_content = votenote_bytes.decode('utf-8')\n        for voteline in votenote_content.splitlines():\n            if not voteline:\n                continue\n            m = re.match('^vote:(?P<user>[a-z0-9@._]+)$', voteline.strip())\n            if not m:\n                print('Skipping crap %r' % voteline)\n                continue\n            user = m.group('user')\n            yield Vote(commit=commit_id, user=user)\n\ndef print_list(args):\n    all_votes = get_all_votes(args.repo_dir)\n    all_votes_sorted = sorted(all_votes, key=lambda v: (v.commit, v.user))\n    for v in all_votes_sorted:\n        print('%s: +1 from %s' % (v.commit, v.user))\n\ndef tally(all_votes):\n    \"\"\" Returns a dict commit id => set of users \"\"\"\n    res = collections.defaultdict(set)\n    for v in all_votes:\n        res[v.commit].add(v.user)\n    return res\n\ndef print_tally(args):\n    all_votes = get_all_votes(args.repo_dir)\n    for commit, votes in sorted(tally(all_votes).items(), key=lambda kv: (kv[1], kv[1])):\n        print('%s: %d votes' % (commit, len(votes)))\n\ndef print_elect(args):\n    all_votes = get_all_votes(args.repo_dir)\n    winner_vcount, winner_commit = max(((len(votes), commit) for commit, votes in tally(all_votes).items()))\n    print('%s won the election with %d votes' % (winner_commit, winner_vcount))\n\ndef main():\n    parser = argparse.ArgumentParser('Vote on git commands')\n    parser.add_argument('-r', '--repo-dir', metavar='DIR', help='root directory of the repository to modify')\n    subparsers = parser.add_subparsers(dest='cmd')\n    vote_parser = subparsers.add_parser('vote', help='Vote for commit')\n    vote_parser.add_argument('--user', metavar='USER_ID', help='ID of the user to vote as')\n    vote_parser.add_argument('COMMIT', help='reference to the commit to vote for')\n    subparsers.add_parser('list', help='List all votes')\n    subparsers.add_parser('tally', help='Tally all votes')\n    subparsers.add_parser('elect', help='Elect a commit')\n    args = parser.parse_args()\n    if args.cmd == 'vote':\n        vote(args)\n    elif args.cmd == 'list':\n        print_list(args)\n    elif args.cmd == 'tally':\n        print_tally(args)\n    elif args.cmd == 'elect':\n        print_elect(args)\n    else:\n        parser.print_help()\nif __name__ == '__main__':\n    main()",
  "line_no": 65,
  "line_no_percent": "84%"
}