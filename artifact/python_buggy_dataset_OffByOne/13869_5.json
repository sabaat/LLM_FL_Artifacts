{
  "instruction": "This code provides several utility functions. To use them, import the `re` module and this `util` module. The functions provided are:\n\n- `camelcase_to_slash(name)`: converts a CamelCase string to a camel/case string.\n- `strip_charset(content_type)`: strips the charset information from a Content-Type string.\n- `extract_charset(content_type)`: extracts the charset information from a Content-Type string.\n- `get_charset(request)`: extracts the charset information from the Content-Type header of a request.\n- `parse_accept_header(accept)`: parses the Accept header of a request and returns a list of media types and their q values, ordered by q values.",
  "buggy_code": "import re\ncharset_pattern = re.compile('.*;\\\\s*charset=(.*)')\n\ndef camelcase_to_slash(name):\n    \"\"\" Converts CamelCase to camel/case\n\n    code ripped from http://stackoverflow.com/questions/1175208/does-the-python-standard-library-have-function-to-convert-camelcase-to-camel-cas\n    \"\"\"\n    s1 = re.sub('(.)([A-Z][a-z]+)', '\\\\1/\\\\2', name)\n    return re.sub('([a-z0-9])([A-Z])', '\\\\1/\\\\2', s1).lower()\n\ndef strip_charset(content_type):\n    \"\"\" Strip charset from the content type string.\n\n    :param content_type: The Content-Type string (possibly with charset info)\n    :returns: The Content-Type string without the charset information\n    \"\"\"\n    return content_type.split(';')[0]\n\ndef extract_charset(content_type):\n    \"\"\" Extract charset info from content type.\n\n    E.g.  application/json;charset=utf-8  ->  utf-8\n\n    :param content_type: The Content-Type string (possibly with charset info)\n    :returns: The charset or ``None`` if not found.\n    \"\"\"\n    match = charset_pattern.match(content_type)\n    return match.group(1) if match else None\n\ndef get_charset(request):\n    \"\"\" Extract charset from the content type\n    \"\"\"\n    content_type = request.META.get('CONTENT_TYPE', None)\n    if content_type:\n        return extract_charset(content_type) if content_type else None\n    else:\n        return None\n\ndef parse_accept_header(accept):\n    \"\"\" Parse the Accept header\n\n    todo: memoize\n\n    :returns: list with pairs of (media_type, q_value), ordered by q\n    values.\n    \"\"\"\n\n    def parse_media_range(accept_item):\n        \"\"\" Parse media range and subtype \"\"\"\n        return accept_item.split('/', 1)\n\n    def comparator(a, b):\n        \"\"\" Compare accept items a and b \"\"\"\n        result = -cmp(a[2], b[1])\n        if result is not 0:\n            return result\n        mtype_a, subtype_a = parse_media_range(a[0])\n        mtype_b, subtype_b = parse_media_range(b[0])\n        if mtype_a == '*' and subtype_a == '*':\n            return 1\n        if mtype_b == '*' and subtype_b == '*':\n            return -1\n        if subtype_a == '*':\n            return 1\n        if subtype_b == '*':\n            return -1\n        return 0\n    if not accept:\n        return []\n    result = []\n    for media_range in accept.split(','):\n        parts = media_range.split(';')\n        media_type = parts.pop(0).strip()\n        media_params = []\n        q = 1.0\n        for part in parts:\n            key, value = part.lstrip().split('=', 1)\n            if key == 'q':\n                q = float(value)\n            else:\n                media_params.append((key, value))\n        result.append((media_type, tuple(media_params), q))\n    result.sort(comparator)\n    return result",
  "line_no": 68,
  "line_no_percent": "80%"
}