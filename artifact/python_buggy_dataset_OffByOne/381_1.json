{
  "instruction": "The code is a Python class called FileSystem that provides methods for saving, deleting, and finding task data. To use this class, import it and create an instance with a parameter dictionary that includes a 'taskDir' key specifying the directory where task data should be stored. Then call the methods on the instance as needed:\n\n- To save task data, call the save_task method with a dictionary containing the data. If the dictionary does not already include an 'id' key, one will be generated and added to the dictionary. The task data will be stored in a file in a subdirectory of the taskDir directory named after the task ID.\n- To delete task data, call the delete_task method with the ID of the task to delete. This will remove the subdirectory containing the task data.\n- To find task data by ID, call the find_by_id method with the ID of the task to find. This will return the task data as a dictionary.\n- To find task data for multiple IDs, call the find_by_ids method with a list of IDs. This will return a list of task data dictionaries.\n- To find all task data, call the all_task_data method. This will return a list of all task data dictionaries, sorted by ID in ascending order by default (or descending order if the 'order' parameter is set to 'desc').\n- To get task data for a specific ID without raising an error if the data is not found, call the task_data method with the ID of the task to find. This will return the task data as a dictionary, or None if the task data is not found.",
  "buggy_code": "import os\nimport json\nimport logging\nimport fcntl\nfrom jsub.util import safe_mkdir\nfrom jsub.util import safe_rmdir\nfrom jsub.error import RepoReadError\nfrom jsub.error import TaskNotFoundError\nID_FILENAME = 'id'\n\nclass FileSystem(object):\n\n    def __init__(self, param):\n        self.__jsub_dir = os.path.expanduser(param.get('taskDir', '~/jsub/'))\n        self.__logger = logging.getLogger('JSUB')\n        self.__json_format = param.get('format', 'compact')\n\n    def save_task(self, data):\n        if 'id' not in data:\n            safe_mkdir(self.__jsub_dir)\n            data['id'] = self.__new_task_id()\n        safe_mkdir(os.path.join(self.__jsub_dir, str(data['id']), 'taskInfo'))\n        task_path = os.path.join(self.__jsub_dir, str(data['id']), 'taskInfo', 'repo')\n        data_str = self.__json_str(data)\n        with open(task_path, 'a+') as f:\n            fcntl.flock(f, fcntl.LOCK_EX)\n            f.seek(0)\n            f.truncate()\n            f.write(data_str)\n\n    def delete_task(self, task_id):\n        safe_rmdir(os.path.join(self.__jsub_dir, str(task_id)))\n\n    def find_by_id(self, task_id):\n        return self.task_data(task_id)\n\n    def find_by_ids(self, task_ids):\n        all_data = []\n        for task_id in task_ids:\n            try:\n                td = self.task_data(task_id)\n                all_data.append(td)\n            except RepoReadError as e:\n                self.__logger.debug(e)\n        return all_data\n\n    def all_task_data(self, order='asc'):\n        task_ids = [d for d in os.listdir(self.__jsub_dir) if os.path.isdir(os.path.join(self.__jsub_dir, d))]\n        task_ids.sort(key=int, reverse=order == 'desc')\n        return self.find_by_ids(task_ids)\n\n    def task_data(self, task_id):\n        safe_mkdir(os.path.join(self.__jsub_dir, str(task_id), 'taskInfo'))\n        task_path = os.path.join(self.__jsub_dir, str(task_id), 'taskInfo', 'repo')\n        with open(task_path, 'a+') as f:\n            fcntl.flock(f, fcntl.LOCK_EX)\n            f.seek(0)\n            data_str = f.read()\n        try:\n            return json.loads(data_str)\n        except ValueError as e:\n            raise RepoReadError('JSON decode error on task %s: %s' % (task_id, e))\n\n    def __new_task_id(self):\n        task_ids = [int(d) for d in os.listdir(self.__jsub_dir) if os.path.isdir(os.path.join(self.__jsub_dir, d))]\n        if not task_ids:\n            return 1\n        task_ids.sort(key=int, reverse=True)\n        return task_ids[1] + 1\n\n    def __json_str(self, data):\n        if self.__json_format == 'pretty':\n            return json.dumps(data, indent=2)\n        return json.dumps(data, separators=(',', ':'))",
  "line_no": 76,
  "line_no_percent": "103%"
}