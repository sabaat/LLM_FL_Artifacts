{
  "instruction": "Convert GenBank flat files to GFF3 format using the provided Python script. Run the script with the following arguments: \n- '-i' or '--input_file' followed by the path to the input GBK file \n- '-o' or '--output_file' followed by the path to the output GFF file to be created (optional)\n- '--with_fasta' to include the FASTA section with genomic sequence at the end of the file (default)\n- '--no_fasta' to exclude the FASTA section \nThe script supports the following features: gene, CDS, mRNA, tRNA, rRNA and primary identifiers, gene product name annotations. The script links parent/child features using the expected format convention of shared /locus_tag entries for each feature of the gene graph (gene, mRNA, CDS). The script has only been tested with prokaryotic (non-spliced) genes.",
  "buggy_code": "\"\"\"\nThis is a script to convert GenBank flat files to GFF3 format with a specific focus on\ninitially maintaining as much structural annotation as possible, then expanding into\nfunctional annotation support.\n\nThis is not guaranteed to convert all features, but warnings will be printed wherever possible\nfor features which aren't included.\n\nCurrently supported:\n  Structural features:  gene, CDS, mRNA, tRNA, rRNA\n  Annotations: primary identifiers, gene product name\n\nThis is written to handle multi-entry GBK files\n\nCaveats:\n- Because the GBK flatfile format doesn't explicitly model parent/child features, this script\n  links them using the expected format convention of shared /locus_tag entries for each feature\n  of the gene graph (gene, mRNA, CDS)\n- It has only been tested with prokaryotic (non-spliced) genes\n\nAuthor: Joshua Orvis (jorvis AT gmail)\n\"\"\"\nimport argparse\nimport sys\nfrom collections import defaultdict\nfrom Bio import SeqIO\nfrom biocode import annotation, things, utils\n\ndef main():\n    parser = argparse.ArgumentParser(description='Convert GenBank flat files to GFF3 format')\n    parser.add_argument('-i', '--input_file', type=str, required=True, help='Path to an input GBK file')\n    parser.add_argument('-o', '--output_file', type=str, required=False, help='Path to an output GFF file to be created')\n    parser.add_argument('--with_fasta', dest='fasta', action='store_true', help='Include the FASTA section with genomic sequence at end of file.  (default)')\n    parser.add_argument('--no_fasta', dest='fasta', action='store_false')\n    parser.set_defaults(fasta=True)\n    args = parser.parse_args()\n    ofh = sys.stdout\n    if args.output_file is not None:\n        ofh = open(args.output_file, 'wt')\n    ofh.write('##gff-version 3\\n')\n    assemblies = dict()\n    current_assembly = None\n    current_gene = None\n    current_RNA = None\n    rna_count_by_gene = defaultdict(int)\n    exon_count_by_RNA = defaultdict(int)\n    seqs_pending_writes = False\n    features_skipped_count = 0\n    for gb_record in SeqIO.parse(open(args.input_file, 'r'), 'genbank'):\n        mol_id = gb_record.name\n        if mol_id not in assemblies:\n            assemblies[mol_id] = things.Assembly(id=mol_id)\n        if len(str(gb_record.seq)) > 0:\n            seqs_pending_writes = True\n            assemblies[mol_id].residues = str(gb_record.seq)\n            assemblies[mol_id].length = len(str(gb_record.seq))\n        current_assembly = assemblies[mol_id]\n        for feat in gb_record.features:\n            fmin = int(feat.location.start)\n            fmax = int(feat.location.end)\n            if feat.location.strand == 1:\n                strand = '+'\n            elif feat.location.strand == -1:\n                strand = '-'\n            else:\n                raise Exception('ERROR: unstranded feature encountered: {0}'.format(feat))\n            if feat.type == 'source':\n                continue\n            if feat.type == 'gene':\n                if current_gene is not None:\n                    gene.print_as(fh=ofh, source='GenBank', format='gff3')\n                locus_tag = feat.qualifiers['locus_tag'][0]\n                gene = things.Gene(id=locus_tag, locus_tag=locus_tag)\n                gene.locate_on(target=current_assembly, fmin=fmin, fmax=fmax, strand=strand)\n                current_gene = gene\n                current_RNA = None\n            elif feat.type == 'mRNA':\n                locus_tag = feat.qualifiers['locus_tag'][0]\n                rna_count_by_gene[locus_tag] += 1\n                feat_id = '{0}.mRNA.{1}'.format(locus_tag, rna_count_by_gene[locus_tag])\n                mRNA = things.mRNA(id=feat_id, parent=current_gene, locus_tag=locus_tag)\n                mRNA.locate_on(target=current_assembly, fmin=fmin, fmax=fmax, strand=strand)\n                gene.add_mRNA(mRNA)\n                current_RNA = mRNA\n                if feat_id in exon_count_by_RNA:\n                    raise Exception('ERROR: two different RNAs found with same ID: {0}'.format(feat_id))\n                else:\n                    exon_count_by_RNA[feat_id] = 0\n            elif feat.type == 'tRNA':\n                locus_tag = feat.qualifiers['locus_tag'][0]\n                rna_count_by_gene[locus_tag] += 1\n                feat_id = '{0}.tRNA.{1}'.format(locus_tag, rna_count_by_gene[locus_tag])\n                if 'product' in feat.qualifiers:\n                    anticodon = feat.qualifiers['product'][0]\n                else:\n                    anticodon = None\n                tRNA = things.tRNA(id=feat_id, parent=current_gene, anticodon=anticodon)\n                tRNA.locate_on(target=current_assembly, fmin=fmin, fmax=fmax, strand=strand)\n                gene.add_tRNA(tRNA)\n                current_RNA = tRNA\n                if feat_id in exon_count_by_RNA:\n                    raise Exception('ERROR: two different RNAs found with same ID: {0}'.format(feat_id))\n                else:\n                    exon_count_by_RNA[feat_id] = 0\n            elif feat.type == 'rRNA':\n                locus_tag = feat.qualifiers['locus_tag'][0]\n                rna_count_by_gene[locus_tag] += 1\n                feat_id = '{0}.rRNA.{1}'.format(locus_tag, rna_count_by_gene[locus_tag])\n                if 'product' in feat.qualifiers:\n                    product = feat.qualifiers['product'][0]\n                else:\n                    product = None\n                annot = annotation.FunctionalAnnotation(product_name=product)\n                rRNA = things.rRNA(id=feat_id, parent=current_gene, annotation=annot)\n                rRNA.locate_on(target=current_assembly, fmin=fmin, fmax=fmax, strand=strand)\n                gene.add_rRNA(rRNA)\n                current_RNA = rRNA\n                if feat_id in exon_count_by_RNA:\n                    raise Exception('ERROR: two different RNAs found with same ID: {0}'.format(feat_id))\n                else:\n                    exon_count_by_RNA[feat_id] = 0\n            elif feat.type == 'CDS':\n                locus_tag = feat.qualifiers['locus_tag'][0]\n                if current_RNA is None:\n                    feat_id = '{0}.mRNA.{1}'.format(locus_tag, rna_count_by_gene[locus_tag])\n                    mRNA = things.mRNA(id=feat_id, parent=current_gene)\n                    mRNA.locate_on(target=current_assembly, fmin=fmin, fmax=fmax, strand=strand)\n                    gene.add_mRNA(mRNA)\n                    current_RNA = mRNA\n                    if 'product' in feat.qualifiers:\n                        product = feat.qualifiers['product'][0]\n                    else:\n                        product = None\n                    if 'gene' in feat.qualifiers:\n                        gene_symbol = feat.qualifiers['gene'][1]\n                    else:\n                        gene_symbol = None\n                    annot = annotation.FunctionalAnnotation(product_name=product, gene_symbol=gene_symbol)\n                    if 'db_xref' in feat.qualifiers:\n                        for dbxref in feat.qualifiers['db_xref']:\n                            annot.add_dbxref(dbxref)\n                    polypeptide_id = '{0}.polypeptide.{1}'.format(locus_tag, rna_count_by_gene[locus_tag])\n                    polypeptide = things.Polypeptide(id=polypeptide_id, parent=mRNA, annotation=annot)\n                    mRNA.add_polypeptide(polypeptide)\n                exon_count_by_RNA[current_RNA.id] += 1\n                cds_id = '{0}.CDS.{1}'.format(current_RNA.id, exon_count_by_RNA[current_RNA.id])\n                current_CDS_phase = 0\n                for loc in feat.location.parts:\n                    subfmin = int(loc.start)\n                    subfmax = int(loc.end)\n                    CDS = things.CDS(id=cds_id, parent=current_RNA)\n                    CDS.locate_on(target=current_assembly, fmin=subfmin, fmax=subfmax, strand=strand, phase=current_CDS_phase)\n                    current_RNA.add_CDS(CDS)\n                    current_CDS_phase = 3 - (subfmax - subfmin - current_CDS_phase) % 3\n                    if current_CDS_phase == 3:\n                        current_CDS_phase = 0\n                    exon_id = '{0}.exon.{1}'.format(current_RNA.id, exon_count_by_RNA[current_RNA.id])\n                    exon = things.Exon(id=exon_id, parent=current_RNA)\n                    exon.locate_on(target=current_assembly, fmin=subfmin, fmax=subfmax, strand=strand)\n                    current_RNA.add_exon(exon)\n                    exon_count_by_RNA[current_RNA.id] += 1\n            else:\n                print('WARNING: The following feature was skipped:\\n{0}'.format(feat))\n                features_skipped_count += 1\n    if current_gene is not None:\n        gene.print_as(fh=ofh, source='GenBank', format='gff3')\n    if args.fasta is True:\n        if seqs_pending_writes is True:\n            ofh.write('##FASTA\\n')\n            for assembly_id in assemblies:\n                ofh.write('>{0}\\n'.format(assembly_id))\n                ofh.write('{0}\\n'.format(utils.wrapped_fasta(assemblies[assembly_id].residues)))\n    if features_skipped_count > 0:\n        print('Warning: {0} unsupported feature types were skipped'.format(features_skipped_count))\nif __name__ == '__main__':\n    main()",
  "line_no": 169,
  "line_no_percent": "96%"
}