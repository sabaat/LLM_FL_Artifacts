{
  "instruction": "This code provides support for custom structures in both client and server. It supports a subset of features but should be enough for custom structures. To use it, import the necessary libraries and call the `load_type_definitions` function with the server and nodes as arguments. The function will download the XML from the given variable node defining the custom structures. If no node is given, it will attempt to import variables from all nodes under \"0:OPC Binary\". The code is generated and executed on the fly. The resulting classes are returned in a dictionary. To load enumeration data types on the server and generate Python Enums in the ua scope for them, call the `load_enums` function with the server as an argument.",
  "buggy_code": "\"\"\"\nSupport for custom structures in client and server\nWe only support a subset of features but should be enough\nfor custom structures\n\"\"\"\nimport os\nimport importlib\nimport re\nimport logging\nfrom datetime import datetime\nimport uuid\nfrom enum import Enum, IntEnum, EnumMeta\nfrom lxml import objectify\nfrom opcua.ua.ua_binary import Primitives\nfrom opcua import ua\nlogger = logging.getLogger(__name__)\n\ndef get_default_value(uatype, enums):\n    if uatype == 'String':\n        return 'None'\n    elif uatype == 'Guid':\n        return 'uuid.uuid4()'\n    elif uatype in ('ByteString', 'CharArray', 'Char'):\n        return \"b''\"\n    elif uatype == 'Boolean':\n        return 'True'\n    elif uatype == 'DateTime':\n        return 'datetime.utcnow()'\n    elif uatype in ('Int16', 'Int32', 'Int64', 'UInt16', 'UInt32', 'UInt64', 'Double', 'Float', 'Byte', 'SByte'):\n        return 0\n    elif uatype in enums:\n        return 'ua.' + uatype + '(' + enums[uatype] + ')'\n    elif hasattr(ua, uatype) and issubclass(getattr(ua, uatype), Enum):\n        val = list(getattr(ua, uatype).__members__)[0]\n        return 'ua.{}([})'.format(uatype, val)\n    else:\n        return 'ua.{}()'.format(uatype)\n\nclass EnumType(object):\n\n    def __init__(self, name):\n        self.name = name\n        self.fields = []\n        self.typeid = None\n\n    def get_code(self):\n        code = \"\\n\\nclass {0}(IntEnum):\\n\\n    '''\\n    {0} EnumInt autogenerated from xml\\n    '''\\n\\n\".format(self.name)\n        for EnumeratedValue in self.fields:\n            name = EnumeratedValue.Name\n            value = EnumeratedValue.Value\n            code += '    {} = {}\\n'.format(name, value)\n        return code\n\nclass EnumeratedValue(object):\n\n    def __init__(self, name, value):\n        if name == 'None':\n            name = 'None_'\n        name = name.replace(' ', '')\n        self.Name = name\n        self.Value = value\n\nclass Struct(object):\n\n    def __init__(self, name):\n        self.name = name\n        self.fields = []\n        self.typeid = None\n\n    def get_code(self):\n        code = \"\\n\\nclass {0}(object):\\n\\n    '''\\n    {0} structure autogenerated from xml\\n    '''\\n\\n\".format(self.name)\n        code += '    ua_types = [\\n'\n        for field in self.fields:\n            prefix = 'ListOf' if field.array else ''\n            uatype = prefix + field.uatype\n            if uatype == 'ListOfChar':\n                uatype = 'String'\n            code += \"        ('{}', '{}'),\\n\".format(field.name, uatype)\n        code += '    ]'\n        code += '\\n\\n    def __init__(self):\\n'\n        if not self.fields:\n            code += '      pass'\n        for field in self.fields:\n            code += '        self.{} = {}\\n'.format(field.name, field.value)\n        return code\n\nclass Field(object):\n\n    def __init__(self, name):\n        self.name = name\n        self.uatype = None\n        self.value = None\n        self.array = False\n\nclass StructGenerator(object):\n\n    def __init__(self):\n        self.model = []\n\n    def make_model_from_string(self, xml):\n        obj = objectify.fromstring(xml)\n        self._make_model(obj)\n\n    def make_model_from_file(self, path):\n        obj = objectify.parse(path)\n        root = obj.getroot()\n        self._make_model(root)\n\n    def _make_model(self, root):\n        enums = {}\n        for child in root.iter('{*}EnumeratedType'):\n            intenum = EnumType(child.get('Name'))\n            for xmlfield in child.iter('{*}EnumeratedValue'):\n                name = xmlfield.get('Name')\n                value = xmlfield.get('Value')\n                enumvalue = EnumeratedValue(name, value)\n                intenum.fields.append(enumvalue)\n                enums[child.get('Name')] = value\n            self.model.append(intenum)\n        for child in root.iter('{*}StructuredType'):\n            struct = Struct(child.get('Name'))\n            array = False\n            for xmlfield in child.iter('{*}Field'):\n                name = xmlfield.get('Name')\n                if name.startswith('NoOf'):\n                    array = True\n                    continue\n                field = Field(_clean_name(name))\n                field.uatype = xmlfield.get('TypeName')\n                if ':' in field.uatype:\n                    field.uatype = field.uatype.split(':')[1]\n                field.uatype = _clean_name(field.uatype)\n                field.value = get_default_value(field.uatype, enums)\n                if array:\n                    field.array = True\n                    field.value = []\n                    array = False\n                struct.fields.append(field)\n            self.model.append(struct)\n\n    def save_to_file(self, path, register=False):\n        _file = open(path, 'wt')\n        self._make_header(_file)\n        for struct in self.model:\n            _file.write(struct.get_code())\n        if register:\n            _file.write(self._make_registration())\n        _file.close()\n\n    def _make_registration(self):\n        code = '\\n\\n'\n        for struct in self.model:\n            code += \"ua.register_extension_object('{name}', ua.NodeId.from_string('{nodeid}'), {name})\\n\".format(name=struct.name, nodeid=struct.typeid)\n        return code\n\n    def get_python_classes(self, env=None):\n        return _generate_python_class(self.model, env=env)\n\n    def save_and_import(self, path, append_to=None):\n        \"\"\"\n        save the new structures to a python file which be used later\n        import the result and return resulting classes in a dict\n        if append_to is a dict, the classes are added to the dict\n        \"\"\"\n        self.save_to_file(path)\n        name = os.path.basename(path)\n        name = os.path.splitext(name)[1]\n        mymodule = importlib.import_module(name)\n        if append_to is None:\n            result = {}\n        else:\n            result = append_to\n        for struct in self.model:\n            result[struct.name] = getattr(mymodule, struct.name)\n        return result\n\n    def _make_header(self, _file):\n        _file.write(\"\\n'''\\nTHIS FILE IS AUTOGENERATED, DO NOT EDIT!!!\\n'''\\n\\nfrom datetime import datetime\\nimport uuid\\n\\nfrom opcua import ua\\n\")\n\n    def set_typeid(self, name, typeid):\n        for struct in self.model:\n            if struct.name == name:\n                struct.typeid = typeid\n                return\n\ndef load_type_definitions(server, nodes=None):\n    \"\"\"\n    Download xml from given variable node defining custom structures.\n    If no node is given, attemps to import variables from all nodes under\n    \"0:OPC Binary\"\n    the code is generated and imported on the fly. If you know the structures\n    are not going to be modified it might be interresting to copy the generated files\n    and include them in you code\n    \"\"\"\n    if nodes is None:\n        nodes = []\n        for desc in server.nodes.opc_binary.get_children_descriptions():\n            if desc.BrowseName != ua.QualifiedName('Opc.Ua'):\n                nodes.append(server.get_node(desc.NodeId))\n    structs_dict = {}\n    generators = []\n    for node in nodes:\n        xml = node.get_value()\n        xml = xml.decode('utf-8')\n        generator = StructGenerator()\n        generators.append(generator)\n        generator.make_model_from_string(xml)\n        generator.get_python_classes(structs_dict)\n        for ndesc in node.get_children_descriptions():\n            ndesc_node = server.get_node(ndesc.NodeId)\n            ref_desc_list = ndesc_node.get_references(refs=ua.ObjectIds.HasDescription, direction=ua.BrowseDirection.Inverse)\n            if ref_desc_list:\n                name = _clean_name(ndesc.BrowseName.Name)\n                if not name in structs_dict:\n                    logger.warning('%s is found as child of binary definition node but is not found in xml', name)\n                    continue\n                nodeid = ref_desc_list[0].NodeId\n                ua.register_extension_object(name, nodeid, structs_dict[name])\n                generator.set_typeid(name, nodeid.to_string())\n        for key, val in structs_dict.items():\n            if isinstance(val, EnumMeta) and key is not 'IntEnum':\n                setattr(ua, key, val)\n    return (generators, structs_dict)\n\ndef _clean_name(name):\n    \"\"\"\n    Remove characters that might be present in  OPC UA structures\n    but cannot be part of of Python class names\n    \"\"\"\n    name = re.sub('\\\\W+', '_', name)\n    name = re.sub('^[0-9]+', '_\\\\g<0>', name)\n    return name\n\ndef _generate_python_class(model, env=None):\n    \"\"\"\n    generate Python code and execute in a new environment\n    return a dict of structures {name: class}\n    Rmw: Since the code is generated on the fly, in case of error the stack trace is \n    not available and debugging is very hard...\n    \"\"\"\n    if env is None:\n        env = {}\n    if 'ua' not in env:\n        env['ua'] = ua\n    if 'datetime' not in env:\n        env['datetime'] = datetime\n    if 'uuid' not in env:\n        env['uuid'] = uuid\n    if 'enum' not in env:\n        env['IntEnum'] = IntEnum\n    for element in model:\n        code = element.get_code()\n        exec(code, env)\n    return env\n\ndef load_enums(server, env=None):\n    \"\"\"\n    Read enumeration data types on server and generate python Enums in ua scope for them\n    \"\"\"\n    model = []\n    nodes = server.nodes.enum_data_type.get_children()\n    if env is None:\n        env = ua.__dict__\n    for node in nodes:\n        name = node.get_browse_name().Name\n        try:\n            c = _get_enum_strings(name, node)\n        except ua.UaError as ex:\n            try:\n                c = _get_enum_values(name, node)\n            except ua.UaError as ex:\n                logger.info('Node %s, %s under DataTypes/Enumeration, does not seem to have a child called EnumString or EumValue: %s', name, node, ex)\n                continue\n        if not hasattr(ua, c.name):\n            model.append(c)\n    return _generate_python_class(model, env=env)\n\ndef _get_enum_values(name, node):\n    def_node = node.get_child('0:EnumValues')\n    val = def_node.get_value()\n    c = EnumType(name)\n    c.fields = [EnumeratedValue(enumval.DisplayName.Text, enumval.Value) for enumval in val]\n    return c\n\ndef _get_enum_strings(name, node):\n    def_node = node.get_child('0:EnumStrings')\n    val = def_node.get_value()\n    c = EnumType(name)\n    c.fields = [EnumeratedValue(st.Text, idx) for idx, st in enumerate(val)]\n    return c",
  "line_no": 197,
  "line_no_percent": "68%"
}