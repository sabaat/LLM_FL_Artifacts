{
  "instruction": "Compare tasmin, tas, tasmax in a timeseries of GeoTiff files. The code includes functions to rasterize, sort files, and calculate the mean of the full domain. The code is set up to compare downscaled climate data to old climate data for the historical period. The output is a plot of the mean temperature or precipitation for the specified time period. The output is saved as a PNG file.",
  "buggy_code": "def transform_from_latlon(lat, lon):\n    \"\"\" simple way to make an affine transform from lats and lons coords \"\"\"\n    from affine import Affine\n    lat = np.asarray(lat)\n    lon = np.asarray(lon)\n    trans = Affine.translation(lon[1], lat[0])\n    scale = Affine.scale(lon[1] - lon[0], lat[1] - lat[0])\n    return trans * scale\n\ndef rasterize(shapes, coords, latitude='latitude', longitude='longitude', fill=None, **kwargs):\n    \"\"\"\n\tRasterize a list of (geometry, fill_value) tuples onto the given\n\txarray coordinates. This only works for 1d latitude and longitude\n\tarrays.\n\t\"\"\"\n    from rasterio import features\n    if fill == None:\n        fill = np.nan\n    transform = transform_from_latlon(coords[latitude], coords[longitude])\n    out_shape = (len(coords[latitude]), len(coords[longitude]))\n    raster = features.rasterize(shapes, out_shape=out_shape, fill=fill, transform=transform, dtype=float, **kwargs)\n    spatial_coords = {latitude: coords[latitude], longitude: coords[longitude]}\n    return xr.DataArray(raster, coords=spatial_coords, dims=(latitude, longitude))\n\ndef sort_files(files, split_on='_', elem_month=-2, elem_year=-1):\n    \"\"\"\n\tsort a list of files properly using the month and year parsed\n\tfrom the filename.  This is useful with SNAP data since the standard\n\tis to name files like '<prefix>_MM_YYYY.tif'.  If sorted using base\n\tPythons sort/sorted functions, things will be sorted by the first char\n\tof the month, which makes thing go 1, 11, ... which sucks for timeseries\n\tthis sorts it properly following SNAP standards as the default settings.\n\n\tARGUMENTS:\n\t----------\n\tfiles = [list] list of `str` pathnames to be sorted by month and year. usually from glob.glob.\n\tsplit_on = [str] `str` character to split the filename on.  default:'_', SNAP standard.\n\telem_month = [int] slice element from resultant split filename list.  Follows Python slicing syntax.\n\t\tdefault:-2. For SNAP standard.\n\telem_year = [int] slice element from resultant split filename list.  Follows Python slicing syntax.\n\t\tdefault:-1. For SNAP standard.\n\n\tRETURNS:\n\t--------\n\tsorted `list` by month and year ascending. \n\n\t\"\"\"\n    import pandas as pd\n    months = [int(os.path.basename(fn).split('.')[0].split(split_on)[elem_month]) for fn in files]\n    years = [int(os.path.basename(fn).split('.')[0].split(split_on)[elem_year]) for fn in files]\n    df = pd.DataFrame({'fn': files, 'month': months, 'year': years})\n    df_sorted = df.sort_values(['year', 'month'])\n    return df_sorted.fn.tolist()\n\ndef only_years(files, begin=1901, end=2100, split_on='_', elem_year=-1):\n    \"\"\"\n\treturn new list of filenames where they are truncated to begin:end\n\n\tARGUMENTS:\n\t----------\n\tfiles = [list] list of `str` pathnames to be sorted by month and year. usually from glob.glob.\n\tbegin = [int] four digit integer year of the begin time default:1901\n\tend = [int] four digit integer year of the end time default:2100\n\tsplit_on = [str] `str` character to split the filename on.  default:'_', SNAP standard.\n\telem_year = [int] slice element from resultant split filename list.  Follows Python slicing syntax.\n\t\tdefault:-1. For SNAP standard.\n\n\tRETURNS:\n\t--------\n\tsliced `list` to begin and end year.\n\t\"\"\"\n    import pandas as pd\n    years = [int(os.path.basename(fn).split('.')[0].split(split_on)[elem_year]) for fn in files]\n    df = pd.DataFrame({'fn': files, 'year': years})\n    df_slice = df[(df.year >= begin) & (df.year <= end)]\n    return df_slice.fn.tolist()\n\ndef masked_mean(fn, bounds=None):\n    \"\"\" get mean of the full domain since the data are already clipped \n\tmostly used for processing lots of files in parallel.\"\"\"\n    import numpy as np\n    import rasterio\n    with rasterio.open(fn) as rst:\n        if bounds:\n            window = rst.window(*bounds)\n        else:\n            window = rst.window(*rst.bounds)\n        mask = rst.read_masks(1) == 0\n        arr = np.ma.masked_array(rst.read(1, window=window), mask=mask)\n    return np.mean(arr)\nif __name__ == '__main__':\n    import os, glob\n    import geopandas as gpd\n    import numpy as np\n    import xarray as xr\n    import matplotlib\n    matplotlib.use('agg')\n    from matplotlib import pyplot as plt\n    from pathos.mp_map import mp_map\n    import pandas as pd\n    import geopandas as gpd\n    base_dir = '/workspace/Shared/Tech_Projects/EPSCoR_Southcentral/project_data'\n    os.chdir(base_dir)\n    scenarios = ['historical']\n    shp_fn = '/workspace/Shared/Tech_Projects/EPSCoR_Southcentral/project_data/SCTC_studyarea/Kenai_StudyArea.shp'\n    shp = gpd.read_file(shp_fn)\n    bounds = shp.bounds\n    models = ['ts323']\n    variables_list = [['pr']]\n    begin_end_groups = [[1916, 1916], [1950, 1960], [1995, 2000]]\n    for scenario in scenarios:\n        for variables in variables_list:\n            for m in models:\n                for begin, end in begin_end_groups:\n                    if m == 'ts323':\n                        old_dir = '/Data/Base_Data/Climate/AK_CAN_2km/historical/CRU/CRU_TS32'\n                    elif scenario == 'historical':\n                        old_dir = '/Data/Base_Data/Climate/AK_CAN_2km/historical/AR5_CMIP5_models'\n                    else:\n                        old_dir = '/Data/Base_Data/Climate/AK_CAN_2km/projected/AR5_CMIP5_models'\n                    figsize = (16, 9)\n                    out = {}\n                    for v in variables:\n                        path = os.path.join(base_dir, 'downscaled', m, scenario, v)\n                        print(path)\n                        files = glob.glob(os.path.join(path, '*.tif'))\n                        files = sort_files(only_years(files, begin=begin, end=end, split_on='_', elem_year=-1))\n                        out[v] = mp_map(masked_mean, files, nproc=4)\n                        if v == 'tas' or v == 'pr':\n                            if m == 'ts323':\n                                path = os.path.join(old_dir, v)\n                                print(path)\n                            else:\n                                path = os.path.join(old_dir, scenario, m, v)\n                            files = glob.glob(os.path.join(path, '*.tif'))\n                            files = sort_files(only_years(files, begin=begin, end=end, split_on='_', elem_year=-1))\n                            out[v + '_old'] = mp_map(masked_mean, files, nproc=4)\n                            path = os.path.join(base_dir, 'downscaled_pr_nofix', m, scenario, v)\n                            print(path)\n                            files = glob.glob(os.path.join(path, '*.tif'))\n                            files = sort_files(only_years(files, begin=begin, end=end, split_on='_', elem_year=-1))\n                            out[v + '_nofix'] = mp_map(masked_mean, files, nproc=4)\n                    plot_df = pd.DataFrame(out)\n                    plot_df.index = pd.date_range(start=str(begin), end=str(end + 1), freq='M')\n                    if 'tas' in variables:\n                        col_list = ['tasmax', 'tas_old', 'tas', 'tasmin']\n                    elif 'pr' in variables:\n                        col_list = ['pr', 'pr_old', 'pr_nofix']\n                    plot_df = plot_df[col_list]\n                    if v == 'pr':\n                        plot_df = plot_df.round()[['pr', 'pr_old']]\n                    if begin == end:\n                        title = 'EPSCoR SC AOI Temp Metrics {} {} {}'.format(m, scenario, begin)\n                    else:\n                        title = 'EPSCoR SC AOI Temp Metrics {} {} {} - {}'.format(m, scenario, begin, end)\n                    if 'tas' in variables:\n                        colors = ['red', 'black', 'blue', 'red']\n                    else:\n                        colors = ['blue', 'black', 'darkred']\n                    ax = plot_df.plot(kind='line', title=title, figsize=figsize, color=colors)\n                    output_dir = os.path.join(base_dir, 'compare_downscaling_versions_PR_no_fix')\n                    if not os.path.exists(output_dir):\n                        os.makedirs(output_dir)\n                    out_metric_fn = 'temps'\n                    if 'pr' in variables:\n                        out_metric_fn = 'prec'\n                    if begin == end:\n                        output_filename = os.path.join(output_dir, 'mean_{}_epscor_sc_{}_{}_{}.png'.format(out_metric_fn, m, scenario, begin))\n                    else:\n                        output_filename = os.path.join(output_dir, 'mean_{}_epscor_sc_{}_{}_{}_{}.png'.format(out_metric_fn, m, scenario, begin, end))\n                    plt.savefig(output_filename, dpi=400)\n                    plt.close()",
  "line_no": 6,
  "line_no_percent": "3%"
}