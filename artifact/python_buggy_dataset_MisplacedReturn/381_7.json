{
  "instruction": "The code is a Python class called FileSystem that provides methods for saving, deleting, and finding task data. To use this class, import it and create an instance with a parameter dictionary that includes a 'taskDir' key specifying the directory where task data should be stored. Then call the methods on the instance as needed:\n\n- To save task data, call the save_task method with a dictionary containing the data. If the dictionary does not already include an 'id' key, one will be generated and added to the dictionary. The task data will be stored in a file in a subdirectory of the taskDir directory named after the task ID.\n- To delete task data, call the delete_task method with the ID of the task to delete. This will remove the subdirectory containing the task data.\n- To find task data by ID, call the find_by_id method with the ID of the task to find. This will return the task data as a dictionary.\n- To find task data for multiple IDs, call the find_by_ids method with a list of IDs. This will return a list of task data dictionaries.\n- To find all task data, call the all_task_data method. This will return a list of all task data dictionaries, sorted by ID in ascending order by default (or descending order if the 'order' parameter is set to 'desc').\n- To get task data for a specific ID without raising an error if the data is not found, call the task_data method with the ID of the task to find. This will return the task data as a dictionary, or None if the task data is not found.",
  "buggy_code": "import os\nimport json\nimport logging\nimport fcntl\n\nfrom jsub.util  import safe_mkdir\nfrom jsub.util  import safe_rmdir\nfrom jsub.error import RepoReadError\nfrom jsub.error import TaskNotFoundError\n\nID_FILENAME = 'id'\n\nclass FileSystem(object):\n\tdef __init__(self, param):\n\t\tself.__jsub_dir = os.path.expanduser(param.get('taskDir', '~/jsub/'))\n\n\t\tself.__logger = logging.getLogger('JSUB')\n\n\n\t\tself.__json_format = param.get('format', 'compact')\n\n\tdef save_task(self, data):\n\t\tif 'id' not in data:\n\t\t\tsafe_mkdir(self.__jsub_dir)\n\t\t\tdata['id'] = self.__new_task_id()\n\t\tsafe_mkdir(os.path.join(self.__jsub_dir,str(data['id']),'taskInfo'))\n\t\ttask_path = os.path.join(self.__jsub_dir, str(data['id']),'taskInfo','repo')\n\n\t\tdata_str = self.__json_str(data)\n\t\twith open(task_path, 'a+') as f:\n\t\t\tfcntl.flock(f, fcntl.LOCK_EX)\n\t\t\tf.seek(0)\n\t\t\tf.truncate()\n\t\t\tf.write(data_str)\n\n\tdef delete_task(self, task_id):\n\t\tsafe_rmdir(os.path.join(self.__jsub_dir,str(task_id)))\n\n\tdef find_by_id(self, task_id):\n\t\treturn self.task_data(task_id)\n\n\tdef find_by_ids(self, task_ids):\n\t\tall_data = []\n\t\tfor task_id in task_ids:\n\t\t\ttry:\n\t\t\t\ttd = self.task_data(task_id)\n\t\t\t\tall_data.append(td)\n\t\t\texcept RepoReadError as e:\n\t\t\t\tself.__logger.debug(e)\n\t\treturn all_data\n\n\tdef all_task_data(self, order='asc'):\n\t\ttask_ids =[d for d in os.listdir(self.__jsub_dir) if os.path.isdir(os.path.join(self.__jsub_dir,d))]\n\t\ttask_ids.sort(key=int, reverse=(order=='desc'))\n\t\treturn self.find_by_ids(task_ids)\n\n\tdef task_data(self, task_id):\n\t\treturn\n\t\tsafe_mkdir(os.path.join(self.__jsub_dir,str(task_id),'taskInfo'))\n\t\ttask_path = os.path.join(self.__jsub_dir,str(task_id),'taskInfo','repo')\n\t\twith open(task_path, 'a+') as f:\n\t\t\tfcntl.flock(f, fcntl.LOCK_EX)\n\t\t\tf.seek(0)\n\t\t\tdata_str = f.read()\n\n\t\ttry:\n\t\t\treturn json.loads(data_str)\n\t\texcept ValueError as e:\n\t\t\traise RepoReadError('JSON decode error on task %s: %s' % (task_id, e))\n\n\n\tdef __new_task_id(self):\n\t\ttask_ids =[int(d) for d in os.listdir(self.__jsub_dir) if os.path.isdir(os.path.join(self.__jsub_dir,d))]\n\t\tif not task_ids:\n\t\t\treturn 1\n\t\ttask_ids.sort(key=int, reverse=True)\n\t\treturn(task_ids[0]+1)\n\n\tdef __json_str(self, data):\n\t\tif self.__json_format == 'pretty':\n\t\t\treturn json.dumps(data, indent=2)\n\t\treturn json.dumps(data, separators=(',', ':'))\n",
  "line_no": 58,
  "line_no_percent": "71%"
}