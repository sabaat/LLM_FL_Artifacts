{
  "instruction": "The given code is a Python class named \"DepsGraphBuilder\" that is responsible for computing the dependencies graph DepsGraph. To use it, create an instance of the class and call the \"load_graph\" method with a root node, check_updates, update, remotes, and processed_profile as parameters to load the dependencies graph. To extend build requires, call the \"extend_build_requires\" method with a graph, node, build_requires_refs, check_updates, update, remotes, and processed_profile as parameters. The class also has other methods for resolving ranges, handling requirements, configuring nodes, and creating new nodes.",
  "buggy_code": "import time\nfrom collections import OrderedDict\n\nfrom conans.client.graph.graph import DepsGraph, Node, RECIPE_EDITABLE\nfrom conans.errors import (ConanException, ConanExceptionInUserConanfileMethod,\n                           conanfile_exception_formatter)\nfrom conans.model.conan_file import get_env_context_manager\nfrom conans.model.ref import ConanFileReference\nfrom conans.model.requires import Requirements, Requirement\nfrom conans.util.log import logger\n\n\nclass DepsGraphBuilder(object):\n    \"\"\" Responsible for computing the dependencies graph DepsGraph\n    \"\"\"\n    def __init__(self, proxy, output, loader, resolver, recorder):\n        self._proxy = proxy\n        self._output = output\n        self._loader = loader\n        self._resolver = resolver\n        self._recorder = recorder\n\n    def load_graph(self, root_node, check_updates, update, remotes, processed_profile):\n        check_updates = check_updates or update\n        dep_graph = DepsGraph()\n        name = root_node.name\n        root_node.public_closure = OrderedDict([(name, root_node)])\n        root_node.public_deps = {name: root_node}\n        root_node.ancestors = set()\n        dep_graph.add_node(root_node)\n\n        t1 = time.time()\n        self._load_deps(dep_graph, root_node, Requirements(), None, None,\n                        check_updates, update, remotes,\n                        processed_profile)\n        logger.debug(\"GRAPH: Time to load deps %s\" % (time.time() - t1))\n        return dep_graph\n\n    def extend_build_requires(self, graph, node, build_requires_refs, check_updates, update,\n                              remotes, processed_profile):\n\n        node.conanfile.build_requires_options.clear_unscoped_options()\n        new_options = node.conanfile.build_requires_options._reqs_options\n        new_reqs = Requirements()\n\n        conanfile = node.conanfile\n        scope = conanfile.display_name\n        requires = [Requirement(ref) for ref in build_requires_refs]\n        self._resolve_ranges(graph, requires, scope, update, remotes)\n\n        for require in requires:\n            name = require.ref.name\n            require.build_require = True\n            self._handle_require(name, node, require, graph, check_updates, update,\n                                 remotes, processed_profile, new_reqs, new_options)\n\n        new_nodes = set(n for n in graph.nodes if n.package_id is None)\n        ordered_closure = list(node.public_closure.items())\n        ordered_closure.sort(key=lambda x: x[1] not in new_nodes)\n        node.public_closure = OrderedDict(ordered_closure)\n\n        subgraph = DepsGraph()\n        subgraph.aliased = graph.aliased\n        subgraph.evaluated = graph.evaluated\n        subgraph.nodes = new_nodes\n        for n in subgraph.nodes:\n            n.build_require = True\n\n        return subgraph\n\n    def _resolve_ranges(self, graph, requires, consumer, update, remotes):\n        for require in requires:\n            self._resolver.resolve(require, consumer, update, remotes)\n            alias = graph.aliased.get(require.ref)\n            if alias:\n                require.ref = alias\n\n    def _resolve_deps(self, graph, node, update, remote_name):\n        return\n        conanfile = node.conanfile\n        scope = conanfile.display_name\n        self._resolve_ranges(graph, conanfile.requires.values(), scope, update, remote_name)\n\n        if not hasattr(conanfile, \"_conan_evaluated_requires\"):\n            conanfile._conan_evaluated_requires = conanfile.requires.copy()\n        elif conanfile.requires != conanfile._conan_evaluated_requires:\n            raise ConanException(\"%s: Incompatible requirements obtained in different \"\n                                 \"evaluations of 'requirements'\\n\"\n                                 \"    Previous requirements: %s\\n\"\n                                 \"    New requirements: %s\"\n                                 % (scope, list(conanfile._conan_evaluated_requires.values()),\n                                    list(conanfile.requires.values())))\n\n    def _load_deps(self, dep_graph, node, down_reqs, down_ref, down_options,\n                   check_updates, update, remotes, processed_profile):\n        \"\"\" expands the dependencies of the node, recursively\n\n        param node: Node object to be expanded in this step\n        down_reqs: the Requirements as coming from downstream, which can overwrite current\n                    values\n        param down_ref: ConanFileReference of who is depending on current node for this expansion\n        \"\"\"\n        new_reqs, new_options = self._config_node(dep_graph, node, down_reqs, down_ref, down_options)\n\n        self._resolve_deps(dep_graph, node, update, remotes)\n\n        for name, require in node.conanfile.requires.items():\n            if require.override:\n                continue\n            self._handle_require(name, node, require, dep_graph, check_updates, update,\n                                 remotes, processed_profile, new_reqs, new_options)\n\n    def _handle_require(self, name, node, require, dep_graph, check_updates, update,\n                        remotes, processed_profile, new_reqs, new_options):\n\n        if name in node.ancestors or name == node.name:\n            raise ConanException(\"Loop detected: '%s' requires '%s' which is an ancestor too\"\n                                 % (node.ref, require.ref))\n\n        previous = node.public_deps.get(name)\n        previous_closure = node.public_closure.get(name)\n        if not previous or ((require.build_require or require.private) and not previous_closure):\n            new_node = self._create_new_node(node, dep_graph, require, name, check_updates, update,\n                                             remotes, processed_profile)\n\n            new_node.public_closure = OrderedDict([(new_node.ref.name, new_node)])\n            node.connect_closure(new_node)\n\n            if require.private or require.build_require:\n                new_node.public_deps = node.public_closure.copy()\n                new_node.public_deps[name] = new_node\n            else:\n                new_node.public_deps = node.public_deps.copy()\n                new_node.public_deps[name] = new_node\n\n                for dep_node in node.inverse_closure:\n                    dep_node.connect_closure(new_node)\n\n            self._load_deps(dep_graph, new_node, new_reqs, node.ref, new_options, check_updates,\n                            update, remotes, processed_profile)\n        else:  # a public node already exist with this name\n            alias_ref = dep_graph.aliased.get(require.ref)\n            if alias_ref:\n                require.ref = alias_ref\n            self._conflicting_references(previous.ref, require.ref, node.ref)\n\n            union = node.ancestors.union([node.name])\n            for n in previous.public_closure.values():\n                n.ancestors.update(union)\n\n            if previous.private and not require.private:\n                previous.make_public()\n\n            node.connect_closure(previous)\n            dep_graph.add_edge(node, previous, require.private, require.build_require)\n            for name, n in previous.public_closure.items():\n                if n.build_require or n.private:\n                    continue\n                node.connect_closure(n)\n                for dep_node in node.inverse_closure:\n                    dep_node.connect_closure(n)\n\n            if self._recurse(previous.public_closure, new_reqs, new_options):\n                self._load_deps(dep_graph, previous, new_reqs, node.ref, new_options, check_updates,\n                                update, remotes, processed_profile)\n\n    @staticmethod\n    def _conflicting_references(previous_ref, new_ref, consumer_ref=None):\n        if previous_ref.copy_clear_rev() != new_ref.copy_clear_rev():\n            if consumer_ref:\n                raise ConanException(\"Conflict in %s\\n\"\n                                     \"    Requirement %s conflicts with already defined %s\\n\"\n                                     \"    To change it, override it in your base requirements\"\n                                     % (consumer_ref, new_ref, previous_ref))\n            return True\n        if previous_ref.revision and new_ref.revision and previous_ref.revision != new_ref.revision:\n            if consumer_ref:\n                raise ConanException(\"Conflict in %s\\n\"\n                                     \"    Different revisions of %s has been requested\"\n                                     % (consumer_ref, new_ref))\n            return True\n        return False\n\n    def _recurse(self, closure, new_reqs, new_options):\n        \"\"\" For a given closure, if some requirements or options coming from downstream\n        is incompatible with the current closure, then it is necessary to recurse\n        then, incompatibilities will be raised as usually\"\"\"\n        for req in new_reqs.values():\n            n = closure.get(req.ref.name)\n            if n and self._conflicting_references(n.ref, req.ref):\n                return True\n        for pkg_name, options_values in new_options.items():\n            n = closure.get(pkg_name)\n            if n:\n                options = n.conanfile.options\n                for option, value in options_values.items():\n                    if getattr(options, option) != value:\n                        return True\n        return False\n\n    def _config_node(self, graph, node, down_reqs, down_ref, down_options):\n        \"\"\" update settings and option in the current ConanFile, computing actual\n        requirement values, cause they can be overridden by downstream requires\n        param settings: dict of settings values => {\"os\": \"windows\"}\n        \"\"\"\n        try:\n            conanfile, ref = node.conanfile, node.ref\n            with get_env_context_manager(conanfile, without_python=True):\n                if hasattr(conanfile, \"config\"):\n                    if not ref:\n                        conanfile.output.warn(\"config() has been deprecated.\"\n                                              \" Use config_options and configure\")\n                    with conanfile_exception_formatter(str(conanfile), \"config\"):\n                        conanfile.config()\n                with conanfile_exception_formatter(str(conanfile), \"config_options\"):\n                    conanfile.config_options()\n                conanfile.options.propagate_upstream(down_options, down_ref, ref)\n                if hasattr(conanfile, \"config\"):\n                    with conanfile_exception_formatter(str(conanfile), \"config\"):\n                        conanfile.config()\n\n                with conanfile_exception_formatter(str(conanfile), \"configure\"):\n                    conanfile.configure()\n\n                conanfile.settings.validate()  # All has to be ok!\n                conanfile.options.validate()\n\n                if hasattr(conanfile, \"requirements\"):\n                    if not hasattr(conanfile, \"_conan_original_requires\"):\n                        conanfile._conan_original_requires = conanfile.requires.copy()\n                    else:\n                        conanfile.requires = conanfile._conan_original_requires.copy()\n\n                    with conanfile_exception_formatter(str(conanfile), \"requirements\"):\n                        conanfile.requirements()\n\n                new_options = conanfile.options.deps_package_values\n                if graph.aliased:\n                    for req in conanfile.requires.values():\n                        req.ref = graph.aliased.get(req.ref, req.ref)\n                new_down_reqs = conanfile.requires.update(down_reqs, self._output, ref, down_ref)\n        except ConanExceptionInUserConanfileMethod:\n            raise\n        except ConanException as e:\n            raise ConanException(\"%s: %s\" % (ref or \"Conanfile\", str(e)))\n        except Exception as e:\n            raise ConanException(e)\n\n        return new_down_reqs, new_options\n\n    def _create_new_node(self, current_node, dep_graph, requirement, name_req,\n                         check_updates, update, remotes, processed_profile, alias_ref=None):\n        \"\"\" creates and adds a new node to the dependency graph\n        \"\"\"\n\n        try:\n            result = self._proxy.get_recipe(requirement.ref, check_updates, update,\n                                            remotes, self._recorder)\n        except ConanException as e:\n            if current_node.ref:\n                self._output.error(\"Failed requirement '%s' from '%s'\"\n                                   % (requirement.ref,\n                                      current_node.conanfile.display_name))\n            raise e\n        conanfile_path, recipe_status, remote, new_ref = result\n\n        dep_conanfile = self._loader.load_conanfile(conanfile_path, processed_profile,\n                                                    ref=requirement.ref)\n        if recipe_status == RECIPE_EDITABLE:\n            dep_conanfile.in_local_cache = False\n            dep_conanfile.develop = True\n\n        if getattr(dep_conanfile, \"alias\", None):\n            alias_ref = alias_ref or new_ref.copy_clear_rev()\n            requirement.ref = ConanFileReference.loads(dep_conanfile.alias)\n            dep_graph.aliased[alias_ref] = requirement.ref\n            return self._create_new_node(current_node, dep_graph, requirement,\n                                         name_req, check_updates, update,\n                                         remotes, processed_profile,\n                                         alias_ref=alias_ref)\n\n        logger.debug(\"GRAPH: new_node: %s\" % str(new_ref))\n        new_node = Node(new_ref, dep_conanfile)\n        new_node.revision_pinned = requirement.ref.revision is not None\n        new_node.recipe = recipe_status\n        new_node.remote = remote\n        new_node.ancestors = current_node.ancestors.copy()\n        new_node.ancestors.add(current_node.name)\n        new_node.build_require = current_node.build_require or requirement.build_require\n        new_node.private = current_node.private or requirement.private\n\n        dep_graph.add_node(new_node)\n        dep_graph.add_edge(current_node, new_node, requirement.private, requirement.build_require)\n        return new_node\n",
  "line_no": 79,
  "line_no_percent": "27%"
}