{
  "instruction": "Create a TopicItem object with the given parameters: logger, seuid, first_message, and parent. The TopicItem represents a specific topic which contains many connections and has attributes like the number of sent messages. It has methods to get the child at a specific position, get the number of children, get all children, get the latest data, get detailed data, get plotable items, get short data, and get time items. It also has a timer that aggregates the topic every TOPIC_AGGREGATION_FREQUENCY nsecs and pushes the updated data to self.__calculated_data.",
  "buggy_code": "from rospy.rostime import Time\nimport rospy\n\nfrom python_qt_binding.QtCore import QTranslator\n\nfrom abstract_item import AbstractItem\nfrom helper_functions import prepare_number_for_representation, UPDATE_FREQUENCY, TOPIC_AGGREGATION_FREQUENCY, \\\n    ROUND_DIGITS, MAXIMUM_OFFLINE_TIME\nfrom arni_core.helper import SEUID, SEUID_DELIMITER\nfrom node_item import NodeItem\n\nfrom rospy.timer import Timer\nfrom rospy.impl.tcpros_service import ServiceProxy\nfrom rospy.rostime import Duration\nfrom rospy.rostime import Time\nfrom connection_item import ConnectionItem\n\n\nimport re\n\nclass TopicItem(AbstractItem):\n    \"\"\"\n    A TopicItem represents a specific topic which contains many connections and has attributes like the number of sent messages.\n    \"\"\"\n\n    def __init__(self, logger, seuid, first_message, parent=None):\n        \"\"\"Initializes the TopicItem.\n        \n        :param seuid: the seuid of the item\n        :type seuid: str\n        :param logger: a logger where to log when special events occur\n        :type logger: ModelLogger\n        :param parent: the parent-item\n        :type parent: AbstractItem\n        \"\"\"\n        AbstractItem.__init__(self, logger, seuid, parent)\n        self.__parent = parent\n        self._type = \"topic\"\n\n        self.add_keys=[\"dropped_msgs\", \"traffic\", \"bandwidth\", \"frequency\"]\n        self.avg_keys=[\"period_mean\", \"period_stddev\", \"stamp_age_mean\", \"stamp_age_stddev\"]\n        self.max_keys=[\"period_max\", \"stamp_age_max\"]\n\n        self._attributes = []\n        self._attributes.extend([\"dropped_msgs\", \"traffic\",\n                                 \"period_mean\", \"period_stddev\", \"period_max\", \"stamp_age_mean\",\n                                 \"stamp_age_stddev\", \"stamp_age_max\", \"bandwidth\", \"frequency\"])\n\n        for item in self._attributes:\n            self._add_data_list(item)\n\n        self.__calculated_data = {}\n        for key in self._attributes:\n            self.__calculated_data[key] = []\n\n        self.__calculated_data[\"window_stop\"] = []\n        self.__calculated_data[\"window_start\"] = []\n\n        for item in self._attributes:\n            self._rated_attributes.append(item + \".actual_value\")\n            self._rated_attributes.append(item + \".expected_value\")\n            self._rated_attributes.append(item + \".state\")\n\n        for item in self._rated_attributes:\n            self._add_rated_data_list(item)\n\n        self._logger.log(\"info\", Time.now(), seuid, \"Created a new TopicItem\")\n\n        self.__timer = Timer(Duration(nsecs=TOPIC_AGGREGATION_FREQUENCY), self.__aggregate_topic_data)\n\n        self.tree_items = []\n        self.__aggregation_window = rospy.get_param(\"~aggregation_window\", 5)\n\n\n\n    def get_child(self, row, parent=None):\n        return\n        \"\"\"\n        Returns the child at the position row.\n\n        :param row: the index of the row\n        :type row: int\n        :param parent: the model parent at the given index (not global / logical parent)\n        :type parent: NodeItem\n\n        :returns: the child at the position row\n        :rtype: AbstractItem\n        \"\"\"\n        if not isinstance(parent, NodeItem):\n            print(type(parent))\n            raise UserWarning\n        return self.__get_local_childs(parent)[row]\n\n    def __get_local_childs(self, parent=None):\n        \"\"\"\n        Returns all childs of the topic item at the given position in the gui.\n\n        :param parent: the model parent at the given index (not global / logical parent)\n        :type parent: NodeItem\n        :param sub_activated: Defines if subscriber shall be shown too.\n        :returns: the child at the position row\n        :rtype: AbstractItem\n        \"\"\"\n        childs = []\n        if parent is not None:\n            seuid = parent.get_seuid()\n\n            seuid_helper = SEUID()\n            seuid_helper.identifier = seuid\n            seuid_helper.set_fields()\n            node = seuid_helper.node\n            for child in self.get_childs():\n                child_seuid = child.get_seuid()\n                seuid_helper.identifier = child_seuid\n                seuid_helper.set_fields()\n                node_comp = seuid_helper.publisher\n                if node == node_comp:\n                    childs.append(child)\n                    continue\n\n            return childs\n        else:\n            return self._child_items\n\n    def row(self, parent=None):\n        \"\"\"\n        Returns the index of the Item.\n\n        :returns: the index of the Item\n        :rtype: int\n        \"\"\"\n        if parent:\n            return parent.get_childs().index(self)\n        elif self.__parent:\n            return self.__parent.get_childs().index(self)\n\n\n    def child_count(self, parent=None):\n        \"\"\"\n        Returns the number of children from the AbstractItem.\n\n        :returns: number of childs\n        :rtype: int\n        \"\"\"\n        return len(self.__get_local_childs(parent))\n\n    def get_childs(self, parent=None):\n        \"\"\"\n        Returns a list with all children.\n        WARNING: This is the same method as in AbstractItem (superclass) to warn you using this function in the gui\n        context. Topic item shows only some connections depending on the parent node. This is *not* implemented for\n        this function.\n\n        :returns: list of children\n        :rtype: list\n        \"\"\"\n        if parent is not None:\n            return self.__get_local_childs(parent)\n        return self._child_items\n\n\n\n    def get_items_younger_than(self, time, *args):\n        \"\"\"\n        Used to overwrite the standard implementation in AbstractItem. This method provides the data from the\n        calculated data and *not* from the raw input. This is especially wanted when plotting\n        :param time:\n        :param args:\n        :return:\n        \"\"\"\n        self._data_lock.acquire()\n        return_values = {}\n\n        if args:\n            for key in args:\n                return_values[key] = None\n            if \"window_stop\" not in args:\n                return_values[\"window_stop\"] = None\n        else:\n            for key in self.__calculated_data:\n                return_values[key] = None\n\n        breakpoint = 0\n        list_of_time = self.__calculated_data[\"window_stop\"]\n        length = len(list_of_time)\n\n        if length is not 0:\n            if list_of_time[0] >= time:\n                for key in return_values:\n                    try:\n                        return_values[key] = self.__calculated_data[key][:]\n                    except KeyError:\n                        print(\"Accessed key was: \" + key + \". Available keys are: \")\n                        print(self.__calculated_data)\n                        raise\n            else:\n                for i in range(length - 1, -1, -1):\n                    if list_of_time[i] < time:\n                        breakpoint = i + 1\n                        for key in return_values:\n                            if key in self.__calculated_data:\n                                return_values[key] = self.__calculated_data[key][breakpoint:length]\n                            else:\n                                raise IndexError(\"IndexError! length of the list %s, accessed index %s. length of data\"\n                                                 \" at given point %s, key is %s\", length, i,\n                                                 len(self.__calculated_data[key]), key)\n                        break\n\n        self._data_lock.release()\n        return return_values\n\n\n    def get_raw_items_younger_than(self, time, *args):\n        \"\"\"\n        Returns all entries that are younger than time either in all keys of self._data or if args not empty in\n        all key corresponding to args.\n        Warning: Method assumes data is sorted by time if this is not true will return too few or too much data.\n\n        :param time: the lower bound in seconds\n        :type time: rospy.Time\n        :param args: the keys to the dict\n        :type args: str\n\n        :returns: dict of lists\n        :rtype: dict\n        :raises KeyError: if an element in args cannot be found in any of the dictionaries (data vs rated data)\n        \"\"\"\n        return_values = {}\n\n        if args:\n            for key in args:\n                return_values[key] = None\n            if \"window_stop\" not in args:\n                return_values[\"window_stop\"] = None\n        else:\n            for key in self._data:\n                return_values[key] = None\n\n        breakpoint = 0\n        list_of_time = self._data[\"window_stop\"]\n        length = len(list_of_time)\n\n        if length is not 0:\n            if list_of_time[0] >= time:\n                for key in return_values:\n                    try:\n                        return_values[key] = self._data[key][:]\n                    except KeyError:\n                        print(\"Accessed key was: \" + key + \". Available keys are: \")\n                        print(self._data)\n                        raise\n            else:\n                for i in range(length - 1, -1, -1):\n                    if list_of_time[i] < time:\n                        breakpoint = i + 1\n                        for key in return_values:\n                            if key in self._data:\n                                return_values[key] = self._data[key][breakpoint:length]\n                            else:\n                                raise IndexError(\"IndexError! length of the list %s, accessed index %s. length of data\"\n                                                 \" at given point %s, key is %s\", length, i, len(self._data[key]), key)\n                        break\n        return return_values\n\n\n    def __aggregate_topic_data(self, event):\n        \"\"\"\n        Aggregates the topic every TOPIC_AGGREGATION_FREQUENCY nsecs and pushes the updated data to\n        self.__calculated_data.\n\n        :param event: containing information when this method was called - not used but needed for the interface\n        \"\"\"\n        aggregated_data = {}\n        for key in self._attributes:\n            aggregated_data[key] = 0\n\n        for key in self.__calculated_data.keys():\n             self.__calculated_data[key].append(0)\n\n        child_count = 0\n        for connection in self.get_childs():  # !assuming all childs are connection items!\n            values = connection.aggregate_data(self.__aggregation_window)  # average over N seconds\n\n            if values:\n                for key in self.add_keys:\n                     aggregated_data[key] += values[key]\n                for key in self.max_keys:\n                    if values[key] > aggregated_data[key]:\n                         aggregated_data[key] = values[key]\n                for key in self.avg_keys:\n                     aggregated_data[key] += values[key]\n                child_count += 1\n\n\n        for key in self.avg_keys:\n            if child_count == 0:\n                aggregated_data[key] = 0\n            else:\n                aggregated_data[key] /= child_count\n\n        self._data_lock.acquire()\n\n        for key in self._attributes:\n            self.__calculated_data[key][-1] = aggregated_data[key]\n\n        self.__calculated_data[\"window_start\"][-1] = Time.now()\n        self.__calculated_data[\"window_stop\"][-1] = Time.now() - (Duration(secs=1) if int(Duration(secs=1).to_sec()) <= int(Time.now().to_sec()) else Time(0))\n\n\n        self._data_lock.release()\n\n\n    def execute_action(self, action):\n        \"\"\"\n        Not senseful, Topics cannot execute actions.\n\n        :param action: action to be executed\n        :type action: RemoteAction\n        \"\"\"\n        pass\n\n\n    def get_detailed_data(self):\n        \"\"\"\n        Returns the detailed data of the HostItem.\n\n        :returns: detailed data\n        :rtype: str\n        \"\"\"\n        data_dict = self.get_latest_data()\n        for key in self.__calculated_data:\n            if self.__calculated_data[key]:\n                data_dict[key] = self.__calculated_data[key][-1]\n            else:\n                data_dict[key] = self.tr(\"Currently no value available\")\n\n        data_dict[\"state\"] = self.get_state()\n\n        content = \"<p class=\\\"detailed_data\\\">\"\n\n        content += self.get_erroneous_entries()\n\n        content += \"Rounded to a second:<br>\"\n\n        if \"frequency\" in self._attributes:\n            content += self.tr(\"frequency\") + \": \" + prepare_number_for_representation(data_dict[\"frequency\"]) \\\n                   + \" \" + self.tr(\"frequency_unit\") + \" <br>\"\n        content += self.tr(\"bandwidth\") + \": \" + prepare_number_for_representation(data_dict[\"bandwidth\"]) \\\n                   + \" \" + self.tr(\"bandwidth_unit\") + \" <br>\"\n\n        content += self.tr(\"dropped_msgs\") + \": \" + prepare_number_for_representation(data_dict[\"dropped_msgs\"]) \\\n                   + \" \" + self.tr(\"dropped_msgs_unit\") + \" <br>\"\n        content += self.tr(\"period_max\") + \": \" + prepare_number_for_representation(data_dict[\"period_max\"]) \\\n                   + \" \" + self.tr(\"period_max_unit\") + \" <br>\"\n        content += self.tr(\"stamp_age_max\") + \": \" + prepare_number_for_representation(data_dict[\"stamp_age_max\"]) \\\n                   + \" \" + self.tr(\"stamp_age_max_unit\") + \" <br>\"\n\n        content += \"</p>\"\n        return content\n\n\n    def get_plotable_items(self):\n        \"\"\"\n        Returns items for the plot.\n\n        :returns: str[]\n        \"\"\"\n        if \"frequency\" in self.__calculated_data:\n            return [\"dropped_msgs\",\"stamp_age_max\", \"period_max\",\n                    \"bandwidth\", \"frequency\"]\n\n        else:\n            return [\"dropped_msgs\", \"traffic\", \"stamp_age_max\", \"period_max\", \"bandwidth\"]\n\n\n    def get_short_data(self):\n        \"\"\"\n        Returns a shortend version of the item data.\n\n        :returns: data of the item\n        :rtype: str\n        \"\"\"\n        data_dict = {}\n        for key in self.__calculated_data:\n            if self.__calculated_data[key]:\n                data_dict[key] = self.__calculated_data[key][-1]\n            else:\n                data_dict[key] = self.tr(\"Currently no value available\")\n                data_dict[\"window_stop\"] = Time(0)\n                data_dict[\"window_start\"] = Time(0)\n\n        data_dict[\"state\"] = self.get_state()\n\n        try:\n            if data_dict[\"window_stop\"] == Time(0):\n                return \"No data yet\"\n            elif (Time.now() - data_dict[\"window_stop\"]) > Duration(MAXIMUM_OFFLINE_TIME):\n                return \"No data since \" + prepare_number_for_representation(Time.now() - data_dict[\"window_stop\"]) \\\n                       + \" seconds\"\n        except:\n            print(data_dict[\"window_stop\"])\n            raise UserWarning\n\n\n        content = \"\"\n        if data_dict[\"state\"] is \"error\":\n            content += self.get_erroneous_entries_for_log()\n        else:\n            content += self.tr(\"frequency\") + \": \" + prepare_number_for_representation(\n                data_dict[\"frequency\"]) + \" \" \\\n                       + self.tr(\"frequency_unit\") + \" - \"\n            content += self.tr(\"bandwidth\") + \": \" + prepare_number_for_representation(data_dict[\"bandwidth\"]) \\\n                       + \" \" + self.tr(\"bandwidth_unit\") + \" - \"\n            content += self.tr(\"dropped_msgs\") + \": \" + prepare_number_for_representation(data_dict[\"dropped_msgs\"]) \\\n                       + \" \" + self.tr(\"dropped_msgs_unit\")\n\n        return content\n\n\n    def can_execute_actions(self):\n        \"\"\"\n        This item cannot execute actions, so it returns False\n\n        :return: False\n        \"\"\"\n        return False\n\n\n    def get_list_items(self):\n        return []\n\n\n    def get_time_items(self):\n        return [\"stamp_age_mean\", \"stamp_age_max\"]\n",
  "line_no": 77,
  "line_no_percent": "18%"
}