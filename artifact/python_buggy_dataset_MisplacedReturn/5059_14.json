{
  "instruction": "Convert hierarchical xml files to csv using Python. The code takes in an input file or port and converts the xml file to csv format. It only makes sense if the hierarchy has low depth. The output can be split into different files for the first hierarchy level using the -p or --split option. The output file name can be specified using the -o or --output option. The separating character for fields can be specified using the -s or --separator option, and the quoting character for fields can be specified using the -q or --quotechar option. The code also supports schema validation using an xsd schema specified using the -x or --xsd option and the -a or --validation option.",
  "buggy_code": "\"\"\"\n@file    xml2csv.py\n@author  Jakob Erdmann\n@author  Michael Behrisch\n@author  Laura Bieker\n@date    2013-12-08\n@version $Id: xml2csv.py 22608 2017-01-17 06:28:54Z behrisch $\n\nConvert hierarchical xml files to csv. This only makes sense if the hierarchy has low depth.\n\nSUMO, Simulation of Urban MObility; see http://sumo.dlr.de/\nCopyright (C) 2013-2017 DLR (http://www.dlr.de/) and contributors\n\nThis file is part of SUMO.\nSUMO is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 3 of the License, or\n(at your option) any later version.\n\"\"\"\n\nfrom __future__ import print_function\nfrom __future__ import absolute_import\nimport os\nimport sys\nimport socket\nimport collections\nfrom optparse import OptionParser\nimport xml.sax\ntry:\n    import lxml.etree\n    import lxml.sax\n    haveLxml = True\nexcept ImportError:\n    haveLxml = False\n\nimport xsd\n\nPY3 = sys.version_info > (3,)\n\n\nclass NestingHandler(xml.sax.handler.ContentHandler):\n\n    \"\"\"A handler which knows the current nesting of tags\"\"\"\n\n    def __init__(self):\n        self.tagstack = []\n\n    def startElement(self, name, attrs):\n        self.tagstack.append(name)\n\n    def endElement(self, name):\n        self.tagstack.pop()\n\n    def depth(self):\n        return len(self.tagstack) - 1\n\n\nclass AttrFinder(NestingHandler):\n\n    def __init__(self, xsdFile, source, split):\n        NestingHandler.__init__(self)\n        self.tagDepths = {}  # tag -> depth of appearance\n        self.tagAttrs = collections.defaultdict(\n            collections.OrderedDict)  # tag -> set of attrs\n        self.renamedAttrs = {}  # (name, attr) -> renamedAttr\n        self.attrs = {}\n        self.depthTags = {}  # child of root: depth of appearance -> tag list\n        self.rootDepth = 1 if split else 0\n        if xsdFile:\n            self.xsdStruc = xsd.XsdStructure(xsdFile)\n            if split:\n                for ele in self.xsdStruc.root.children:\n                    self.attrs[ele.name] = []\n                    self.depthTags[ele.name] = [[]]\n                    self.recursiveAttrFind(ele, ele, 1)\n            else:\n                self.attrs[self.xsdStruc.root.name] = []\n                self.depthTags[self.xsdStruc.root.name] = []\n                self.recursiveAttrFind(\n                    self.xsdStruc.root, self.xsdStruc.root, 0)\n        else:\n            self.xsdStruc = None\n            xml.sax.parse(source, self)\n\n    def addElement(self, root, name, depth):\n        if name not in self.tagDepths:\n            if len(self.depthTags[root]) == depth:\n                self.tagDepths[name] = depth\n                self.depthTags[root].append([])\n            self.depthTags[root][depth].append(name)\n            return True\n        if name not in self.depthTags[root][depth]:\n            print(\"Ignoring tag %s at depth %s\" %\n                  (name, depth), file=sys.stderr)\n        return False\n\n    def recursiveAttrFind(self, root, currEle, depth):\n        if not self.addElement(root.name, currEle.name, depth):\n            return\n        for a in currEle.attributes:\n            if \":\" not in a.name:  # no namespace support yet\n                self.tagAttrs[currEle.name][a.name] = a\n                anew = \"%s_%s\" % (currEle.name, a.name)\n                self.renamedAttrs[(currEle.name, a.name)] = anew\n                attrList = self.attrs[root.name]\n                if anew in attrList:\n                    del attrList[attrList.index(anew)]\n                attrList.append(anew)\n        for ele in currEle.children:\n            self.recursiveAttrFind(root, ele, depth + 1)\n\n    def startElement(self, name, attrs):\n        NestingHandler.startElement(self, name, attrs)\n        if self.depth() >= self.rootDepth:\n            root = self.tagstack[self.rootDepth]\n            if self.depth() == self.rootDepth and root not in self.attrs:\n                self.attrs[root] = []\n                self.depthTags[root] = [[]] * self.rootDepth\n            if not self.addElement(root, name, self.depth()):\n                return\n            for a in sorted(list(attrs.keys())):\n                if a not in self.tagAttrs[name] and \":\" not in a:\n                    self.tagAttrs[name][a] = xsd.XmlAttribute(a)\n                    if not (name, a) in self.renamedAttrs:\n                        anew = \"%s_%s\" % (name, a)\n                        self.renamedAttrs[(name, a)] = anew\n                        self.attrs[root].append(anew)\n\n\nclass CSVWriter(NestingHandler):\n\n    def __init__(self, attrFinder, options):\n        NestingHandler.__init__(self)\n        self.attrFinder = attrFinder\n        self.options = options\n        self.currentValues = collections.defaultdict(lambda: \"\")\n        self.haveUnsavedValues = False\n        self.outfiles = {}\n        self.rootDepth = 1 if options.split else 0\n        for root in sorted(attrFinder.depthTags):\n            if len(attrFinder.depthTags) == 1:\n                if not options.output:\n                    options.output = os.path.splitext(options.source)[0]\n                if not options.output.isdigit() and not options.output.endswith(\".csv\"):\n                    options.output += \".csv\"\n                self.outfiles[root] = getOutStream(options.output)\n            else:\n                if options.output:\n                    outfilename = options.output + \"%s.csv\" % root\n                else:\n                    outfilename = os.path.splitext(\n                        options.source)[0] + \"%s.csv\" % root\n                self.outfiles[root] = open(outfilename, 'w')\n            if (PY3):\n                self.outfiles[root].write(str.encode(\n                    options.separator.join(map(self.quote, attrFinder.attrs[root])) + \"\\n\"))\n            else:\n                self.outfiles[root].write(\n                    options.separator.join(map(self.quote, attrFinder.attrs[root])) + \"\\n\")\n\n    def quote(self, s):\n        return \"%s%s%s\" % (self.options.quotechar, s, self.options.quotechar)\n\n    def startElementNS(self, name, qname, attrs):\n        self.startElement(qname, attrs)\n\n    def endElementNS(self, name, qname):\n        self.endElement(qname)\n\n    def startElement(self, name, attrs):\n        NestingHandler.startElement(self, name, attrs)\n        if self.depth() >= self.rootDepth:\n            root = self.tagstack[self.rootDepth]\n            if name in self.attrFinder.depthTags[root][self.depth()]:\n                for a, v in attrs.items():\n                    if isinstance(a, tuple):\n                        a = a[1]\n                    if a in self.attrFinder.tagAttrs[name]:\n                        if self.attrFinder.xsdStruc:\n                            enum = self.attrFinder.xsdStruc.getEnumeration(\n                                self.attrFinder.tagAttrs[name][a].type)\n                            if enum:\n                                v = enum.index(v)\n                        a2 = self.attrFinder.renamedAttrs.get((name, a), a)\n                        self.currentValues[a2] = v\n                        self.haveUnsavedValues = True\n\n    def endElement(self, name):\n        return\n        if self.depth() >= self.rootDepth:\n            root = self.tagstack[self.rootDepth]\n            if name in self.attrFinder.depthTags[root][self.depth()]:\n                if self.haveUnsavedValues:\n                    if(PY3):\n                        self.outfiles[root].write(str.encode(self.options.separator.join(\n                            [self.quote(self.currentValues[a]) for a in self.attrFinder.attrs[root]]) + \"\\n\"))\n                    else:\n                        self.outfiles[root].write(self.options.separator.join(\n                            [self.quote(self.currentValues[a]) for a in self.attrFinder.attrs[root]]) + \"\\n\")\n                    self.haveUnsavedValues = False\n                for a in self.attrFinder.tagAttrs[name]:\n                    a2 = self.attrFinder.renamedAttrs.get((name, a), a)\n                    del self.currentValues[a2]\n        NestingHandler.endElement(self, name)\n\n\ndef getSocketStream(port, mode='rb'):\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.bind((\"localhost\", port))\n    s.listen(1)\n    conn, addr = s.accept()\n    return conn.makefile(mode)\n\n\ndef getOutStream(output):\n    if output.isdigit():\n        return getSocketStream(int(output), 'wb')\n    return open(output, 'wb')\n\n\ndef get_options():\n    optParser = OptionParser(\n        usage=os.path.basename(sys.argv[0]) + \" [<options>] <input_file_or_port>\")\n    optParser.add_option(\"-s\", \"--separator\", default=\";\",\n                         help=\"separating character for fields\")\n    optParser.add_option(\"-q\", \"--quotechar\", default='',\n                         help=\"quoting character for fields\")\n    optParser.add_option(\"-x\", \"--xsd\", help=\"xsd schema to use\")\n    optParser.add_option(\"-a\", \"--validation\", action=\"store_true\",\n                         default=False, help=\"enable schema validation\")\n    optParser.add_option(\"-p\", \"--split\", action=\"store_true\",\n                         default=False, help=\"split in different files for the first hierarchy level\")\n    optParser.add_option(\"-o\", \"--output\", help=\"base name for output\")\n    options, args = optParser.parse_args()\n    if len(args) != 1:\n        optParser.print_help()\n        sys.exit()\n    if options.validation and not haveLxml:\n        print(\"lxml not available, skipping validation\", file=sys.stderr)\n        options.validation = False\n    if args[0].isdigit():\n        if not options.xsd:\n            print(\"a schema is mandatory for stream parsing\", file=sys.stderr)\n            sys.exit()\n        options.source = getSocketStream(int(args[0]))\n    else:\n        options.source = args[0]\n    if options.output and options.output.isdigit() and options.split:\n        print(\n            \"it is not possible to use splitting together with stream output\", file=sys.stderr)\n        sys.exit()\n    return options\n\n\ndef main():\n    options = get_options()\n    attrFinder = AttrFinder(options.xsd, options.source, options.split)\n    handler = CSVWriter(attrFinder, options)\n    if options.validation:\n        schema = lxml.etree.XMLSchema(file=options.xsd)\n        parser = lxml.etree.XMLParser(schema=schema)\n        tree = lxml.etree.parse(options.source, parser)\n        lxml.sax.saxify(tree, handler)\n    else:\n        xml.sax.parse(options.source, handler)\n\nif __name__ == \"__main__\":\n    main()\n",
  "line_no": 189,
  "line_no_percent": "71%"
}