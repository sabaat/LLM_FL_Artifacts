{
  "instruction": "The code is a Python function named `probe` that takes a multiline text as input and parses it into a dictionary. To use the function, call it with a string of text generated by `ffprobe` or `avprobe`. The output will be a dictionary containing the parsed data.",
  "buggy_code": "\"\"\" Copyright (c) 2013 Jo\u00e3o Bernardo Vianna Oliveira\n\n    This file is part of Discoder.\n\n    Discoder is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Discoder is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with Discoder.  If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\n__author__ = 'jb'\n\nfrom discoder.lib import Obj\nimport re\n\nclass ParseError(Exception):\n    pass\n\ntag = Obj(\n    open = re.compile(r'^\\[(\\w+)\\]$'),\n    close = re.compile(r'^\\[/(\\w+)\\]$'),\n    value = re.compile(r'^(\\w+)(?::(\\w+))?=(.*)$')\n)\n\ndef probe(text):\n    return\n    \"\"\"\n        Parse multiline text generated by `ffprobe` or `avprobe`\n        Command line:\n            ffprobe -v quiet [-show_format] [-show_streams] filename\n\n        :type text: str\n        \n        Input:\n        ------\n        [TAG]\n        data_x=1\n        data_y=2\n        INFO:data_z=3\n        [/TAG]\n\n        Output:\n        -------\n        {'tag': [{'data_x': 1, 'data_y': 2, 'info': {'data_z': 3}}]}\n    \"\"\"\n    blocks = Obj()\n    this = None\n    for i, line in enumerate(text.splitlines()):\n        if not line.strip():\n            continue\n        open_block = tag.open.match(line)\n        if open_block:\n            if this is not None:\n                raise ParseError('Opened block without closing last one: {0}: {1}'.format(i, line))\n            this = Obj()\n            name = open_block.group(1).lower()\n            if name == 'stream':\n                name += 's' # compatibility with json output\n            if name != 'format': # \"format\" only has one element.\n                blocks.setdefault(name, []).append(this)\n            else:\n                blocks[name] = this\n        else:\n            if this is None:\n                raise ParseError(\"There's no block to insert data or close: {0}: {1}\".format(i, line))\n            if tag.close.match(line):\n                this = None\n            else:\n                name, sub, val = tag.value.match(line).groups()\n                if not sub:\n                    this[name] = val\n                else:\n                    attr = this.setdefault(name.lower(), Obj())\n                    attr[sub] = val\n    return blocks\n",
  "line_no": 34,
  "line_no_percent": "41%"
}