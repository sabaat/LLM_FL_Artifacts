{
  "instruction": "Create a Packet class that generates a binary packet from provided init_packet_fields. The class should include a method called generate_packet that returns a string representing the init_packet (in binary). The class should also include a dictionary called init_packet_fields that contains the packet fields. The class should use little endian format with standard sizes for python. The class should include an enum called PacketField that contains the packet field values. The class should include constants for unsigned short, unsigned int, unsigned char, and char array. The class should include a private method called __generate_struct_format_string that generates a struct format string based on keys that are present in init_packet_fields. The class should handle fields that require length and fields that require a specific format.",
  "buggy_code": "from enum import Enum\nimport struct\n\n\nINIT_PACKET_USES_CRC16 = 0\nINIT_PACKET_USES_HASH = 1\nINIT_PACKET_EXT_USES_ECDS = 2 \n\n\nclass PacketField(Enum):\n    PACKET_VERSION = 1\n    COMPRESSION_TYPE = 2\n    DEVICE_TYPE = 3\n    DEVICE_REVISION = 4\n    APP_VERSION = 5\n    REQUIRED_SOFTDEVICES_ARRAY = 6\n    OPT_DATA = 7\n    NORDIC_PROPRIETARY_OPT_DATA_EXT_PACKET_ID = 8\n    NORDIC_PROPRIETARY_OPT_DATA_FIRMWARE_LENGTH = 9\n    NORDIC_PROPRIETARY_OPT_DATA_FIRMWARE_HASH = 10\n    NORDIC_PROPRIETARY_OPT_DATA_FIRMWARE_CRC16 = 11\n    NORDIC_PROPRIETARY_OPT_DATA_INIT_PACKET_ECDS = 12\n\n\nclass Packet(object):\n    \"\"\"\n    Class that implements the INIT packet format.\n    http://developer.nordicsemi.com/nRF51_SDK/doc/7.1.0/s110/html/a00065.html\n    \"\"\"\n\n    UNSIGNED_SHORT = \"H\"\n    UNSIGNED_INT = \"I\"\n    UNSIGNED_CHAR = \"B\"\n    CHAR_ARRAY = \"s\"\n\n    def __init__(self, init_packet_fields):\n        return\n        \"\"\"\n\n            :param init_packet_fields: Dictionary with packet fields\n        \"\"\"\n        self.init_packet_fields = init_packet_fields\n\n    def generate_packet(self):\n        \"\"\"\n        Generates a binary packet from provided init_packet_fields provided in constructor.\n        This version includes the extended data\n\n        :return str: Returns a string representing the init_packet (in binary)\n\n        \"\"\"\n        format_string = self.__generate_struct_format_string()\n        args = []\n\n        for key in sorted(self.init_packet_fields.keys(), key=lambda x: x.value):\n            if key in [PacketField.REQUIRED_SOFTDEVICES_ARRAY,\n                       PacketField.OPT_DATA]:\n                args.append(len(self.init_packet_fields[key]))\n                args.extend(self.init_packet_fields[key])\n            elif key in [PacketField.NORDIC_PROPRIETARY_OPT_DATA_EXT_PACKET_ID]:\n                args.append(self.init_packet_fields[key]) # Extended packet id format\n            elif key in [PacketField.NORDIC_PROPRIETARY_OPT_DATA_FIRMWARE_LENGTH]:\n                args.append(self.init_packet_fields[key]) # Length of firmware image\n            elif key in [PacketField.NORDIC_PROPRIETARY_OPT_DATA_FIRMWARE_CRC16]:\n                args.append(self.init_packet_fields[key])  # CRC-16\n            elif key in [PacketField.NORDIC_PROPRIETARY_OPT_DATA_FIRMWARE_HASH]:\n                args.append(self.init_packet_fields[key])  # SHA-256 hash of firmware image\n            elif key in [PacketField.NORDIC_PROPRIETARY_OPT_DATA_INIT_PACKET_ECDS]:\n                args.append(self.init_packet_fields[key])  # ECDS of base init packet using Curve P-256 amd SHA-256\n            else:\n                args.append(self.init_packet_fields[key])\n\n        return struct.pack(format_string, *args)\n\n    def __generate_struct_format_string(self):\n        format_string = \"<\"  # Use little endian format with standard sizes for python,\n\n        for key in sorted(self.init_packet_fields.keys(), key=lambda x: x.value):\n            if key in [PacketField.PACKET_VERSION,\n                       PacketField.COMPRESSION_TYPE,\n                       PacketField.DEVICE_TYPE,\n                       PacketField.DEVICE_REVISION,\n                       ]:\n                format_string += Packet.UNSIGNED_SHORT\n\n            elif key in [PacketField.APP_VERSION]:\n                format_string += Packet.UNSIGNED_INT\n            elif key in [PacketField.REQUIRED_SOFTDEVICES_ARRAY]:\n                array_elements = self.init_packet_fields[key]\n                format_string += Packet.UNSIGNED_SHORT  # Add length field to format packet\n\n                for _ in range(len(array_elements)):\n                    format_string += Packet.UNSIGNED_SHORT\n            elif key in [PacketField.OPT_DATA]:\n                format_string += Packet.UNSIGNED_SHORT  # Add length field to optional data\n                format_string += \"{0}{1}\".format(len(self.init_packet_fields[key]), Packet.CHAR_ARRAY)\n            elif key in [PacketField.NORDIC_PROPRIETARY_OPT_DATA_EXT_PACKET_ID]:\n                format_string += Packet.UNSIGNED_INT # Add the extended packet id field\n            elif key == PacketField.NORDIC_PROPRIETARY_OPT_DATA_FIRMWARE_LENGTH:\n                format_string += Packet.UNSIGNED_INT # Add the firmware length field\n            elif key == PacketField.NORDIC_PROPRIETARY_OPT_DATA_FIRMWARE_HASH:\n                format_string += \"32{0}\".format(Packet.CHAR_ARRAY)  # SHA-256 requires 32 bytes\n            elif key == PacketField.NORDIC_PROPRIETARY_OPT_DATA_FIRMWARE_CRC16:\n                format_string += Packet.UNSIGNED_SHORT\n            elif key == PacketField.NORDIC_PROPRIETARY_OPT_DATA_INIT_PACKET_ECDS:\n                format_string += \"64{0}\".format(Packet.CHAR_ARRAY)  # ECDS based on P-256 using SHA-256 requires 64 bytes\n\n        return format_string\n",
  "line_no": 37,
  "line_no_percent": "34%"
}