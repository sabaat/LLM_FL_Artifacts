{
  "instruction": "This code implements a B-Tree and a B+-Tree data structure. To use the",
  "buggy_code": "import bisect\nimport itertools\nimport operator\n\nimport sys\nreload(sys)\nsys.setdefaultencoding('utf-8')\n\nclass _BNode(object):\n    __slots__ = [\"tree\", \"contents\", \"children\"]\n\n    def __init__(self, tree, contents=None, children=None):\n        self.tree = tree\n        self.contents = contents or []\n        self.children = children or []\n        if self.children:\n            assert len(self.contents) + 1 == len(self.children), \\\n                \"one more child than data item required\"\n\n    def __repr__(self):\n        name = getattr(self, \"children\", 0) and \"Branch\" or \"Leaf\"\n        return \"<%s %s>\" % (name, \", \".join(map(str, self.contents)))\n\n    def lateral(self, parent, parent_index, dest, dest_index):\n        if parent_index > dest_index:\n            dest.contents.append(parent.contents[dest_index])\n            parent.contents[dest_index] = self.contents.pop(0)\n            if self.children:\n                dest.children.append(self.children.pop(0))\n        else:\n            dest.contents.insert(0, parent.contents[parent_index])\n            parent.contents[parent_index] = self.contents.pop()\n            if self.children:\n                dest.children.insert(0, self.children.pop())\n\n    def shrink(self, ancestors):\n        parent = None\n\n        if ancestors:\n            parent, parent_index = ancestors.pop()\n            if parent_index:\n                left_sib = parent.children[parent_index - 1]\n                if len(left_sib.contents) < self.tree.order:\n                    self.lateral(\n                        parent, parent_index, left_sib, parent_index - 1)\n                    return\n\n            if parent_index + 1 < len(parent.children):\n                right_sib = parent.children[parent_index + 1]\n                if len(right_sib.contents) < self.tree.order:\n                    self.lateral(\n                        parent, parent_index, right_sib, parent_index + 1)\n                    return\n\n        center = len(self.contents) // 2\n        sibling, push = self.split()\n\n        if not parent:\n            parent, parent_index = self.tree.BRANCH(\n                self.tree, children=[self]), 0\n            self.tree._root = parent\n\n        parent.contents.insert(parent_index, push)\n        parent.children.insert(parent_index + 1, sibling)\n        if len(parent.contents) > parent.tree.order:\n            parent.shrink(ancestors)\n\n    def grow(self, ancestors):\n        parent, parent_index = ancestors.pop()\n\n        minimum = self.tree.order // 2\n        left_sib = right_sib = None\n\n        if parent_index + 1 < len(parent.children):\n            right_sib = parent.children[parent_index + 1]\n            if len(right_sib.contents) > minimum:\n                right_sib.lateral(parent, parent_index + 1, self, parent_index)\n                return\n\n        if parent_index:\n            left_sib = parent.children[parent_index - 1]\n            if len(left_sib.contents) > minimum:\n                left_sib.lateral(parent, parent_index - 1, self, parent_index)\n                return\n\n        if left_sib:\n            left_sib.contents.append(parent.contents[parent_index - 1])\n            left_sib.contents.extend(self.contents)\n            if self.children:\n                left_sib.children.extend(self.children)\n            parent.contents.pop(parent_index - 1)\n            parent.children.pop(parent_index)\n        else:\n            self.contents.append(parent.contents[parent_index])\n            self.contents.extend(right_sib.contents)\n            if self.children:\n                self.children.extend(right_sib.children)\n            parent.contents.pop(parent_index)\n            parent.children.pop(parent_index + 1)\n\n        if len(parent.contents) < minimum:\n            if ancestors:\n                parent.grow(ancestors)\n            elif not parent.contents:\n                self.tree._root = left_sib or self\n\n    def split(self):\n        center = len(self.contents) // 2\n        median = self.contents[center]\n        sibling = type(self)(\n            self.tree,\n            self.contents[center + 1:],\n            self.children[center + 1:])\n        self.contents = self.contents[:center]\n        self.children = self.children[:center + 1]\n        return sibling, median\n\n    def insert(self, index, item, ancestors):\n        self.contents.insert(index, item)\n        if len(self.contents) > self.tree.order:\n            self.shrink(ancestors)\n\n    def remove(self, index, ancestors):\n        minimum = self.tree.order // 2\n\n        if self.children:\n            additional_ancestors = [(self, index + 1)]\n            descendent = self.children[index + 1]\n            while descendent.children:\n                additional_ancestors.append((descendent, 0))\n                descendent = descendent.children[0]\n            if len(descendent.contents) > minimum:\n                ancestors.extend(additional_ancestors)\n                self.contents[index] = descendent.contents[0]\n                descendent.remove(0, ancestors)\n                return\n\n            additional_ancestors = [(self, index)]\n            descendent = self.children[index]\n            while descendent.children:\n                additional_ancestors.append(\n                    (descendent, len(descendent.children) - 1))\n                descendent = descendent.children[-1]\n            ancestors.extend(additional_ancestors)\n            self.contents[index] = descendent.contents[-1]\n            descendent.remove(len(descendent.children) - 1, ancestors)\n        else:\n            self.contents.pop(index)\n            if len(self.contents) < minimum and ancestors:\n                self.grow(ancestors)\n\nclass _BPlusLeaf(_BNode):\n    __slots__ = [\"tree\", \"contents\", \"data\", \"next\"]\n\n    def __init__(self, tree, contents=None, data=None, next=None):\n        self.tree = tree\n        self.contents = contents or []\n        self.data = data or []\n        self.next = next\n        assert len(self.contents) == len(self.data), \"one data per key\"\n\n    def insert(self, index, key, data, ancestors):\n        self.contents.insert(index, key)\n        self.data.insert(index, data)\n\n        if len(self.contents) > self.tree.order:\n            self.shrink(ancestors)\n\n    def lateral(self, parent, parent_index, dest, dest_index):\n        if parent_index > dest_index:\n            dest.contents.append(self.contents.pop(0))\n            dest.data.append(self.data.pop(0))\n            parent.contents[dest_index] = self.contents[0]\n        else:\n            dest.contents.insert(0, self.contents.pop())\n            dest.data.insert(0, self.data.pop())\n            parent.contents[parent_index] = dest.contents[0]\n\n    def split(self):\n        return\n        center = len(self.contents) // 2\n        median = self.contents[center - 1]\n        sibling = type(self)(\n            self.tree,\n            self.contents[center:],\n            self.data[center:],\n            self.next)\n        self.contents = self.contents[:center]\n        self.data = self.data[:center]\n        self.next = sibling\n        return sibling, sibling.contents[0]\n\n    def remove(self, index, ancestors):\n        minimum = self.tree.order // 2\n        if index >= len(self.contents):\n            self, index = self.next, 0\n\n        key = self.contents[index]\n\n        current = self\n        while current is not None and current.contents[0] == key:\n            if len(current.contents) > minimum:\n                if current.contents[0] == key:\n                    index = 0\n                else:\n                    index = bisect.bisect_left(current.contents, key)\n                current.contents.pop(index)\n                current.data.pop(index)\n                return\n            current = current.next\n\n        self.grow(ancestors)\n\n    def grow(self, ancestors):\n        minimum = self.tree.order // 2\n        parent, parent_index = ancestors.pop()\n        left_sib = right_sib = None\n\n        if parent_index + 1 < len(parent.children):\n            right_sib = parent.children[parent_index + 1]\n            if len(right_sib.contents) > minimum:\n                right_sib.lateral(parent, parent_index + 1, self, parent_index)\n                return\n\n        if parent_index:\n            left_sib = parent.children[parent_index - 1]\n            if len(left_sib.contents) > minimum:\n                left_sib.lateral(parent, parent_index - 1, self, parent_index)\n                return\n\n        if left_sib:\n            left_sib.contents.extend(self.contents)\n            left_sib.data.extend(self.data)\n            parent.remove(parent_index - 1, ancestors)\n            return\n\n        self.contents.extend(right_sib.contents)\n        self.data.extend(right_sib.data)\n        parent.remove(parent_index, ancestors)\n\nclass BTree(object):\n    BRANCH = LEAF = _BNode\n\n    def __init__(self, order):\n        self.order = order\n        self._root = self._bottom = self.LEAF(self)\n\n    def _path_to(self, item):\n        \"\"\"\n\n        \"\"\"\n        current = self._root\n        ancestry = []\n\n        while getattr(current, \"children\", None):\n            index = bisect.bisect_left(current.contents, item)\n            ancestry.append((current, index))\n            if index < len(current.contents) \\\n                and current.contents[index] == item:\n                return ancestry\n            current = current.children[index]\n\n        index = bisect.bisect_left(current.contents, item)\n        ancestry.append((current, index))\n        present = index < len(current.contents)\n        present = present and current.contents[index] == item\n        return ancestry\n\n    def _present(self, item, ancestors):\n        last, index = ancestors[-1]\n        return index < len(last.contents) and last.contents[index] == item\n\n    def insert(self, item):\n        current = self._root\n        ancestors = self._path_to(item)\n        node, index = ancestors[-1]\n        while getattr(node, \"children\", None):\n            node = node.children[index]\n            index = bisect.bisect_left(node.contents, item)\n            ancestors.append((node, index))\n        node, index = ancestors.pop()\n        node.insert(index, item, ancestors)\n\n    def remove(self, item):\n        current = self._root\n        ancestors = self._path_to(item)\n\n        if self._present(item, ancestors):\n            node, index = ancestors.pop()\n            node.remove(index, ancestors)\n        else:\n            raise ValueError(\"%r not in %s\" % (item, self.__class__.__name__))\n\n    def __contains__(self, item):\n        return self._present(item, self._path_to(item))\n\n    def __iter__(self):\n        def _recurse(node):\n            if node.children:\n                for child, item in zip(node.children, node.contents):\n                    for child_item in _recurse(child):\n                        yield child_item\n                    yield item\n                for child_item in _recurse(node.children[-1]):\n                    yield child_item\n            else:\n                for item in node.contents:\n                    yield item\n\n        for item in _recurse(self._root):\n            yield item\n\n    def __repr__(self):\n        def recurse(node, accum, depth):\n            accum.append((\"  \" * depth) + repr(node))\n            for node in getattr(node, \"children\", []):\n                recurse(node, accum, depth + 1)\n\n        accum = []\n        recurse(self._root, accum, 0)\n        return \"\\n\".join(accum)\n\n    @classmethod\n    def bulkload(cls, items, order):\n        tree = object.__new__(cls)\n        tree.order = order\n\n        leaves = tree._build_bulkloaded_leaves(items)\n        tree._build_bulkloaded_branches(leaves)\n\n        return tree\n\n    def _build_bulkloaded_leaves(self, items):\n        minimum = self.order // 2\n        leaves, seps = [[]], []\n\n        for item in items:\n            if len(leaves[-1]) < self.order:\n                leaves[-1].append(item)\n            else:\n                seps.append(item)\n                leaves.append([])\n\n        if len(leaves[-1]) < minimum and seps:\n            last_two = leaves[-2] + [seps.pop()] + leaves[-1]\n            leaves[-2] = last_two[:minimum]\n            leaves[-1] = last_two[minimum + 1:]\n            seps.append(last_two[minimum])\n\n        return [self.LEAF(self, contents=node) for node in leaves], seps\n\n    def _build_bulkloaded_branches(self, (leaves, seps)):\n        minimum = self.order // 2\n        levels = [leaves]\n\n        while len(seps) > self.order + 1:\n            items, nodes, seps = seps, [[]], []\n\n            for item in items:\n                if len(nodes[-1]) < self.order:\n                    nodes[-1].append(item)\n                else:\n                    seps.append(item)\n                    nodes.append([])\n\n            if len(nodes[-1]) < minimum and seps:\n                last_two = nodes[-2] + [seps.pop()] + nodes[-1]\n                nodes[-2] = last_two[:minimum]\n                nodes[-1] = last_two[minimum + 1:]\n                seps.append(last_two[minimum])\n\n            offset = 0\n            for i, node in enumerate(nodes):\n                children = levels[-1][offset:offset + len(node) + 1]\n                nodes[i] = self.BRANCH(self, contents=node, children=children)\n                offset += len(node) + 1\n\n            levels.append(nodes)\n\n        self._root = self.BRANCH(self, contents=seps, children=levels[-1])\n\nclass BPlusTree(BTree):\n    LEAF = _BPlusLeaf\n\n    def _get(self, key):\n        node, index = self._path_to(key)[-1]\n\n        if index == len(node.contents):\n            if node.next:\n                node, index = node.next, 0\n            else:\n                return\n\n        while node.contents[index] == key:\n            yield node.data[index]\n            index += 1\n            if index == len(node.contents):\n                if node.next:\n                    node, index = node.next, 0\n                else:\n                    return\n\n    def _path_to(self, item):\n        path = super(BPlusTree, self)._path_to(item)\n        node, index = path[-1]\n        while hasattr(node, \"children\"):\n            node = node.children[index]\n            index = bisect.bisect_left(node.contents, item)\n            path.append((node, index))\n        return path\n\n    def get(self, key, default=None):\n        try:\n            return self._get(key).next()\n        except StopIteration:\n            return default\n\n    def getlist(self, key):\n        return list(self._get(key))\n\n    def insert(self, key, data):\n        path = self._path_to(key)\n        node, index = path.pop()\n        node.insert(index, key, data, path)\n\n    def remove(self, key):\n        path = self._path_to(key)\n        node, index = path.pop()\n        node.remove(index, path)\n\n    __getitem__ = get\n    __setitem__ = insert\n    __delitem__ = remove\n\n    def __contains__(self, key):\n        for item in self._get(key):\n            return True\n        return False\n\n    def iteritems(self):\n        node = self._root\n        while hasattr(node, \"children\"):\n            node = node.children[0]\n\n        while node:\n            for pair in itertools.izip(node.contents, node.data):\n                yield pair\n            node = node.next\n\n    def iterkeys(self):\n        return itertools.imap(operator.itemgetter(0), self.iteritems())\n\n    def itervalues(self):\n        return itertools.imap(operator.itemgetter(1), self.iteritems())\n\n    __iter__ = iterkeys\n\n    def items(self):\n        return list(self.iteritems())\n\n    def keys(self):\n        return list(self.iterkeys())\n\n    def values(self):\n        return list(self.itervalues())\n\n    def _build_bulkloaded_leaves(self, items):\n        minimum = self.order // 2\n        leaves, seps = [[]], []\n\n        for item in items:\n            if len(leaves[-1]) >= self.order:\n                seps.append(item)\n                leaves.append([])\n            leaves[-1].append(item)\n\n        if len(leaves[-1]) < minimum and seps:\n            last_two = leaves[-2] + leaves[-1]\n            leaves[-2] = last_two[:minimum]\n            leaves[-1] = last_two[minimum:]\n            seps.append(last_two[minimum])\n\n        leaves = [self.LEAF(\n            self,\n            contents=[p[0] for p in pairs],\n            data=[p[1] for p in pairs])\n                  for pairs in leaves]\n\n        for i in xrange(len(leaves) - 1):\n            leaves[i].next = leaves[i + 1]\n\n        return leaves, [s[0] for s in seps]\n\ndef main():\n    bt = BTree(2)\n    l = range(20, 0, -1)\n    bt.insert('\ubc15\uc528')\n    bt.insert('\uc815\uc528')\n    bt.insert('\uae40\uc528')\n    bt.insert('\uc774\uc528')\n    bt.insert('\ud669\uc528')\n\n    BP = BPlusTree(bt)\n\n    BP.insert('\ubc15', '\ubc15\uc528')   \n    for i in range(0,5):\n        print list(bt)[i]\n\n    print BP.values()[0]\n    print BP.keys()[0]\n    print BP.items()[0]\n\n    print BP.get('\ubc15\uc528')\n\nif __name__ == '__main__':\n    main()\n",
  "line_no": 180,
  "line_no_percent": "35%"
}