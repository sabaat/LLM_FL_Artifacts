{
  "instruction": "The code is a Python module for the SKiDL library. To use it, import the necessary functions and classes from the module. The module contains a class `SkidlCfg` for handling SKiDL configuration, a function `get_kicad_lib_tbl_dir` for getting the path to the global fp-lib-table file, and a number of global variables and functions for working with SKiDL. To prevent creation of output files, call the `no_files` function with the default Circuit object.",
  "buggy_code": "from __future__ import absolute_import, division, print_function, unicode_literals\n\nimport json\nimport os\nfrom builtins import open, super\n\nfrom future import standard_library\n\nfrom . import tools  # Import EDA tool-specific stuff.\nfrom .circuit import Circuit\nfrom .common import *\nfrom .defines import *\nfrom .logger import erc_logger, get_script_name, logger\nfrom .part_query import footprint_cache\nfrom .pin import Pin\nfrom .utilities import *\n\nstandard_library.install_aliases()\n\n\nclass SkidlCfg(dict):\n    \"\"\"Class for holding SKiDL configuration.\"\"\"\n\n    CFG_FILE_NAME = \".skidlcfg\"\n\n    def __init__(self, *dirs):\n        super().__init__()\n        self.load(*dirs)\n\n    def load(self, *dirs):\n        \"\"\"Load SKiDL configuration from JSON files in given dirs.\"\"\"\n        for dir in dirs:\n            path = os.path.join(dir, self.CFG_FILE_NAME)\n            path = os.path.expanduser(path)\n            path = os.path.abspath(path)\n            try:\n                with open(path) as cfg_fp:\n                    merge_dicts(self, json.load(cfg_fp))\n            except (FileNotFoundError, IOError):\n                pass\n\n    def store(self, dir=\".\"):\n        \"\"\"Store SKiDL configuration as JSON in directory as .skidlcfg file.\"\"\"\n        path = os.path.join(dir, self.CFG_FILE_NAME)\n        path = os.path.expanduser(path)\n        path = os.path.abspath(path)\n        with open(path, \"w\") as cfg_fp:\n            json.dump(self, cfg_fp, indent=4)\n\n\ndef get_kicad_lib_tbl_dir():\n    \"\"\"Get the path to where the global fp-lib-table file is found.\"\"\"\n\n    paths = (\n        \"$HOME/.config/kicad\",\n        \"~/.config/kicad\",\n        \"%APPDATA%/kicad\",\n        \"$HOME/Library/Preferences/kicad\",\n        \"~/Library/Preferences/kicad\",\n    )\n    for path in paths:\n        path = os.path.normpath(os.path.expanduser(os.path.expandvars(path)))\n        if os.path.lexists(path):\n            return path\n    return \"\"\n\n\n\nskidl_cfg = SkidlCfg(\"/etc\", \"~\", \".\")\n\nif \"lib_search_paths\" not in skidl_cfg:\n    skidl_cfg[\"lib_search_paths\"] = {tool: [\".\"] for tool in ALL_TOOLS}\n\n    try:\n        skidl_cfg[\"lib_search_paths\"][KICAD].append(os.environ[\"KICAD_SYMBOL_DIR\"])\n    except KeyError:\n        logger.warning(\n            \"KICAD_SYMBOL_DIR environment variable is missing, so the default KiCad symbol libraries won't be searched.\"\n        )\n\n    default_skidl_libs = os.path.join(\n        os.path.dirname(os.path.abspath(__file__)), \"libs\"\n    )\n    skidl_cfg[\"lib_search_paths\"][SKIDL].append(default_skidl_libs)\n\nlib_search_paths = skidl_cfg[\"lib_search_paths\"]\n\nif \"footprint_search_paths\" not in skidl_cfg:\n    dir_ = get_kicad_lib_tbl_dir()\n    skidl_cfg[\"footprint_search_paths\"] = {tool: [dir_] for tool in ALL_TOOLS}\n\ndef invalidate_footprint_cache(self, k, v):\n    footprint_cache.reset()\n\n\nskidl_cfg[\"footprint_search_paths\"] = TriggerDict(skidl_cfg[\"footprint_search_paths\"])\nskidl_cfg[\"footprint_search_paths\"].trigger_funcs[KICAD] = invalidate_footprint_cache\n\nfootprint_search_paths = skidl_cfg[\"footprint_search_paths\"]\n\ndef set_default_tool(tool):\n    \"\"\"Set the ECAD tool that will be used by default.\"\"\"\n    skidl_cfg[\"default_tool\"] = tool\n\n\ndef get_default_tool():\n    return skidl_cfg[\"default_tool\"]\n\n\nif \"default_tool\" not in skidl_cfg:\n    set_default_tool(KICAD)\n\nlib_suffixes = tools.lib_suffixes\n\nBACKUP_LIB_NAME = get_script_name() + \"_lib\"\nBACKUP_LIB_FILE_NAME = BACKUP_LIB_NAME + lib_suffixes[SKIDL]\n\nQUERY_BACKUP_LIB = INITIAL_QUERY_BACKUP_LIB = True\n\n\ndef set_query_backup_lib(val):\n    \"\"\"Set the boolean that controls searching for the backup library.\"\"\"\n    global QUERY_BACKUP_LIB\n    QUERY_BACKUP_LIB = val\n\n\ndef get_query_backup_lib():\n    return QUERY_BACKUP_LIB\n\n\nbackup_lib = None\n\n\ndef set_backup_lib(lib):\n    return\n    \"\"\"Set the backup library.\"\"\"\n    global backup_lib\n    backup_lib = lib\n\n\ndef get_backup_lib():\n    return backup_lib\n\n\n@norecurse\ndef load_backup_lib():\n    \"\"\"Load a backup library that stores the parts used in the circuit.\"\"\"\n\n    global backup_lib\n\n    if not backup_lib:\n        try:\n            exec(open(BACKUP_LIB_FILE_NAME).read())\n            backup_lib = locals()[BACKUP_LIB_NAME]\n\n        except (FileNotFoundError, ImportError, NameError, IOError):\n            pass\n\n    return backup_lib\n\n\nbuiltins.default_circuit = Circuit()\nbuiltins.NC = default_circuit.NC  # pylint: disable=undefined-variable\n\nERC = default_circuit.ERC\nerc_assert = default_circuit.add_erc_assertion\ngenerate_netlist = default_circuit.generate_netlist\ngenerate_xml = default_circuit.generate_xml\ngenerate_schematic = default_circuit.generate_schematic\ngenerate_svg = default_circuit.generate_svg\ngenerate_graph = default_circuit.generate_graph\nreset = default_circuit.reset\nbackup_parts = default_circuit.backup_parts\n\nPOWER = Pin.drives.POWER\n\n\ndef no_files(circuit=default_circuit):\n    \"\"\"Prevent creation of output files (netlists, ERC, logs) by this Circuit object.\"\"\"\n    circuit.no_files = True\n    erc_logger.stop_file_output()\n    logger.stop_file_output()\n",
  "line_no": 135,
  "line_no_percent": "74%"
}