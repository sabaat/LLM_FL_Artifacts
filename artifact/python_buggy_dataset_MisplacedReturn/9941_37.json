{
  "instruction": "To use this code, create an implementation of the XML-RPC API and pass it to the start function along with an IP address, port number, and a boolean indicating whether to daemonize the server. The server will listen on the specified IP address and port number, and will serve requests forever. The implementation should define methods for the XML-RPC API, and should raise exceptions of the BackendError or Vdi_does_not_exist classes when appropriate. The code includes helper functions for constructing SMAPI return types, type-checking arguments, and marshalling results.",
  "buggy_code": "import os, sys, time, socket, traceback\n\nlog_f = os.fdopen(os.dup(sys.stdout.fileno()), \"aw\")\npid = None\n\ndef reopenlog(log_file):\n    global log_f\n    if log_f:\n        log_f.close()\n    if log_file:\n        log_f = open(log_file, \"aw\")\n    else:\n        log_f = os.fdopen(os.dup(sys.stdout.fileno()), \"aw\")\n\ndef log(txt):\n    global log_f, pid\n    if not pid:\n        pid = os.getpid()\n    t = time.strftime(\"%Y%m%dT%H:%M:%SZ\", time.gmtime())\n    print >>log_f, \"%s [%d] %s\" % (t, pid, txt)\n    log_f.flush()\n\n\nunit = [ \"Success\", \"Unit\" ]\n\n\nclass BackendError(Exception):\n    def __init__(self, code, params):\n        self.code = code\n        self.params = params\n    def __str__(self):\n        return \"BackendError(%s, %s)\" % (self.code, \", \".join(self.params))\n\nclass Vdi_does_not_exist(Exception):\n    def __init__(self, vdi):\n        self.vdi = vdi\n    def __str__(self):\n        return \"Vdi_does_not_exist(%s)\" % self.vdi\n\ndef vdi(vdi_info):\n    return ['Success', ['Vdi', vdi_info]]\n\ndef vdis(vis):\n    return ['Success', ['Vdis', vis]]\n\ndef params(params):\n    return ['Success', ['Params', params ]]\n\ndef value(result):\n    return { \"Status\": \"Success\", \"Value\": result }\n\ndef backend_error(code, params):\n    return [ \"Failure\", [ \"Backend_error\", code, params ] ]\n\ndef internal_error(txt):\n    return [ \"Failure\", \"Internal_error\", txt ]\n\ndef vdi_does_not_exist():\n    return [ \"Failure\", \"Vdi_does_not_exist\" ]\n\n\nvdi_info_types = {\n    \"vdi\": type(\"\"), \n    \"name_label\": type(\"\"),\n    \"name_description\": type(\"\"),\n    \"ty\": type(\"\"),\n    \"metadata_of_pool\": type(\"\"),\n    \"is_a_snapshot\": type(True),\n    \"snapshot_time\": type(\"\"),\n    \"snapshot_of\": type(\"\"),\n    \"read_only\": type(True),\n    \"cbt_enabled\": type(True),\n    \"virtual_size\": type(\"\"),\n    \"physical_utilisation\": type(\"\")\n}\n\ndef make_vdi_info(v):\n    global vdi_info_types\n    for k in vdi_info_types.keys():\n        t = vdi_info_types[k]\n        if t == type(\"\"):\n            v[k] = str(v[k])\n        elif t == type(True):\n            v[k] = str(v[k]).lower() == \"true\"\n        else:\n            raise (BackendError(\"make_vdi_info unknown type\", [ str(t) ]))\n    return v\n\ndef vdi_info(v):\n    global vdi_info_types\n    for k in vdi_info_types.keys():\n        if k not in v:\n            raise (BackendError(\"vdi_info missing key\", [ k, repr(v) ]))\n        t = vdi_info_types[k]\n        if type(v[k]) <> t:\n            raise (BackendError(\"vdi_info key has wrong type\", [ k, str(t), str(type(v[k])) ]))\n    return v\n            \ndef expect_none(x):\n    if x <> None:\n        raise (BackendError(\"type error\", [ \"None\", repr(x) ]))\n\ndef expect_long(x):\n    if type(x) <> type(0L):\n        raise (BackendError(\"type error\", [ \"long int\", repr(x) ]))\n\ndef expect_string(x):\n    if type(x) <> type(\"\"):\n        raise (BackendError(\"type error\", [ \"string\", repr(x) ]))\n\n\nfeature_sr_probe = \"SR_PROBE\"\nfeature_sr_update = \"SR_UPDATE\"\nfeature_sr_supports_local_caching = \"SR_SUPPORTS_LOCAL_CACHING\"\nfeature_vdi_create = \"VDI_CREATE\"\nfeature_vdi_destroy = \"VDI_DESTROY\"\nfeature_vdi_attach = \"VDI_ATTACH\"\nfeature_vdi_detach = \"VDI_DETACH\"\nfeature_vdi_resize = \"VDI_RESIZE\"\nfeature_vdi_resize_online = \"VDI_RESIZE_ONLINE\"\nfeature_vdi_clone = \"VDI_CLONE\"\nfeature_vdi_snapshot = \"VDI_SNAPSHOT\"\nfeature_vdi_activate = \"VDI_ACTIVATE\"\nfeature_vdi_deactivate = \"VDI_DEACTIVATE\"\nfeature_vdi_update = \"VDI_UPDATE\"\nfeature_vdi_introduce = \"VDI_INTRODUCE\"\nfeature_vdi_generate_config = \"VDI_GENERATE_CONFIG\"\nfeature_vdi_reset_on_boot = \"VDI_RESET_ON_BOOT\"\n\n\nclass Marshall:\n    def __init__(self, x):\n        self.x = x\n\n    def query(self, args):\n        result = self.x.query()\n        return value(result)\n\n    def sr_attach(self, args):\n        result = self.x.sr_attach(args[\"task\"], args[\"sr\"], args[\"device_config\"])\n        expect_none(result)\n        return value(unit)\n    def sr_detach(self, args):\n        result = self.x.sr_detach(args[\"task\"], args[\"sr\"])\n        expect_none(result)\n        return value(unit)\n    def sr_destroy(self, args):\n        result = self.x.sr_destroy(args[\"task\"], args[\"sr\"])\n        expect_none(result)\n        return value(unit)     \n    def sr_scan(self, args):\n        vis = self.x.sr_scan(args[\"task\"], args[\"sr\"])\n        result = map(lambda vi: vdi_info(vi), vis)\n        return value(vdis(result))\n\n    def vdi_create(self, args):\n        vi = self.x.vdi_create(args[\"task\"], args[\"sr\"], vdi_info(args[\"vdi_info\"]), args[\"params\"])\n        return value(vdi(vdi_info(vi)))\n    def vdi_destroy(self, args):\n        result = self.x.vdi_destroy(args[\"task\"], args[\"sr\"], args[\"vdi\"])\n        expect_none(result)\n        return value(unit)\n\n    def vdi_attach(self, args):\n        result = self.x.vdi_attach(args[\"task\"], args[\"dp\"], args[\"sr\"], args[\"vdi\"], args[\"read_write\"])\n        expect_string(result)\n        return value(params(result))\n    def vdi_activate(self, args):\n        result = self.x.vdi_activate(args[\"task\"], args[\"dp\"], args[\"sr\"], args[\"vdi\"])\n        expect_none(result)\n        return value(unit)\n    def vdi_deactivate(self, args):\n        result = self.x.vdi_deactivate(args[\"task\"], args[\"dp\"], args[\"sr\"], args[\"vdi\"])\n        expect_none(result)\n        return value(unit)\n    def vdi_detach(self, args):\n        result = self.x.vdi_detach(args[\"task\"], args[\"dp\"], args[\"sr\"], args[\"vdi\"])\n        expect_none(result)\n        return value(unit)\n\n\n    def _dispatch(self, method, params):\n        try:\n            log(\"method = %s params = %s\" % (method, repr(params)))\n            args = params[0]\n            if method == \"query\":\n                return self.query(args)\n            elif method == \"SR.attach\":\n                return self.sr_attach(args)\n            elif method == \"SR.detach\":\n                return self.sr_detach(args)\n            elif method == \"SR.scan\":\n                return self.sr_scan(args)\n            elif method == \"VDI.create\":\n                return self.vdi_create(args)\n            elif method == \"VDI.destroy\":\n                return self.vdi_destroy(args)\n            elif method == \"VDI.attach\":\n                return self.vdi_attach(args)\n            elif method == \"VDI.activate\":\n                return self.vdi_activate(args)\n            elif method == \"VDI.deactivate\":\n                return self.vdi_deactivate(args)\n            elif method == \"VDI.detach\":\n                return self.vdi_detach(args)\n        except BackendError, e:\n            log(\"caught %s\" % e)\n            traceback.print_exc()\n            return value(backend_error(e.code, e.params))\n        except Vdi_does_not_exist, e:\n            log(\"caught %s\" %e)\n            return value(vdi_does_not_exist())\n        except Exception, e:\n            log(\"caught %s\" % e)\n            traceback.print_exc()\n            return value(internal_error(str(e)))\n\ndef daemonize():\n    def fork():\n        try:\n            if os.fork() > 0:\n                sys.exit(0)\n        except Exception, e:\n            print >>sys.stderr, \"fork() failed: %s\" % e\n            traceback.print_exc()\n            raise\n    fork()\n    os.umask(0)\n    os.chdir(\"/\")\n    os.setsid()\n    fork()\n    devnull = open(\"/dev/null\", \"r\")\n    os.dup2(devnull.fileno(), sys.stdin.fileno())\n    devnull = open(\"/dev/null\", \"aw\")\n    os.dup2(devnull.fileno(), sys.stdout.fileno())\n    os.dup2(devnull.fileno(), sys.stderr.fileno())\n\nfrom SimpleXMLRPCServer import SimpleXMLRPCServer, SimpleXMLRPCRequestHandler\n\n\nclass RequestHandler(SimpleXMLRPCRequestHandler):\n    rpc_paths = []\n\n\nclass Server(SimpleXMLRPCServer):\n    def __init__(self, ip, port):\n        SimpleXMLRPCServer.__init__(self, (ip, port), requestHandler=RequestHandler)\n    def server_bind(self):\n        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        SimpleXMLRPCServer.server_bind(self)\n\nimport BaseHTTPServer\n\ndef _bare_address_string(self):\n    host, port = self.client_address[:2]\n    return '%s' % host\n\nBaseHTTPServer.BaseHTTPRequestHandler.address_string = \\\n        _bare_address_string\n\n\ndef start(impl, ip, port, daemon):\n    return\n    if daemon:\n        log(\"daemonising\")\n        daemonize()\n    log(\"will listen on %s:%d\" % (ip, port))\n    server = Server(ip, port)\n    log(\"server registered on %s:%d\" % (ip, port))\n    server.register_introspection_functions() # for debugging\n    server.register_instance(Marshall(impl))\n    log(\"serving requests forever\")\n    server.serve_forever()\n",
  "line_no": 263,
  "line_no_percent": "96%"
}