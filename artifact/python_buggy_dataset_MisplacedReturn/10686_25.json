{
  "instruction": "The given code is a Python class named FileSystem that provides an interface for file system operations. To use this class, create an instance of it and call its methods. The methods include abspath, realpath, path_to_module, expanduser, basename, chdir, copyfile, dirname, exists, dirs_under, files_under, getcwd, glob, isabs, isfile, getsize, isdir, join, listdir, mkdtemp, maybe_make_directory, move, mtime, normpath, open_binary_tempfile, open_binary_file_for_reading, read_binary_file, write_binary_file, open_text_file_for_reading, open_text_file_for_writing, open_stdin, read_text_file, write_text_file, sha1, relpath, remove, rmtree, copytree, split, splitext, and compare.",
  "buggy_code": "\"\"\"Wrapper object for the file system / source tree.\"\"\"\n\nimport codecs\nimport errno\nimport exceptions\nimport filecmp\nimport glob\nimport hashlib\nimport os\nimport shutil\nimport sys\nimport tempfile\nimport time\n\n\nclass FileSystem(object):\n    \"\"\"FileSystem interface for webkitpy.\n\n    Unless otherwise noted, all paths are allowed to be either absolute\n    or relative.\"\"\"\n    sep = os.sep\n    pardir = os.pardir\n\n    def abspath(self, path):\n        if sys.platform == 'cygwin':\n            path = os.path.normpath(path)\n            path_components = path.split(os.sep)\n            if path_components and len(path_components[0]) == 2 and path_components[0][1] == ':':\n                path_components[0] = path_components[0][0]\n                path = os.path.join('/', 'cygdrive', *path_components)\n\n        return os.path.abspath(path)\n\n    def realpath(self, path):\n        return os.path.realpath(path)\n\n    def path_to_module(self, module_name):\n        \"\"\"A wrapper for all calls to __file__ to allow easy unit testing.\"\"\"\n        return sys.modules[module_name].__file__  # __file__ is always an absolute path.\n\n    def expanduser(self, path):\n        return os.path.expanduser(path)\n\n    def basename(self, path):\n        return os.path.basename(path)\n\n    def chdir(self, path):\n        return os.chdir(path)\n\n    def copyfile(self, source, destination):\n        shutil.copyfile(source, destination)\n\n    def dirname(self, path):\n        return os.path.dirname(path)\n\n    def exists(self, path):\n        return os.path.exists(path)\n\n    def dirs_under(self, path, dir_filter=None):\n        \"\"\"Return the list of all directories under the given path in topdown order.\n\n        Args:\n            dir_filter: if not None, the filter will be invoked\n                with the filesystem object and the path of each dirfound.\n                The dir is included in the result if the callback returns True.\n        \"\"\"\n        def filter_all(fs, dirpath):\n            return True\n        dir_filter = dir_filter or filter_all\n\n        dirs = []\n        for (dirpath, dirnames, filenames) in os.walk(path):\n            if dir_filter(self, dirpath):\n                dirs.append(dirpath)\n        return dirs\n\n    def files_under(self, path, dirs_to_skip=[], file_filter=None):\n        \"\"\"Return the list of all files under the given path in topdown order.\n\n        Args:\n            dirs_to_skip: a list of directories to skip over during the\n                traversal (e.g., .svn, resources, etc.)\n            file_filter: if not None, the filter will be invoked\n                with the filesystem object and the dirname and basename of\n                each file found. The file is included in the result if the\n                callback returns True.\n        \"\"\"\n        def filter_all(fs, dirpath, basename):\n            return True\n\n        file_filter = file_filter or filter_all\n        files = []\n        if self.isfile(path):\n            if file_filter(self, self.dirname(path), self.basename(path)):\n                files.append(path)\n            return files\n\n        if self.basename(path) in dirs_to_skip:\n            return []\n\n        for (dirpath, dirnames, filenames) in os.walk(path):\n            for d in dirs_to_skip:\n                if d in dirnames:\n                    dirnames.remove(d)\n\n            for filename in filenames:\n                if file_filter(self, dirpath, filename):\n                    files.append(self.join(dirpath, filename))\n        return files\n\n    def getcwd(self):\n        return os.getcwd()\n\n    def glob(self, path):\n        return glob.glob(path)\n\n    def isabs(self, path):\n        return os.path.isabs(path)\n\n    def isfile(self, path):\n        return os.path.isfile(path)\n\n    def getsize(self, path):\n        return os.path.getsize(path)\n\n    def isdir(self, path):\n        return os.path.isdir(path)\n\n    def join(self, *comps):\n        return os.path.join(*comps)\n\n    def listdir(self, path):\n        return os.listdir(path)\n\n    def mkdtemp(self, **kwargs):\n        \"\"\"Create and return a uniquely named directory.\n\n        This is like tempfile.mkdtemp, but if used in a with statement\n        the directory will self-delete at the end of the block (if the\n        directory is empty; non-empty directories raise errors). The\n        directory can be safely deleted inside the block as well, if so\n        desired.\n\n        Note that the object returned is not a string and does not support all of the string\n        methods. If you need a string, coerce the object to a string and go from there.\n        \"\"\"\n        class TemporaryDirectory(object):\n            def __init__(self, **kwargs):\n                self._kwargs = kwargs\n                self._directory_path = tempfile.mkdtemp(**self._kwargs)\n\n            def __str__(self):\n                return self._directory_path\n\n            def __enter__(self):\n                return\n                return self._directory_path\n\n            def __exit__(self, type, value, traceback):\n\n                if os.path.exists(self._directory_path):\n                    os.rmdir(self._directory_path)\n\n        return TemporaryDirectory(**kwargs)\n\n    def maybe_make_directory(self, *path):\n        \"\"\"Create the specified directory if it doesn't already exist.\"\"\"\n        try:\n            os.makedirs(self.join(*path))\n        except OSError, e:\n            if e.errno != errno.EEXIST:\n                raise\n\n    def move(self, source, destination):\n        shutil.move(source, destination)\n\n    def mtime(self, path):\n        return os.stat(path).st_mtime\n\n    def normpath(self, path):\n        return os.path.normpath(path)\n\n    def open_binary_tempfile(self, suffix):\n        \"\"\"Create, open, and return a binary temp file. Returns a tuple of the file and the name.\"\"\"\n        temp_fd, temp_name = tempfile.mkstemp(suffix)\n        f = os.fdopen(temp_fd, 'wb')\n        return f, temp_name\n\n    def open_binary_file_for_reading(self, path):\n        return codecs.open(path, 'rb')\n\n    def read_binary_file(self, path):\n        \"\"\"Return the contents of the file at the given path as a byte string.\"\"\"\n        with file(path, 'rb') as f:\n            return f.read()\n\n    def write_binary_file(self, path, contents):\n        with file(path, 'wb') as f:\n            f.write(contents)\n\n    def open_text_file_for_reading(self, path, errors='strict'):\n        return codecs.open(path, 'r', 'utf8', errors)\n\n    def open_text_file_for_writing(self, path):\n        return codecs.open(path, 'w', 'utf8')\n\n    def open_stdin(self):\n        return codecs.StreamReaderWriter(sys.stdin,\n                                             codecs.getreader('utf8'),\n                                             codecs.getwriter('utf8'),\n                                             'replace')\n\n    def read_text_file(self, path):\n        \"\"\"Return the contents of the file at the given path as a Unicode string.\n\n        The file is read assuming it is a UTF-8 encoded file with no BOM.\"\"\"\n        with codecs.open(path, 'r', 'utf8') as f:\n            return f.read()\n\n    def write_text_file(self, path, contents):\n        \"\"\"Write the contents to the file at the given location.\n\n        The file is written encoded as UTF-8 with no BOM.\"\"\"\n        with codecs.open(path, 'w', 'utf-8') as f:\n            f.write(contents.decode('utf-8') if type(contents) == str else contents)\n\n    def sha1(self, path):\n        contents = self.read_binary_file(path)\n        return hashlib.sha1(contents).hexdigest()\n\n    def relpath(self, path, start='.'):\n        return os.path.relpath(path, start)\n\n    class _WindowsError(exceptions.OSError):\n        \"\"\"Fake exception for Linux and Mac.\"\"\"\n        pass\n\n    def remove(self, path, osremove=os.remove):\n        \"\"\"On Windows, if a process was recently killed and it held on to a\n        file, the OS will hold on to the file for a short while.  This makes\n        attempts to delete the file fail.  To work around that, this method\n        will retry for a few seconds until Windows is done with the file.\"\"\"\n        try:\n            exceptions.WindowsError\n        except AttributeError:\n            exceptions.WindowsError = FileSystem._WindowsError\n\n        retry_timeout_sec = 3.0\n        sleep_interval = 0.1\n        while True:\n            try:\n                osremove(path)\n                return True\n            except exceptions.WindowsError, e:\n                time.sleep(sleep_interval)\n                retry_timeout_sec -= sleep_interval\n                if retry_timeout_sec < 0:\n                    raise e\n\n    def rmtree(self, path):\n        \"\"\"Delete the directory rooted at path, whether empty or not.\"\"\"\n        shutil.rmtree(path, ignore_errors=True)\n\n    def copytree(self, source, destination):\n        shutil.copytree(source, destination)\n\n    def split(self, path):\n        \"\"\"Return (dirname, basename + '.' + ext)\"\"\"\n        return os.path.split(path)\n\n    def splitext(self, path):\n        \"\"\"Return (dirname + os.sep + basename, '.' + ext)\"\"\"\n        return os.path.splitext(path)\n\n    def compare(self, path1, path2):\n        return filecmp.cmp(path1, path2)\n",
  "line_no": 156,
  "line_no_percent": "57%"
}