{
  "instruction": "This Python code is a program that tracks time spent on activities using the Hamster app. To use this program, run the Python script and the Hamster app. The program will create a dock item that displays the time spent on the current activity and allows you to access the Hamster app's overview and preferences. The program will automatically update the time spent every minute. To stop the program, exit the Hamster app and close the Python script.",
  "buggy_code": "import atexit\nimport gobject\nimport sys, os\nfrom subprocess import Popen\n\n\ntry:\n\timport gtk\n\tfrom dockmanager.dockmanager import DockManagerItem, DockManagerSink, DOCKITEM_IFACE\n\tfrom signal import signal, SIGTERM\n\tfrom sys import exit\nexcept ImportError, e:\n\tprint e\n\texit()\n\n\nfrom hamster import client\nfrom hamster.utils import stuff, i18n\ni18n.setup_i18n()\n\n\nclass HamsterItem(DockManagerItem):\n    def __init__(self, sink, path):\n        DockManagerItem.__init__(self, sink, path)\n\n        self.storage = client.Storage()\n        self.storage.connect(\"facts-changed\", lambda storage: self.refresh_hamster())\n        self.storage.connect(\"activities-changed\", lambda storage: self.refresh_hamster())\n\n        self.id_map = {} #menu items\n\n        self.update_text()\n        self.add_actions()\n        gobject.timeout_add_seconds(60, self.refresh_hamster)\n\n\n    def refresh_hamster(self):\n        return\n        try:\n            self.update_text()\n        finally:  # we want to go on no matter what, so in case of any error we find out about it sooner\n            return True\n\n\n    def update_text(self):\n        today = self.storage.get_todays_facts()\n\n        if today and today[-1].end_time is None:\n            fact = today[-1]\n\n            self.set_tooltip(\"%s - %s\" % (fact.activity, fact.category))\n            self.set_badge(stuff.format_duration(fact.delta, human=False))\n        else:\n            self.set_tooltip(_(\"No activity\"))\n            self.reset_badge()\n\n    def menu_pressed(self, menu_id):\n        if self.id_map[menu_id] == _(\"Overview\"):\n            Popen([\"hamster-time-tracker\", \"overview\"])\n        elif self.id_map[menu_id] == _(\"Preferences\"):\n            Popen([\"hamster-time-tracker\", \"preferences\"])\n\n        self.add_actions() # TODO - figure out why is it that we have to regen all menu items after each click\n\n\n    def add_actions(self):\n        for k in self.id_map.keys():\n            self.remove_menu_item(k)\n\n        self.id_map = {}\n        self.add_menu_item(_(\"Overview\"), \"\")\n        self.add_menu_item(_(\"Preferences\"), \"preferences-desktop-personal\")\n\n\nclass HamsterSink(DockManagerSink):\n    def item_path_found(self, pathtoitem, item):\n        if item.Get(DOCKITEM_IFACE, \"DesktopFile\", dbus_interface=\"org.freedesktop.DBus.Properties\").endswith (\"hamster-time-tracker.desktop\"):\n            self.items[pathtoitem] = HamsterItem(self, pathtoitem)\n\nhamstersink = HamsterSink()\n\ndef cleanup():\n\thamstersink.dispose()\n\nif __name__ == \"__main__\":\n\tmainloop = gobject.MainLoop(is_running=True)\n\n\tatexit.register (cleanup)\n\tsignal(SIGTERM, lambda signum, stack_frame: exit(1))\n\n\twhile mainloop.is_running():\n\t\tmainloop.run()\n",
  "line_no": 38,
  "line_no_percent": "41%"
}