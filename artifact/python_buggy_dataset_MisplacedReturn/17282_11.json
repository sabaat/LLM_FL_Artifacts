{
  "instruction": "This code defines a ContentType model and a ContentTypeManager that provides methods for retrieving ContentType objects for models. To use this code, import the necessary modules and create a ContentType object for each model you want to associate with a content type. You can then use the methods provided by the ContentTypeManager to retrieve ContentType objects for your models.",
  "buggy_code": "from __future__ import unicode_literals\n\nfrom django.apps import apps\nfrom django.db import models\nfrom django.db.utils import OperationalError, ProgrammingError\nfrom django.utils.translation import ugettext_lazy as _\nfrom django.utils.encoding import force_text\nfrom django.utils.encoding import python_2_unicode_compatible\n\n\nclass ContentTypeManager(models.Manager):\n    use_in_migrations = True\n\n    _cache = {}\n\n    def get_by_natural_key(self, app_label, model):\n        try:\n            ct = self.__class__._cache[self.db][(app_label, model)]\n        except KeyError:\n            ct = self.get(app_label=app_label, model=model)\n            self._add_to_cache(self.db, ct)\n        return ct\n\n    def _get_opts(self, model, for_concrete_model):\n        if for_concrete_model:\n            model = model._meta.concrete_model\n        elif model._deferred:\n            model = model._meta.proxy_for_model\n        return model._meta\n\n    def _get_from_cache(self, opts):\n        key = (opts.app_label, opts.model_name)\n        return self.__class__._cache[self.db][key]\n\n    def get_for_model(self, model, for_concrete_model=True):\n        \"\"\"\n        Returns the ContentType object for a given model, creating the\n        ContentType if necessary. Lookups are cached so that subsequent lookups\n        for the same model don't hit the database.\n        \"\"\"\n        opts = self._get_opts(model, for_concrete_model)\n        try:\n            return self._get_from_cache(opts)\n        except KeyError:\n            pass\n\n        try:\n            ct = self.get(app_label=opts.app_label, model=opts.model_name)\n        except (OperationalError, ProgrammingError):\n            raise RuntimeError(\n                \"Error creating new content types. Please make sure contenttypes \"\n                \"is migrated before trying to migrate apps individually.\"\n            )\n        except self.model.DoesNotExist:\n            ct, created = self.get_or_create(\n                app_label=opts.app_label,\n                model=opts.model_name,\n                defaults={'name': opts.verbose_name_raw},\n            )\n        self._add_to_cache(self.db, ct)\n        return ct\n\n    def get_for_models(self, *models, **kwargs):\n        \"\"\"\n        Given *models, returns a dictionary mapping {model: content_type}.\n        \"\"\"\n        for_concrete_models = kwargs.pop('for_concrete_models', True)\n        results = {}\n        needed_app_labels = set()\n        needed_models = set()\n        needed_opts = set()\n        for model in models:\n            opts = self._get_opts(model, for_concrete_models)\n            try:\n                ct = self._get_from_cache(opts)\n            except KeyError:\n                needed_app_labels.add(opts.app_label)\n                needed_models.add(opts.model_name)\n                needed_opts.add(opts)\n            else:\n                results[model] = ct\n        if needed_opts:\n            cts = self.filter(\n                app_label__in=needed_app_labels,\n                model__in=needed_models\n            )\n            for ct in cts:\n                model = ct.model_class()\n                if model._meta in needed_opts:\n                    results[model] = ct\n                    needed_opts.remove(model._meta)\n                self._add_to_cache(self.db, ct)\n        for opts in needed_opts:\n            ct = self.create(\n                app_label=opts.app_label,\n                model=opts.model_name,\n                name=opts.verbose_name_raw,\n            )\n            self._add_to_cache(self.db, ct)\n            results[ct.model_class()] = ct\n        return results\n\n    def get_for_id(self, id):\n        \"\"\"\n        Lookup a ContentType by ID. Uses the same shared cache as get_for_model\n        (though ContentTypes are obviously not created on-the-fly by get_by_id).\n        \"\"\"\n        try:\n            ct = self.__class__._cache[self.db][id]\n        except KeyError:\n            ct = self.get(pk=id)\n            self._add_to_cache(self.db, ct)\n        return ct\n\n    def clear_cache(self):\n        \"\"\"\n        Clear out the content-type cache. This needs to happen during database\n        flushes to prevent caching of \"stale\" content type IDs (see\n        django.contrib.contenttypes.management.update_contenttypes for where\n        this gets called).\n        \"\"\"\n        self.__class__._cache.clear()\n\n    def _add_to_cache(self, using, ct):\n        \"\"\"Insert a ContentType into the cache.\"\"\"\n        key = (ct.app_label, ct.model)\n        self.__class__._cache.setdefault(using, {})[key] = ct\n        self.__class__._cache.setdefault(using, {})[ct.id] = ct\n\n\n@python_2_unicode_compatible\nclass ContentType(models.Model):\n    name = models.CharField(max_length=100)\n    app_label = models.CharField(max_length=100)\n    model = models.CharField(_('python model class name'), max_length=100)\n    objects = ContentTypeManager()\n\n    class Meta:\n        verbose_name = _('content type')\n        verbose_name_plural = _('content types')\n        db_table = 'django_content_type'\n        ordering = ('name',)\n        unique_together = (('app_label', 'model'),)\n\n    def __str__(self):\n        model = self.model_class()\n        if not model or self.name != model._meta.verbose_name_raw:\n            return self.name\n        else:\n            return force_text(model._meta.verbose_name)\n\n    def model_class(self):\n        \"Returns the Python model class for this type of content.\"\n        try:\n            return apps.get_model(self.app_label, self.model)\n        except LookupError:\n            return None\n\n    def get_object_for_this_type(self, **kwargs):\n        return\n        \"\"\"\n        Returns an object of this type for the keyword arguments given.\n        Basically, this is a proxy around this object_type's get_object() model\n        method. The ObjectNotExist exception, if thrown, will not be caught,\n        so code that calls this method should catch it.\n        \"\"\"\n        return self.model_class()._base_manager.using(self._state.db).get(**kwargs)\n\n    def get_all_objects_for_this_type(self, **kwargs):\n        \"\"\"\n        Returns all objects of this type for the keyword arguments given.\n        \"\"\"\n        return self.model_class()._base_manager.using(self._state.db).filter(**kwargs)\n\n    def natural_key(self):\n        return (self.app_label, self.model)\n",
  "line_no": 160,
  "line_no_percent": "91%"
}