{
  "instruction": "This code is a protocol to read data from an Arduino device and save it to a file. To use it, import the necessary modules and classes, including LineReceiver from twisted.protocols.basic, SerialPort from twisted.internet.serialport, Site from twisted.web.server, and File from twisted.web.static. Define a function called timeToArray that converts a time string to an array similar to a datetime object. Define another function called dataToFile that saves data to a file. Finally, define a class called PalmAcqProtocol that inherits from LineReceiver and takes in the wsMcuFactory, sensor, and outputdir as arguments. In this class, define methods to extract and process data from the Arduino device, and to send the data to a dispatch URL.",
  "buggy_code": "import sys, time, os, socket\nimport struct, binascii, re, csv\nfrom datetime import datetime, timedelta\n\nfrom twisted.protocols.basic import LineReceiver\nfrom twisted.internet import reactor\nfrom twisted.python import usage, log\nfrom twisted.internet.serialport import SerialPort\nfrom twisted.web.server import Site\nfrom twisted.web.static import File\n\ntry: # version > 0.8.0\n    from autobahn.wamp1.protocol import exportRpc\nexcept:\n    from autobahn.wamp import exportRpc\n\niddict = {'f': '10', 'x': '11', 'y': '12', 'z': '13', 'df': '14', 't': '30', 'rh': '33', 'p': '35', 'w': '38'}\n\n\"\"\"\n0: clientname                   -- str (atlas)\n1: timestamp (PC)               -- str (2013-01-23 12:10:32.712475)\n2: date (PC)                    -- str (2013-01-23)\n3: outtime (PC)                 -- str (12:10:32.712475)\n4: timestamp (sensor)           -- str (2013-01-23 12:10:32.712475)\n5: GPS coordinates              -- str (??.??N ??.??E)\n9: Sensor Description           -- str (to be found in the adict)\n10: f                           -- float (48633.04) [nT]\n11: x                           -- float (20401.3) [nT]\n12: y                           -- float (-30.0) [nT]\n13: z                           -- float (43229.7) [nT]\n14: df                          -- float (0.06) [nT]\n30: T (ambient)                 -- float (7.2) [C]\n31: T (sensor)                  -- float (10.0) [C]\n32: T (electronics)             -- float (12.5) [C]\n33: rh (relative humidity)      -- float (99.0) [%]\n34: T (dewpoint)                -- float (6.0) [C]\n38: W (weight)                  -- float (24.0042) [g]\n40: Error code (POS1)           -- float (80) [-]\n60: VDD (support voltage)       -- float (5.02) [V]\n61: VAD (measured voltage)      -- float (2.03) [V]\n62: VIS (measured voltage)      -- float (0.00043) [V]\n\"\"\"\n\ndef timeToArray(timestring):\n    try:\n        splittedfull = timestring.split(' ')\n        splittedday = splittedfull[0].split('-')\n        splittedsec = splittedfull[1].split('.')\n        splittedtime = splittedsec[0].split(':')\n        datearray = splittedday + splittedtime\n        datearray.append(splittedsec[1])\n        datearray = map(int,datearray)\n        return datearray\n    except:\n        log.msg('Error while extracting time array')\n        return []\n\ndef dataToFile(outputdir, sensorid, filedate, bindata, header):\n    try:\n        hostname = socket.gethostname()\n        path = os.path.join(outputdir,hostname,sensorid)\n        if not os.path.exists(path):\n            os.makedirs(path)\n        savefile = os.path.join(path, sensorid+'_'+filedate+\".bin\")\n        if not os.path.isfile(savefile):\n            with open(savefile, \"wb\") as myfile:\n                myfile.write(header + \"\\n\")\n                myfile.write(bindata + \"\\n\")\n        else:\n            with open(savefile, \"a\") as myfile:\n                myfile.write(bindata + \"\\n\")\n    except:\n        log.err(\"PalmAcq - Protocol: Error while saving file\")\n\n\n\nclass PalmAcqProtocol(LineReceiver):\n    \"\"\"\n    Protocol to read Arduino data (usually from ttyACM0)\n    Tested so far only for Arduino Uno on a Linux machine\n    The protocol works only if the serial output follows the MagPy convention:\n    Up to 99 Sensors are supported identified by unique sensor names and ID's.\n\n    ARDUINO OUTPUT:\n        - serial output on ttyACM0 needs to follow the MagPy definition:\n            Three data sequences are supported:\n            1.) The meta information\n                The meta information line contains all information for a specific sensor.\n                If more than one sensor is connected, then several meta information\n                lines should be sent (e.g. M1:..., M2:..., M99:...)\n                Meta lines should be resent once in a while (e.g. every 10-100 data points)\n                Example:\n                     M1: SensorName: MySensor, SensorID: 12345, SensorRevision: 0001\n            2.) The header line\n                The header line contains information on the provided data for each sensor.\n                The typical format includes the MagPy key, the actual Variable and the unit.\n                Key and Variable are separeted by an underscore, unit is provided in brackets.\n                Like the Meta information the header should be sent out once in a while\n                Example:\n                     H1: f_F [nT], t1_Temp [deg C], var1_Quality [None], var2_Pressure [mbar]\n            3.) The data line:\n                The data line containes all data from a specific sensor\n                Example:\n                     D1: 46543.7898, 6.9, 10, 978.000\n\n         - recording starts after meta and header information have been received\n\n    MARTAS requirements:\n         - add the following line to the sensor.txt\n            ARDUINO             ACM0    9600\n         - on the MARTAS machine an additional information file will be created\n           containing the sensor information for connected ARDUINO boards:\n           arduinolist.csv:\n              \"HMC5883_12345_0001\",\"['x', 'y', 'z']\"\n           This file is used by the MARCOS machine to identify connected sensors and their keys\n\n    \"\"\"\n    delimiter = \"\\r\"\n\n    def __init__(self, wsMcuFactory, sensor, outputdir):\n        self.wsMcuFactory = wsMcuFactory\n        self.sensorid = sensor\n        self.hostname = socket.gethostname()\n        self.outputdir = outputdir\n        self.sensor = ''\n        self.sensordict = {}\n        self.ConversionConstant = 40/4/float(int(\"0x800000\",16))\n        eventstring = \"evt0,evt1,evt3,evt11,evt12,evt13,evt32,evt60,evt99\"\n        self.eventlist = eventstring.split(',')\n\n    def connectionMade(self):\n        log.msg('%s connected.' % self.sensorid)\n\n    def extractPalmAcqData(self, line):\n        \"\"\"\n         Method to convert hexadecimals to doubles\n         Returns a data array\n        \"\"\"\n        if line.startswith('*'):\n             try:\n                 data = []\n                 chunks = []\n                 line = line.strip('*')\n                 chunks.append(line[:6])\n                 chunks.append(line[6:12])\n                 chunks.append(line[12:18])\n                 trigger = line[18]\n                 ar = line.split(':')\n                 if len(ar) == 2:\n                     extended = ar[1]\n                     chunks.append(extended[:4])\n                     chunks.append(extended[4:8])\n                     chunks.append(extended[8:12])\n                     chunks.append(extended[12:16])\n                     chunks.append(extended[16:20])\n                 for idx, chunk in enumerate(chunks):\n                     if len(chunk) == 6:\n                         val = hex(int('0x'+chunk,16) ^ int('0x800000',16))\n                         val = hex(int(val,16) - int('0x800000',16))\n                         val = float(int(val,16)) * self.ConversionConstant\n                     elif len(chunk) == 4:\n                         val = hex(int('0x'+chunk,16) ^ int('0x8000',16))\n                         val = hex(int(val,16) - int('0x8000',16))\n                         if idx == 3:\n                             val = float(int(val,16)) * 0.000575 + 1.0\n                         elif idx == 4:\n                             val = float(int(val,16)) / 128.0\n                         elif idx > 4:\n                             val = float(int(val,16)) / 8000.0\n\n                     data.append(val)\n\n\n                 return data, trigger\n             except:\n                 return [], 'N'\n        else:\n             return [], 'N'\n\n    def processPalmAcqData(self, data):\n        return\n        \"\"\"Convert raw ADC counts into SI units as per datasheets\"\"\"\n        printdata = False\n\n        currenttime = datetime.utcnow()\n        outdate = datetime.strftime(currenttime, \"%Y-%m-%d\")\n        filename = outdate\n        outtime = datetime.strftime(currenttime, \"%H:%M:%S\")\n\n\n        timestamp = datetime.strftime(currenttime, \"%Y-%m-%d %H:%M:%S.%f\")\n        datearray = timeToArray(timestamp)\n        packcode = '6hL'\n\n        x = data[0]\n        y = data[1]\n        z = data[2]\n        v = 0.0\n        t = 0.0\n        p = 0.0\n        q = 0.0\n        r = 0.0\n        if len(data) > 4:\n            v = data[3]\n            t = data[4]\n            p = data[5]\n            q = data[6]\n            r = data[7]\n\n        datearray.append(x)\n        datearray.append(y)\n        datearray.append(z)\n        datearray.append(int(float(v)*10000))\n        datearray.append(int(float(t)*10000))\n        datearray.append(p)\n        datearray.append(q)\n        datearray.append(r)\n        packcode = packcode + 'fffllfff'\n        multiplier = [1,1,1,10000,10000,1,1,1]\n\n        try:\n            data_bin = struct.pack(packcode,*datearray)\n        except:\n            log.msg('Error while packing binary data')\n            pass\n\n        header = \"# MagPyBin %s %s %s %s %s %s %d\" % (self.sensorid, \"[x,y,z,v,t,p,q,r]\", \"[x,y,z,v,t,p,q,r]\", \"[V,V,V,V,C,V,V,V]\", str(multiplier).replace(\" \",\"\"), packcode, struct.calcsize(packcode))\n\n        if printdata:\n            print timestamp\n\n        try:\n            dataToFile(self.outputdir, self.sensorid, filename, data_bin, header)\n        except:\n            log.msg('Saving failed')\n            pass\n\n        evt0 = {'id': 0, 'value': self.hostname}\n        evt1 = {'id': 1, 'value': timestamp}\n        evt3 = {'id': 3, 'value': outtime}\n        evt11 = {'id': 11, 'value': x}\n        evt12 = {'id': 12, 'value': y}\n        evt13 = {'id': 13, 'value': z}\n        evt32 = {'id': 32, 'value': t}\n        evt60 = {'id': 60, 'value': v}\n        evt99 = {'id': 99, 'value': 'eol'}\n\n        return evt0,evt1,evt3,evt11,evt12,evt13,evt32,evt60,evt99\n\n\n    def lineReceived(self, line):\n\n        data=[]\n\n        if line:\n            data, trigger = self.extractPalmAcqData(line)\n\n        if len(data) > 1:\n            evt0,evt1,evt3,evt11,evt12,evt13,evt32,evt60,evt99 = self.processPalmAcqData(data)\n\n            dispatch_url =  \"http://example.com/\"+self.hostname+\"/pal#\"+self.sensorid+\"-value\"\n\n            for event in self.eventlist:\n                self.wsMcuFactory.dispatch(dispatch_url, eval(event))\n",
  "line_no": 181,
  "line_no_percent": "69%"
}