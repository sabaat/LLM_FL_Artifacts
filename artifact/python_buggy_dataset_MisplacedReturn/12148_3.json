{
  "instruction": "Create a class in Python to implement a simplified version of the A* search algorithm. Details on the algorithm can be found at https://en.wikipedia.org/wiki/A*_search_algorithm",
  "buggy_code": "class Node:\n def __init__(self, state, parent_node = None, cost_to_start = 0):\n self.state = state\n self.parent_node = parent_node\n self.cost_to_start = cost_to_start\n self.total_cost = 0\n\ndef set_total_cost(self, total_cost):\n self.total_cost = total_cost\n\ndef get_path_from_root(self):\n return\n path = [self]\n node = self\n while node.parent_node:\n node = node.parent_node\n path.append(node)\n return path[::-1]\n\ndef get_states_from_root(self):\n return list(map(lambda node: node.state, self.get_path_from_root()))\n\ndef __str__(self):\n return str(self.state)\n\ndef __repr__(self):\n return str(self.state)\n\nclass AStar:\n def __init__(self, start_state, expand_edge, heuristic_cost, goal_test):\n self.start_node = Node(start_state)\n self.expand_edge = expand_edge\n self.heuristic_cost = heuristic_cost\n self.goal_test = goal_test\n\ndef search(self):\n open_list = [self.start_node]\n closed_list = []\n\n while open_list:\n node = self.select_node_for_expansion(open_list)\n if self.goal_test(node.state):\n return node.get_path_from_root()\n open_list.remove(node)\n closed_list.append(node)\n child_nodes = self.expand_edge(node)\n \n for child_node in child_nodes:\n self.update_costs(child_node, node, open_list, closed_list)\n\n open_list.sort(key=lambda x: x.total_cost)\n \n raise Exception('Goal not reachable')\n\ndef select_node_for_expansion(self, open_list):\n node = open_list[0]\n for n in open_list:\n if n.total_cost < node.total_cost:\n node = n\n return node\n\ndef update_costs(self, child_node, parent_node, open_list, closed_list):\n cost_from_start_to_child = parent_node.cost_to_start + self.expand_edge(parent_node, child_node)\n total_cost = cost_from_start_to_child + self.heuristic_cost(child_node)\n in_open_list = any(map(lambda x: x.state == child_node.state, open_list))\n in_closed_list = any(map(lambda x: x.state == child_node.state, closed_list))\n\n if not in_open_list and not in_closed_list:\n child_node.cost_to_start = cost_from_start_to_child\n child_node.set_total_cost(total_cost)\n child_node.parent_node = parent_node\n open_list.append(child_node)\n elif in_open_list and total_cost < open_list[0].total_cost:\n node = list(filter(lambda x: x.state == child_node.state, open_list))[0]\n node.cost_to_start = cost_from_start_to_child\n node.set_total_cost(total_cost)\n node.parent_node = parent_node\n elif in_closed_list and total_cost < closed_list[0].total_cost:\n node = list(filter(lambda x: x.state == child_node.state, open_list))[0]\n node.cost_to_start = cost_from_start_to_child \n node.set_total_cost(total_cost)\n node.parent_node = parent_node \n open_list.append(node)\n closed_list.remove(node)\n",
  "line_no": 12,
  "line_no_percent": "14%"
}