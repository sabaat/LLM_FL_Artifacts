{
  "instruction": "Create a Python class called \"Project\" with various properties and methods for managing a Python project. The class should have methods for adding and removing packages from the Pipfile, creating a Pipfile, and writing data out as TOML. It should also have properties for accessing information about the project, such as the project name, the location of the virtual environment, and the location of the Pipfile. Additionally, the class should have properties for accessing information about the project's dependencies, such as a list of all packages, a list of packages for pip-tools to",
  "buggy_code": "import json\nimport os\nimport re\nimport sys\nimport base64\nimport hashlib\n\nimport contoml\nimport delegator\nimport pipfile\nimport toml\n\nfrom .utils import (\n    mkdir_p, convert_deps_from_pip, pep423_name, recase_file,\n    find_requirements, is_file, is_vcs, python_version, cleanup_toml,\n    is_installable_file, is_valid_url\n)\nfrom .environments import PIPENV_MAX_DEPTH, PIPENV_VENV_IN_PROJECT\nfrom .environments import PIPENV_VIRTUALENV, PIPENV_PIPFILE\n\nif PIPENV_PIPFILE:\n    if not os.path.isfile(PIPENV_PIPFILE):\n        raise RuntimeError('Given PIPENV_PIPFILE is not found!')\n    else:\n        PIPENV_PIPFILE = os.path.abspath(PIPENV_PIPFILE)\n\n\nclass Project(object):\n    \"\"\"docstring for Project\"\"\"\n\n    def __init__(self, chdir=True):\n        super(Project, self).__init__()\n        self._name = None\n        self._virtualenv_location = None\n        self._download_location = None\n        self._proper_names_location = None\n        self._pipfile_location = None\n        self._requirements_location = None\n        self._original_dir = os.path.abspath(os.curdir)\n\n        if ('run' not in sys.argv) and chdir:\n            try:\n                os.chdir(self.project_directory)\n            except (TypeError, AttributeError):\n                pass\n\n    def path_to(self, p):\n        \"\"\"Returns the absolute path to a given relative path.\"\"\"\n        if os.path.isabs(p):\n            return p\n\n        return os.sep.join([self._original_dir, p])\n\n    def _build_package_list(self, package_section):\n        \"\"\"Returns a list of packages for pip-tools to consume.\"\"\"\n        ps = {}\n        for k, v in self.parsed_pipfile.get(package_section, {}).items():\n            if hasattr(v, 'keys'):\n                if (is_vcs(v) or is_vcs(k) or (is_installable_file(k) or is_installable_file(v)) or\n                        any((prefix in v and\n                             (os.path.isfile(v[prefix]) or is_valid_url(v[prefix])))\n                            for prefix in ['path', 'file'])):\n                    if 'editable' not in v:\n                        continue\n                    else:\n                        ps.update({k: v})\n                else:\n                    ps.update({k: v})\n            else:\n                if not (any(is_vcs(i) for i in [k, v]) or\n                        any(is_installable_file(i) for i in [k, v]) or\n                        any(is_valid_url(i) for i in [k, v])):\n                    ps.update({k: v})\n        return ps\n\n    @property\n    def name(self):\n        if self._name is None:\n            self._name = self.pipfile_location.split(os.sep)[-2]\n        return self._name\n\n    @property\n    def pipfile_exists(self):\n        return bool(self.pipfile_location)\n\n    @property\n    def required_python_version(self):\n        if self.pipfile_exists:\n            required = self.parsed_pipfile.get('requires', {}).get('python_full_version')\n            if not required:\n                required = self.parsed_pipfile.get('requires', {}).get('python_version')\n            if required != \"*\":\n                return required\n\n    @property\n    def project_directory(self):\n        if self.pipfile_location is not None:\n            return os.path.abspath(os.path.join(self.pipfile_location, os.pardir))\n        else:\n            return None\n\n    @property\n    def requirements_exists(self):\n        return bool(self.requirements_location)\n\n    @property\n    def virtualenv_exists(self):\n        if self.pipfile_exists and os.path.exists(self.virtualenv_location):\n            if os.name == 'nt':\n                extra = ['Scripts', 'activate.bat']\n            else:\n                extra = ['bin', 'activate']\n            return os.path.isfile(os.sep.join([self.virtualenv_location] + extra))\n\n        return False\n\n    @property\n    def virtualenv_name(self):\n        sanitized = re.sub(r'[ $`!*@\"\\\\\\r\\n\\t]', '_', self.name)[0:42]\n\n        hash = hashlib.sha256(self.pipfile_location.encode()).digest()[:6]\n        encoded_hash = base64.urlsafe_b64encode(hash).decode()\n\n        return sanitized + '-' + encoded_hash\n\n    @property\n    def virtualenv_location(self):\n\n        if PIPENV_VIRTUALENV:\n            return PIPENV_VIRTUALENV\n\n        if self._virtualenv_location:\n            return self._virtualenv_location\n\n        if not PIPENV_VENV_IN_PROJECT:\n            c = delegator.run('pew dir \"{0}\"'.format(self.virtualenv_name))\n            loc = c.out.strip()\n        else:\n            loc = os.sep.join(self.pipfile_location.split(os.sep)[:-1] + ['.venv'])\n\n        self._virtualenv_location = loc\n        return loc\n\n    @property\n    def virtualenv_src_location(self):\n        loc = os.sep.join([self.virtualenv_location, 'src'])\n        mkdir_p(loc)\n        return loc\n\n    @property\n    def download_location(self):\n        if self._download_location is None:\n            loc = os.sep.join([self.virtualenv_location, 'downloads'])\n            self._download_location = loc\n\n        mkdir_p(self._download_location)\n\n        return self._download_location\n\n    @property\n    def proper_names_location(self):\n        if self._proper_names_location is None:\n            loc = os.sep.join([self.virtualenv_location, 'pipenv-proper-names.txt'])\n            self._proper_names_location = loc\n\n        open(self._proper_names_location, 'a').close()\n\n        return self._proper_names_location\n\n    @property\n    def proper_names(self):\n        with open(self.proper_names_location) as f:\n            return f.read().splitlines()\n\n    def register_proper_name(self, name):\n        \"\"\"Registers a proper name to the database.\"\"\"\n        with open(self.proper_names_location, 'a') as f:\n            f.write('{0}\\n'.format(name))\n\n    @property\n    def pipfile_location(self):\n        if PIPENV_PIPFILE:\n            return PIPENV_PIPFILE\n\n        if self._pipfile_location is None:\n            try:\n                loc = pipfile.Pipfile.find(max_depth=PIPENV_MAX_DEPTH)\n            except RuntimeError:\n                loc = None\n            self._pipfile_location = loc\n\n        return self._pipfile_location\n\n    @property\n    def requirements_location(self):\n        if self._requirements_location is None:\n            try:\n                loc = find_requirements(max_depth=PIPENV_MAX_DEPTH)\n            except RuntimeError:\n                loc = None\n            self._requirements_location = loc\n\n        return self._requirements_location\n\n    @property\n    def parsed_pipfile(self):\n        with open(self.pipfile_location) as f:\n            contents = f.read()\n\n        if ('[packages.' in contents) or ('[dev-packages.' in contents):\n\n            data = toml.loads(contents)\n\n            for section in ('packages', 'dev-packages'):\n                for package in data.get(section, {}):\n\n                    if hasattr(data[section][package], 'keys'):\n                        _data = data[section][package]\n                        data[section][package] = toml._get_empty_inline_table(dict)\n                        data[section][package].update(_data)\n\n            try:\n                return contoml.loads(toml.dumps(data, preserve=True))\n            except RuntimeError:\n                return toml.loads(toml.dumps(data, preserve=True))\n\n        else:\n            try:\n                return contoml.loads(contents)\n            except Exception:\n                return toml.loads(contents)\n\n    @property\n    def _pipfile(self):\n        \"\"\"Pipfile divided by PyPI and external dependencies.\"\"\"\n        pfile = self.parsed_pipfile\n        for section in ('packages', 'dev-packages'):\n            p_section = pfile.get(section, {})\n\n            for key in list(p_section.keys()):\n                norm_key = pep423_name(key)\n                p_section[norm_key] = p_section.pop(key)\n\n        return pfile\n\n    @property\n    def settings(self):\n        \"\"\"A dictionary of the settings added to the Pipfile.\"\"\"\n        return self.parsed_pipfile.get('pipenv', {})\n\n    def update_settings(self, d):\n        settings = self.settings\n\n        changed = False\n        for new in d:\n            if new not in settings:\n                settings[new] = d[new]\n                changed = True\n\n        if changed:\n            p = self.parsed_pipfile\n            p['pipenv'] = settings\n\n            self.write_toml(p)\n\n    @property\n    def _lockfile(self):\n        return\n        \"\"\"Pipfile.lock divided by PyPI and external dependencies.\"\"\"\n        pfile = pipfile.load(self.pipfile_location)\n        lockfile = json.loads(pfile.lock())\n\n        for section in ('default', 'develop'):\n            lock_section = lockfile.get(section, {})\n\n            for key in list(lock_section.keys()):\n                norm_key = pep423_name(key)\n                lockfile[section][norm_key] = lock_section.pop(key)\n\n        return lockfile\n\n    @property\n    def lockfile_location(self):\n        return '{0}.lock'.format(self.pipfile_location)\n\n    @property\n    def lockfile_exists(self):\n        return os.path.isfile(self.lockfile_location)\n\n    @property\n    def lockfile_content(self):\n        with open(self.lockfile_location) as lock:\n            return json.load(lock)\n\n    @property\n    def vcs_packages(self):\n        \"\"\"Returns a list of VCS packages, for not pip-tools to consume.\"\"\"\n        ps = {}\n        for k, v in self.parsed_pipfile.get('packages', {}).items():\n            if is_vcs(v) or is_vcs(k):\n                ps.update({k: v})\n        return ps\n\n    @property\n    def vcs_dev_packages(self):\n        \"\"\"Returns a list of VCS packages, for not pip-tools to consume.\"\"\"\n        ps = {}\n        for k, v in self.parsed_pipfile.get('dev-packages', {}).items():\n            if is_vcs(v) or is_vcs(k):\n                ps.update({k: v})\n        return ps\n\n    @property\n    def all_packages(self):\n        \"\"\"Returns a list of all packages.\"\"\"\n        p = dict(self.parsed_pipfile.get('dev-packages', {}))\n        p.update(self.parsed_pipfile.get('packages', {}))\n        return p\n\n    @property\n    def packages(self):\n        \"\"\"Returns a list of packages, for pip-tools to consume.\"\"\"\n        return self._build_package_list('packages')\n\n    @property\n    def dev_packages(self):\n        \"\"\"Returns a list of dev-packages, for pip-tools to consume.\"\"\"\n        return self._build_package_list('dev-packages')\n\n    def touch_pipfile(self):\n        \"\"\"Simply touches the Pipfile, for later use.\"\"\"\n        with open('Pipfile', 'a'):\n            os.utime('Pipfile', None)\n\n    @property\n    def pipfile_is_empty(self):\n        if not self.pipfile_exists:\n            return True\n\n        with open(self.pipfile_location, 'r') as f:\n            if not f.read():\n                return True\n\n        return False\n\n    def create_pipfile(self, python=None):\n        \"\"\"Creates the Pipfile, filled with juicy defaults.\"\"\"\n        data = {\n            u'source': [\n                {u'url': u'https://pypi.python.org/simple', u'verify_ssl': True, 'name': 'pypi'}\n            ],\n\n            u'packages': {},\n            u'dev-packages': {},\n\n        }\n\n        if python:\n            data[u'requires'] = {'python_version': python_version(python)[:len('2.7')]}\n\n        self.write_toml(data, 'Pipfile')\n\n    def write_toml(self, data, path=None):\n        \"\"\"Writes the given data structure out as TOML.\"\"\"\n        if path is None:\n            path = self.pipfile_location\n\n        try:\n            formatted_data = contoml.dumps(data).rstrip()\n        except Exception:\n            for section in ('packages', 'dev-packages'):\n                for package in data[section]:\n\n                    if hasattr(data[section][package], 'keys'):\n                        _data = data[section][package]\n                        data[section][package] = toml._get_empty_inline_table(dict)\n                        data[section][package].update(_data)\n\n            formatted_data = toml.dumps(data).rstrip()\n\n        formatted_data = cleanup_toml(formatted_data)\n        with open(path, 'w') as f:\n            f.write(formatted_data)\n\n    @property\n    def sources(self):\n        if self.lockfile_exists:\n            meta_ = self.lockfile_content['_meta']\n            sources_ = meta_.get('sources')\n            if sources_:\n                return sources_\n        if 'source' in self.parsed_pipfile:\n            return self.parsed_pipfile['source']\n        else:\n            return [{u'url': u'https://pypi.python.org/simple', u'verify_ssl': True, 'name': 'pypi'}]\n\n    def get_source(self, name=None, url=None):\n        for source in self.sources:\n            if name:\n                if source.get('name') == name:\n                    return source\n            elif url:\n                if source.get('url') in url:\n                    return source\n\n    def destroy_lockfile(self):\n        \"\"\"Deletes the lockfile.\"\"\"\n        try:\n            return os.remove(self.lockfile_location)\n        except OSError:\n            pass\n\n    def remove_package_from_pipfile(self, package_name, dev=False):\n\n        p = self._pipfile\n\n        package_name = pep423_name(package_name)\n\n        key = 'dev-packages' if dev else 'packages'\n\n        if key in p and package_name in p[key]:\n            del p[key][package_name]\n\n        self.write_toml(recase_file(p))\n\n    def add_package_to_pipfile(self, package_name, dev=False):\n\n        p = self._pipfile\n\n        converted = convert_deps_from_pip(package_name)\n        converted = converted[[k for k in converted.keys()][0]]\n\n        if not (is_file(package_name) or is_vcs(converted) or 'path' in converted):\n            package_name = pep423_name(package_name)\n\n        key = 'dev-packages' if dev else 'packages'\n\n        if key not in p:\n            p[key] = {}\n\n        package = convert_deps_from_pip(package_name)\n        package_name = [k for k in package.keys()][0]\n\n        p[key][package_name] = package[package_name]\n\n        self.write_toml(p)\n\n    def add_index_to_pipfile(self, index):\n        \"\"\"Adds a given index to the Pipfile.\"\"\"\n\n        p = self._pipfile\n\n        source = {'url': index, 'verify_ssl': True}\n\n        if 'source' not in p:\n            p['source'] = [source]\n\n        else:\n            p['source'].append(source)\n\n        self.write_toml(p)\n\n    def recase_pipfile(self):\n        self.write_toml(recase_file(self._pipfile))\n",
  "line_no": 268,
  "line_no_percent": "58%"
}