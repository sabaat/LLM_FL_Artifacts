{
  "instruction": "The given code is a Python function that creates a natural language game creation program. To use the program, call the function \"start_dialog\" with an optional output file name as an argument. The program will prompt the user for input to define the game environment, including board size, number of players, game pieces, player moves, win conditions, and game end conditions. The program will then generate a GDL file based on the user's input and write it to the output file. If no output file name is provided, the program will write the GDL file to a file named \"test.txt\".",
  "buggy_code": "import re\nimport nltk\nimport ngdl_classes\nimport global_vars\nimport ngdl_parse\nimport ngdl_write\n\ndef start_dialog(output_file=\"test.txt\"):\n    if not global_vars.initialized:\n        global_vars.init()\n    else:\n        reset_global_vars()\n\n    output = open(output_file, \"w\")\n    print \"Welcome to the natural language game creation program for general game playing!\"\n    board_size_dialog()\n    player_num_dialog()\n    game_pieces_dialog()\n    player_move_dialog()\n    goal_dialog()\n    terminal_dialog()\n    ngdl_write.write_gdl_file(output)\n    output.close()\n\ndef reset_global_vars():\n    global_vars.write_queue = [[\"noop\", []], [\"goals\", []], [\"terminal\", []], [\"distinct_cells\", []], [\"successors\", [50]]]\n    global_vars.game = ngdl_classes.Game()\n    \ndef board_size_dialog():\n    in_board_size = raw_input(\"What size would you like your board to be?: \")\n    valid_input = re.search(\"([0-9]+)\\s?(by|x|X)\\s?([0-9]+)\", in_board_size)\n\n    while not valid_input:\n        print \"Sorry, I can't understand that input yet, can you try again?\"\n        in_board_size = raw_input(\"What size would you like your game to be?: \")\n        valid_input = re.search(\"([0-9]+)\\s?(by|x|X)\\s?([0-9]+)\", in_board_size)\n\n    board_size = (valid_input.group(1), valid_input.group(3))\n\n\n    global_vars.game.board = ngdl_classes.Board((int(board_size[0]), int(board_size[1])))\n    global_vars.write_queue.append([\"board\" , []])\n\ndef player_num_dialog():\n    in_player_num = raw_input(\"How many players does your game have?: \")\n    valid_input = re.search(\"[0-9]+\", in_player_num)\n\n    while not valid_input:\n        print \"Sorry, I can't understand that input yet, can you try again?\"\n        in_player_num = raw_input(\"How many players does your game have?: \")\n        valid_input = re.search(\"[0-9]+\", in_player_num)\n\n    num_players = int(valid_input.group())\n\n    for p in range(1,num_players+1):\n        global_vars.game.players.append(ngdl_classes.Player(\"player\" + str(p)))\n\n    global_vars.write_queue.append([\"players\", []])\n\ndef game_pieces_dialog():\n\n    for player in global_vars.game.players:\n        in_piece_names = raw_input(\"What types of pieces does \" + player.name + \" have?: \")\n        pieces = re.findall(\"([0-9]*)\\s|^([^\\W\\d]+)\", in_piece_names)\n\n        for p in pieces:\n            global_vars.game.pieces[p[1]] = ngdl_classes.Piece(p[1])\n            player.pieces.append(p[1])\n\n        on_board_response = raw_input(\"Do any of \" + player.name + \"'s pieces start on the board?: \")\n        on_board_response = on_board_response.lower()\n        if not re.match(\"[no|n]\", on_board_response):\n            for p in pieces:\n\n                if p[0] == \"\" or int(p[0]) > 1:\n                    p_positions = raw_input(\"What are the starting positions <col, row> of the \" +\n                                            p[1] + \" that start on the board? (enter to skip): \")\n                else:\n                    p_positions = raw_input(\"What is the starting position <col, row> of the \" +\n                                            p[1] + \" if it starts on the board? (enter to skip): \")\n\n                positions = re.findall(\"([0-9]+),\\s?([0-9]+)\", p_positions)\n                if positions:\n                    for pos in positions:\n                        global_vars.game.board.starting_positions[(int(pos[0]), int(pos[1]))] = player.name + \" \" + piece.name\n                \n\ndef player_move_dialog():\n    move_conditions = raw_input(\"What can a player do on their turn?: \")\n    parse_trees = ngdl_parse.parse(move_conditions, 2)\n        \n    nltk_tree = parse_trees[0]\n    tree = translate_tree(nltk_tree)\n\n    conditions = process_condition(tree)\n    \n    action = tree.find_closest_node(\"ACTION\")\n    while action.children:\n        index = [child.name for child in action.children].index(\"ACTION\")\n        action = action[index]\n\n    if action.value == \"drop\":\n        drop_response = raw_input(\"By 'drop', do you mean dropping a piece like in Connect-4, or placing a piece like in Shogi?: \")        \n        drop_response.lower()\n        if re.match(\"[connect\\-4|drop]\", drop_response):\n            global_vars.write_queue.append([\"drop_occupant_conditions\", [[conditions]]])\n            global_vars.write_queue.append([\"perpetuate_untouched_cells\", [[\"drop\"]]])\n        else:\n            global_vars.write_queue.append([\"place_occupant_conditions\", [[conditions]]])\n            global_vars.write_queue.append([\"perpetuate_untouched_cells\", [[\"place\"]]])\n    elif action.value in [\"place\", \"mark\"]:\n        global_vars.write_queue.append([\"place_occupant_conditions\", [[conditions]]])\n        global_vars.write_queue.append([\"perpetuate_untouched_cells\", [[\"place\"]]])\n            \n\n\n\ndef goal_dialog():\n    return\n    win_conditions = raw_input(\"How does a player win?: \")\n    parse_trees = ngdl_parse.parse(win_conditions, 1)\n\n    nltk_tree = parse_trees[0]\n    tree = translate_tree(nltk_tree)\n\n    conditions_tree = tree.find_closest_node(\"COND\")\n    conditions = process_condition(conditions_tree)\n    global_vars.write_queue.append([\"win_conditions\", [[conditions], \"\"]])\n\ndef terminal_dialog():\n    game_end_conditions = raw_input(\"Aside from a player winning, how does the game end?: \")\n    parse_trees = ngdl_parse.parse(game_end_conditions, 1)\n\n    nltk_tree = parse_trees[0]\n    tree = translate_tree(nltk_tree)\n\n    conditions_tree = tree.find_closest_node(\"COND\")\n    conditions = process_condition(conditions_tree)\n    global_vars.write_queue.append([\"game_end_conditions\", [[conditions]]])\n\ndef process_result(result):\n    return\n\ndef process_conditions(conds):\n    conditions = []\n    if \"OR\" in [child.name for child in conds.children]:\n        conditions.append(\"OR\")\n        for child in conds.children:\n            if child.name == \"COND\":\n                conditions.append(process_condition(child))\n    elif \"AND\" in [child.name for child in conds.children]:\n        conditions.append(\"AND\")\n        for child in conds.children:\n            if child.name == \"COND\":\n                conditions.append(process_condition(child))\n    else:\n        conditions.append(\"COND\")\n        conditions.append(process_condition(conds))\n    return conditions\n\ndef process_condition(cond_node):\n    for leaf in cond_node.leaves():\n        if leaf.value in cond_dictionary:\n            cond_definition = cond_dictionary[leaf.value]\n            slot_values = []\n            for slot in cond_definition[0]:\n                slot_node = leaf.find_closest_node(slot[0])\n                if not slot_node:\n                    if len(slot) == 2:\n                        slot_values.append(slot[1])\n                    else:\n                        print \"Slot fill error1!\"\n                elif cond_node not in slot_node.ancestors():\n                    if len(slot) == 2:\n                        slot_values.append(slot[1])\n                    else:\n                        print \"Slot fill error2!\"\n                elif slot_node.name == \"PLAYER\":\n                    slot_values.append(process_player(slot_node))\n                elif slot_node.name == \"BOARD_PART\":\n                    slot_values.append(process_board_part(slot_node))\n                elif slot_node.name == \"PIECE\":\n                    slot_values.append(process_piece(slot_node))\n                else:\n                    slot_values.append(slot_node.value)\n\n            if cond_definition[-1]:\n                global_vars.write_queue.append([cond_definition[2], slot_values])\n            else:\n                global_vars.write_queue.append([cond_definition[2], []])\n            return cond_definition[1].format(*slot_values)\n                    \n\ndef process_player(player_node):\n    return \"?player\"\n\ndef process_board_part(board_part_node):\n    square_equivalents = [\"cell\"]\n    board_part = board_part_node\n    while board_part.children:\n        index = [child.name for child in board_part.children].index(\"BOARD_PART\")\n        board_part = board_part[index]\n    if board_part.value in square_equivalents:\n        return \"square\"\n    else:\n        return board_part.value\n\ndef process_piece(piece_node):\n    piece = piece_node\n    while piece.children:\n        index = [child.name for child in piece.children].index(\"PIECE\")\n        piece = piece[index]\n\n    if piece.value == \"piece\":\n        return \"?piece\"\n    else:\n        return piece.value\n\n\ndef translate_tree(nltk_tree):\n    if nltk_tree.height() == 2:\n        tree = ngdl_classes.Tree(nltk_tree.node)\n        tree.value = nltk_tree[0]\n        return tree\n        \n    tree = ngdl_classes.Tree(nltk_tree.node)\n    for subtree in nltk_tree:\n        if type(subtree) == str:\n            tree.value = subtree\n        else:\n            tree.children.append(translate_tree(subtree))\n\n    for subtree in tree.children:\n        subtree.parent = tree\n\n    return tree\n        \n\ncond_dictionary = {\"empty\": [[[\"BOARD_PART\"], [\"NUM\", \"?col\"], [\"NUM\", \"?row\"]], \"(empty {0} {1} {2})\", \"board_part_empty\", False],\n                   \"open\": [[[\"BOARD_PART\"], [\"NUM\", \"?col\"], [\"NUM\", \"?row\"]], \"(open {0} {1} {2})\", \"board_part_open\", False],\n                   \"full\": [[[\"BOARD_PART\"], [\"NUM\", \"?col\"], [\"NUM\", \"?row\"]], \"(full {0} {1} {2})\", \"board_part_full\", False],\n                   \"in-a-row\": [[[\"NUM\"], [\"PLAYER\", \"?player\"], [\"PIECE\", \"?piece\"]], \"({0}_in_a_row {1} {2})\", \"x_in_a_row\", True]\n                   }\n",
  "line_no": 119,
  "line_no_percent": "49%"
}