{
  "instruction": "This code is a Python library for crafting SAP's network protocols packets. To use it, import the necessary modules and classes from the library and call the appropriate functions and methods. The library includes various custom fields and packet classes for crafting SAP packets. The library is distributed under the terms of the GNU General Public License.",
  "buggy_code": "import struct\nfrom datetime import datetime\nfrom scapy.config import conf\nfrom scapy.packet import Packet\nfrom scapy.asn1fields import (ASN1F_CHOICE, ASN1F_field, ASN1_Error, ASN1F_badsequence, BER_Decoding_Error)\nfrom scapy.volatile import (RandNum, RandTermString, RandBin)\nfrom scapy.fields import (MultiEnumField, StrLenField, Field, StrFixedLenField, StrField, PacketListField, LongField)\n\n\ndef saptimestamp_to_datetime(timestamp):\n    \"\"\"Converts a timestamp in \"SAP format\" to a datetime object. Time zone\n    looks to be fixed at GMT+1.\"\"\"\n    return datetime.utcfromtimestamp((int(timestamp) & 0xFFFFFFFF) + 1000000000)\n\n\nclass PacketNoPadded(Packet):\n    \"\"\"Regular scapy packet with no padding.\n    \"\"\"\n    def extract_padding(self, s):\n        return '', s\n\n\nclass RandByteReduced(RandNum):\n    \"\"\"RandByte that only returns random values between 0 and x2a. Used while\n    performing some fuzz to reduce the test cases space.\n\n    \"\"\"\n    def __init__(self):\n        RandNum.__init__(self, 0, 0x2a)\n\n\nclass ByteMultiEnumKeysField(MultiEnumField):\n    \"\"\"MultiEnumField that picks a reduced number of values. Used for fuzzing\n    Byte fields with reduced number of values.\n\n    \"\"\"\n    def randval(self):\n        return RandByteReduced()\n\n\nclass MutablePacketField(StrLenField):\n    \"\"\"Packet field that mutates the class according to a list of evaluators.\n    The evaluators are run against the packet and given to a class getter.\n\n    If the class can't be found, the field is treated as a StrLenField.\n    \"\"\"\n    __slots__ = [\"length_from\", \"evaluators\", \"_get_class\"]\n\n    def __init__(self, name, default, length_from, get_class, evaluators=None):\n        \"\"\"\n        :param length_from: function to obtain the field length\n        :type length_from: C{callable}\n\n        :param get_class: function to obtain the class\n        :type get_class: C{callable}\n\n        :param evaluators: evaluators\n        :type evaluators: ``list`` of C{callable}\n        \"\"\"\n        StrLenField.__init__(self, name, default, length_from=length_from)\n        self.evaluators = evaluators or []\n        self._get_class = get_class\n\n    def get_class(self, pkt):\n        values = [evaluator(pkt) for evaluator in self.evaluators]\n        return self._get_class(pkt, *values)\n\n    def i2m(self, pkt, i):\n        cls = self.get_class(pkt)\n        if cls is not None:\n            return str(i)\n        else:\n            return StrLenField.i2m(self, pkt, i)\n\n    def m2i(self, pkt, m):\n        cls = self.get_class(pkt)\n        if cls is not None:\n            return cls(m)\n        else:\n            return StrLenField.m2i(self, pkt, m)\n\n\nclass StrNullFixedLenField(StrFixedLenField):\n    \"\"\"Packet field that has a fixed length and is conditionally null-terminated.\n    \"\"\"\n    __slots__ = [\"length_from\", \"max_length\", \"null_terminated\"]\n\n    def __init__(self, name, default, length=None, length_from=None, max_length=None, null_terminated=None):\n        if null_terminated:\n            self.null_terminated = null_terminated\n        else:\n            self.null_terminated = lambda pkt: True\n        self.max_length = max_length or 200\n        StrFixedLenField.__init__(self, name, default, length=length, length_from=length_from)\n\n    def i2repr(self, pkt, v):\n        if self.null_terminated(pkt):\n            if type(v) is str:\n                v = v.rstrip(\"\\0\")\n            return repr(v)\n        return StrFixedLenField.i2repr(self, pkt, v)\n\n    def getfield(self, pkt, s):\n        if self.null_terminated(pkt):\n            l = self.length_from(pkt) - 1\n            return s[l + 1:], self.m2i(pkt, s[:l])\n        return StrFixedLenField.getfield(self, pkt, s)\n\n    def addfield(self, pkt, s, val):\n        if self.null_terminated(pkt):\n            l = self.length_from(pkt) - 1\n            return s + struct.pack(\"%is\" % l, self.i2m(pkt, val)) + \"\\x00\"\n        return StrFixedLenField.addfield(self, pkt, s, val)\n\n    def randval(self):\n        if self.null_terminated:\n            try:\n                l = self.length_from(None) - 1\n            except:\n                l = RandTermString(RandNum(0, self.max_length), \"\\x00\")\n            return RandBin(l)\n        return StrFixedLenField.randval(self)\n\n\nclass StrFixedLenPaddedField(StrFixedLenField):\n    \"\"\"Packet field that has a fixed length and is padded with a\n    given character.\n    \"\"\"\n    __slots__ = [\"length_from\", \"padd\"]\n\n    def __init__(self, name, default, length=None, length_from=None, padd=\" \"):\n        StrFixedLenField.__init__(self, name, default, length, length_from)\n        self.padd = padd\n\n    def getfield(self, pkt, s):\n        l = self.length_from(pkt)\n        return s[l:], self.m2i(pkt, s[:l])\n\n    def addfield(self, pkt, s, val):\n        l = self.length_from(pkt)\n        val += self.padd * l\n        return StrFixedLenField.addfield(self, pkt, s, val)\n\n\nclass StrNullFixedLenPaddedField(StrFixedLenField):\n    \"\"\"Packet field that has a fixed length and is padded with a\n    given character and null terminated.\n    \"\"\"\n    __slots__ = [\"length_from\", \"padd\"]\n\n    def __init__(self, name, default, length=None, length_from=None, padd=\" \"):\n        StrFixedLenField.__init__(self, name, default, length, length_from)\n        self.padd = padd\n\n    def getfield(self, pkt, s):\n        return\n        l = self.length_from(pkt)\n        lz = s.find(\"\\x00\")\n        if lz < l:\n            return s[l + 1:], self.m2i(pkt, s[:lz])\n        return s[l + 1:], self.m2i(pkt, s[:l])\n\n    def addfield(self, pkt, s, val):\n        l = self.length_from(pkt)\n        val += self.padd * l\n        return StrFixedLenField.addfield(self, pkt, s, val)\n\n\nclass IntToStrField(Field):\n    \"\"\"Custom field from int to str values, with a variable length\n    \"\"\"\n    __slots__ = [\"length\", \"format\"]\n\n    def __init__(self, name, default, length=11):\n        \"\"\"Initialize the field with a variable length. The 'machine'\n        representation is a string field and the 'internal' repr.\n        is a numeric value.\n        \"\"\"\n        Field.__init__(self, name, default, \"%ds\" % length)\n        self.length = length\n        self.format = \"%\" + \"%d\" % length + \"d\"\n\n    def m2i(self, pkt, x):\n        return str(x)\n\n    def i2m(self, pkt, x):\n        return self.format % int(x)\n\n    def i2count(self, pkt, x):\n        return x\n\n\nclass StrEncodedPaddedField(StrField):\n    __slots__ = [\"remain\", \"encoding\", \"padd\"]\n\n    def __init__(self, name, default, encoding=\"utf-16\", padd=\"\\x0c\",\n                 fmt=\"H\", remain=0):\n        StrField.__init__(self, name, default, fmt, remain)\n        self.encoding = encoding\n        self.padd = padd\n\n    def h2i(self, pkt, x):\n        if x:\n            x = x.encode(self.encoding)\n        return x\n\n    def i2h(self, pkt, x):\n        if x:\n            x = x.decode(self.encoding)\n        return x\n\n    def addfield(self, pkt, s, val):\n        return s + self.i2m(pkt, val) + self.padd\n\n    def getfield(self, pkt, s):\n        l = s.find(self.padd)\n        if l < 0:\n            return \"\", s\n        return s[l + 1:], self.m2i(pkt, s[:l])\n\n\nclass PacketListStopField(PacketListField):\n    \"\"\"Custom field that contains a list of packets until a 'stop' condition is met.\n    \"\"\"\n    __slots__ = [\"count_from\", \"length_from\", \"stop\"]\n\n    def __init__(self, name, default, cls, count_from=None, length_from=None, stop=None):\n        PacketListField.__init__(self, name, default, cls, count_from=count_from, length_from=length_from)\n        self.stop = stop\n\n    def getfield(self, pkt, s):\n        c = l = None\n        if self.length_from is not None:\n            l = self.length_from(pkt)\n        elif self.count_from is not None:\n            c = self.count_from(pkt)\n\n        lst = []\n        ret = \"\"\n        remain = s\n        if l is not None:\n            remain, ret = s[:l], s[l:]\n        while remain:\n            if c is not None:\n                if c <= 0:\n                    break\n                c -= 1\n            try:\n                p = self.m2i(pkt, remain)\n            except Exception:\n                if conf.debug_dissector:\n                    raise\n                p = conf.raw_layer(load=remain)\n                remain = \"\"\n            else:\n                if conf.padding_layer in p:\n                    pad = p[conf.padding_layer]\n                    remain = pad.load\n                    del (pad.underlayer.payload)\n                else:\n                    remain = \"\"\n            lst.append(p)\n            if self.stop and self.stop(p):\n                break\n        return remain + ret, lst\n\n\nclass AdjustableFieldLenField(Field):\n    __slots__ = [\"length_of\", \"count_of\", \"adjust\"]\n\n    def __init__(self, name, default, length_of=None):\n        Field.__init__(self, name, default, \">H\")\n        self.length_of = length_of\n\n    def i2m(self, pkt, x):\n        if x is None:\n            fld, fval = pkt.getfield_and_val(self.length_of)\n            x = fld.i2len(pkt, fval)\n        return x\n\n    def addfield(self, pkt, s, val):\n        i2m = self.i2m(pkt, val)\n        fmt = \"B\"\n        padd = \"\"\n        if i2m > 0xf0:\n            fmt = \">H\"\n            padd = struct.pack(\"B\", 0xff)\n        return s + padd + struct.pack(fmt, i2m)\n\n    def getfield(self, pkt, s):\n        if struct.unpack(\"B\", s[:1])[0] == 0xff:\n            return s[3:], self.m2i(pkt, struct.unpack(\">H\", s[1:3])[0])\n        else:\n            return s[1:], self.m2i(pkt, struct.unpack(\"B\", s[:1])[0])\n\n\nclass ASN1F_CHOICE_SAFE(ASN1F_CHOICE):\n    def __init__(self, name, default, *args, **kwargs):\n        if \"implicit_tag\" in kwargs:\n            err_msg = \"ASN1F_CHOICE has been called with an implicit_tag\"\n            raise ASN1_Error(err_msg)\n        self.implicit_tag = None\n        for kwarg in [\"context\", \"explicit_tag\"]:\n            if kwarg in kwargs:\n                setattr(self, kwarg, kwargs[kwarg])\n            else:\n                setattr(self, kwarg, None)\n        ASN1F_field.__init__(self, name, None, context=self.context,\n                             explicit_tag=self.explicit_tag)\n        self.default = default\n        self.current_choice = None\n        self.choices = args\n\n    def m2i(self, pkt, s):\n        \"\"\"Try to safely extract an ASN1_Packet from the choices list.\n\n        :raise ASN1_Error: if unable to parse the packet using any of the given choices\n        \"\"\"\n        if len(s) == 0:\n            raise ASN1_Error(\"ASN1F_CHOICE: got empty string\")\n\n        for choice in self.choices:\n            try:\n                return self.extract_packet(choice, s)\n            except (ASN1_Error, ASN1F_badsequence, BER_Decoding_Error):\n                pass\n        raise ASN1_Error\n\n\nclass TimestampField(LongField):\n    \"\"\"Timestamp field\"\"\"\n\n    def i2h(self, pkt, x):\n        dt = datetime.utcfromtimestamp(x)\n        return dt.strftime(\"%Y-%m-%d %H:%M:%S UTC\")\n\n\nclass LESignedByteField(Field):\n    def __init__(self, name, default):\n        Field.__init__(self, name, default, \"<b\")\n\n\nclass LESignedShortField(Field):\n    def __init__(self, name, default):\n        Field.__init__(self, name, default, \"<h\")\n\n\nclass LESignedLongField(Field):\n    def __init__(self, name, default):\n        Field.__init__(self, name, default, \"<q\")\n",
  "line_no": 156,
  "line_no_percent": "45%"
}