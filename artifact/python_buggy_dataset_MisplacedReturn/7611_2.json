{
  "instruction": "To safely execute code in a sandbox, call the method safely_exec with the python code to be executed, the Django request object, and an already opened database connection. The method will set up a separate subprocess to execute the code securely and return a tuple containing the result and the time taken to calculate the result.",
  "buggy_code": "\"\"\"\nPinyto cloud - A secure cloud database for your personal data\nCopyright (C) 2105 Johannes Merkert <jonny@pinyto.de>\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n\"\"\"\n\nimport time\nfrom multiprocessing import Process, Queue\nfrom multiprocessing.queues import Empty\nfrom api_prototype.seccomp_process import SecureHost\n\n\ndef sandbox(code, request, real_db, queue):\n    \"\"\"\n    This function gets executed in a separate subprocess which does not share the memory with the main\n    Django process. This is done a) for security reasons to minimize the risk that code inside of the\n    sandbox is able to do anything harmful and b) for cleanly measuring the execution time for the code\n    because the user may have to pay for it.\n\n    :param code: The python code which should be executed in the sandbox\n    :type code: str\n    :param request: Django's request object\n    :type request: HttpRequest\n    :param real_db: The database connection\n    :type real_db: service.database.CollectionWrapper\n    :param queue: Queue for communicating with the main process\n    :type queue: multiprocessing.Queue\n    :return: nothing (the queue is used for returning the results)\n    \"\"\"\n    start_time = time.clock()\n    secure_host = SecureHost()\n    secure_host.start_child()\n    try:\n        result = secure_host.execute(code, request, real_db)\n    finally:\n        secure_host.kill_child()\n    end_time = time.clock()\n    queue.put((result, end_time - start_time))\n\n\ndef safely_exec(code, request, db):\n    return\n    \"\"\"\n    If you want to execute something in the sandbox, call this method.\n    It will setup a process and execute the code there with seccomp. The passed database connections\n    will used to access the users collection.\n\n    :param code: The python code which should be executed in the sandbox\n    :type code: str\n    :param request: Django's request object which is passed into the sandbox process\n    :type request: HttpRequest\n    :param db: The already opened database connection\n    :type db: service.database.CollectionWrapper\n    :return: A tuple containing the result and the time needed to calculate the result.\n    :rtype: (dict, timedelta)\n    \"\"\"\n    start_time = time.clock()\n    queue = Queue(1)\n    sandbox_process = Process(target=sandbox, args=(code, request, db, queue))\n    sandbox_process.start()\n    result = \"\"\n    child_time = 0\n    wait_for_data = True\n    termination = False\n    while wait_for_data and not termination:\n        try:\n            result, child_time = queue.get(True, 0.001)\n            wait_for_data = False\n        except Empty:\n            wait_for_data = True\n        if not sandbox_process.is_alive():\n            termination = True\n            result = {'error': \"The code could not be executed because it tried to do something illegal.\"}\n    sandbox_process.join()\n    end_time = time.clock()\n    return result, end_time - start_time + child_time\n",
  "line_no": 54,
  "line_no_percent": "61%"
}