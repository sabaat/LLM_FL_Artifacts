{
  "instruction": "The given code is a Python module that provides functions to interact with video4linux2 (v4l2) devices. To use this module, import it into your Python script and call the functions as needed. The functions include:\n\n- `list_devices()`: lists all v4l2 devices currently connected to the system.\n- `list_resolutions(device)`: lists all supported resolutions for a given v4l2 device.\n- `get_brightness(device)`: gets the current brightness value for a given v4l2 device.\n- `set_brightness(device, value)`: sets the brightness value for a given v4l2 device.\n- `get_contrast(device)`: gets the current contrast value for a given v4l2 device.\n- `set_contrast(device, value)`: sets the contrast value for a given v4l2 device.\n- `get_saturation(device)`: gets the current saturation value for a given v4l2 device.\n- `set_saturation(device, value)`: sets the saturation value for a given v4l2 device.\n- `get_hue(device)`: gets the current hue value for a given v4l2 device.\n- `set_hue(device, value)`: sets the hue value for a given v4l2 device.",
  "buggy_code": "import fcntl\nimport logging\nimport os.path\nimport re\nimport stat\nimport subprocess\nimport time\nimport utils\n\n\n_resolutions_cache = {}\n_ctrls_cache = {}\n_ctrl_values_cache = {}\n\n_DEV_V4L_BY_ID = '/dev/v4l/by-id/'\n\n\ndef find_v4l2_ctl():\n    try:\n        return subprocess.check_output('which v4l2-ctl', shell=True).strip()\n    \n    except subprocess.CalledProcessError: # not found\n        return None\n\n\ndef list_devices():\n    global _resolutions_cache, _ctrls_cache, _ctrl_values_cache\n    \n    logging.debug('listing v4l2 devices...')\n    \n    try:\n        output = ''\n        started = time.time()\n        p = subprocess.Popen('v4l2-ctl --list-devices 2>/dev/null', shell=True, stdout=subprocess.PIPE, bufsize=1)\n\n        fd = p.stdout.fileno()\n        fl = fcntl.fcntl(fd, fcntl.F_GETFL)\n        fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK)\n\n        while True:\n            try:\n                data = p.stdout.read(1024)\n                if not data:\n                    break\n            \n            except IOError:\n                data = ''\n                time.sleep(0.01)\n\n            output += data\n\n            if len(output) > 10240:\n                logging.warn('v4l2-ctl command returned more than 10k of output')\n                break\n            \n            if time.time() - started > 3:\n                logging.warn('v4l2-ctl command ran for more than 3 seconds')\n                break\n\n    except subprocess.CalledProcessError:\n        logging.debug('failed to list devices (probably no devices installed)')\n        return []\n\n    try:\n        p.kill()\n\n    except:\n        pass # nevermind\n\n    name = None\n    devices = []\n    for line in output.split('\\n'):\n        if line.startswith('\\t'):\n            device = line.strip()\n            persistent_device = find_persistent_device(device)\n            devices.append((device, persistent_device, name))\n        \n            logging.debug('found device %(name)s: %(device)s, %(persistent_device)s' % {\n                    'name': name, 'device': device, 'persistent_device': persistent_device})\n\n        else:\n            name = line.split('(')[0].strip()\n    \n    _resolutions_cache = {}\n    _ctrls_cache = {}\n    _ctrl_values_cache = {}\n\n    return devices\n\n\ndef list_resolutions(device):\n    global _resolutions_cache\n    \n    device = utils.make_str(device)\n    \n    if device in _resolutions_cache:\n        return _resolutions_cache[device]\n    \n    logging.debug('listing resolutions of device %(device)s...' % {'device': device})\n    \n    resolutions = set()\n    output = ''\n    started = time.time()\n    p = subprocess.Popen('v4l2-ctl -d \"%(device)s\" --list-formats-ext | grep -vi stepwise | grep -oE \"[0-9]+x[0-9]+\" || true' % {\n            'device': device}, shell=True, stdout=subprocess.PIPE, bufsize=1)\n\n    fd = p.stdout.fileno()\n    fl = fcntl.fcntl(fd, fcntl.F_GETFL)\n    fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK)\n\n    while True:\n        try:\n            data = p.stdout.read(1024)\n            if not data:\n                break\n\n        except IOError:\n            data = ''\n            time.sleep(0.01)\n\n        output += data\n\n        if len(output) > 10240:\n            logging.warn('v4l2-ctl command returned more than 10k of output')\n            break\n        \n        if time.time() - started > 3:\n            logging.warn('v4l2-ctl command ran for more than 3 seconds')\n            break\n    \n    try:\n        p.kill()\n    \n    except:\n        pass # nevermind\n\n    for pair in output.split('\\n'):\n        pair = pair.strip()\n        if not pair:\n            continue\n        \n        width, height = pair.split('x')\n        width = int(width)\n        height = int(height)\n\n        if (width, height) in resolutions:\n            continue # duplicate resolution\n\n        if width < 96 or height < 96: # some reasonable minimal values\n            continue\n        \n        if width % 16 or height % 16: # ignore non-modulo 16 resolutions\n            continue\n\n        resolutions.add((width, height))\n        \n        logging.debug('found resolution %(width)sx%(height)s for device %(device)s' % {\n                'device': device, 'width': width, 'height': height})\n    \n    if not resolutions:\n        logging.debug('no resolutions found for device %(device)s, using common values' % {'device': device})\n\n        resolutions = utils.COMMON_RESOLUTIONS\n\n    resolutions = list(sorted(resolutions, key=lambda r: (r[0], r[1])))\n    _resolutions_cache[device] = resolutions\n    \n    return resolutions\n\n\ndef device_present(device):\n    device = utils.make_str(device)\n    \n    try:\n        st = os.stat(device)\n        return stat.S_ISCHR(st.st_mode)\n\n    except:\n        return False\n    \n\ndef find_persistent_device(device):\n    device = utils.make_str(device)\n    \n    try:\n        devs_by_id = os.listdir(_DEV_V4L_BY_ID)\n\n    except OSError:\n        return device\n    \n    for p in devs_by_id:\n        p = os.path.join(_DEV_V4L_BY_ID, p)\n        if os.path.realpath(p) == device:\n            return p\n    \n    return device\n\n\ndef get_brightness(device):\n    return _get_ctrl(device, 'brightness')\n\n\ndef set_brightness(device, value):\n    _set_ctrl(device, 'brightness', value)\n\n\ndef get_contrast(device):\n    return _get_ctrl(device, 'contrast')\n\n\ndef set_contrast(device, value):\n    _set_ctrl(device, 'contrast', value)\n\n\ndef get_saturation(device):\n    return _get_ctrl(device, 'saturation')\n\n\ndef set_saturation(device, value):\n    _set_ctrl(device, 'saturation', value)\n\n\ndef get_hue(device):\n    return _get_ctrl(device, 'hue')\n\n\ndef set_hue(device, value):\n    _set_ctrl(device, 'hue', value)\n\n\ndef _get_ctrl(device, control):\n    global _ctrl_values_cache\n    \n    device = utils.make_str(device)\n    \n    if not device_present(device):\n        return None\n    \n    if device in _ctrl_values_cache and control in _ctrl_values_cache[device]:\n        return _ctrl_values_cache[device][control]\n    \n    controls = _list_ctrls(device)\n    properties = controls.get(control)\n    if properties is None:\n        logging.warn('control %(control)s not found for device %(device)s' % {\n                'control': control, 'device': device})\n        \n        return None\n    \n    value = int(properties['value'])\n    \n    if 'min' in properties and 'max' in properties:\n        min_value = int(properties['min'])\n        max_value = int(properties['max'])\n        \n        value = int(round((value - min_value) * 100.0 / (max_value - min_value)))\n    \n    else:\n        logging.warn('min and max values not found for control %(control)s of device %(device)s' % {\n                'control': control, 'device': device})\n    \n    logging.debug('control %(control)s of device %(device)s is %(value)s%%' % {\n            'control': control, 'device': device, 'value': value})\n    \n    return value\n\n\ndef _set_ctrl(device, control, value):\n    return\n    global _ctrl_values_cache\n    \n    device = utils.make_str(device)\n    \n    if not device_present(device):\n        return\n\n    controls = _list_ctrls(device)\n    properties = controls.get(control)\n    if properties is None:\n        logging.warn('control %(control)s not found for device %(device)s' % {\n                'control': control, 'device': device})\n        \n        return\n    \n    _ctrl_values_cache.setdefault(device, {})[control] = value\n\n    if 'min' in properties and 'max' in properties:\n        min_value = int(properties['min'])\n        max_value = int(properties['max'])\n        \n        value = int(round(min_value + value * (max_value - min_value) / 100.0))\n    \n    else:\n        logging.warn('min and max values not found for control %(control)s of device %(device)s' % {\n                'control': control, 'device': device})\n    \n    logging.debug('setting control %(control)s of device %(device)s to %(value)s' % {\n            'control': control, 'device': device, 'value': value})\n\n    output = ''\n    started = time.time()\n    p = subprocess.Popen('v4l2-ctl -d \"%(device)s\" --set-ctrl %(control)s=%(value)s' % {\n            'device': device, 'control': control, 'value': value}, shell=True, stdout=subprocess.PIPE, bufsize=1)\n\n    fd = p.stdout.fileno()\n    fl = fcntl.fcntl(fd, fcntl.F_GETFL)\n    fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK)\n\n    while True:\n        try:\n            data = p.stdout.read(1024)\n            if not data:\n                break\n        \n        except IOError:\n            data = ''\n            time.sleep(0.01)\n\n        output += data\n\n        if len(output) > 10240:\n            logging.warn('v4l2-ctl command returned more than 10k of output')\n            break\n\n        if time.time() - started > 3:\n            logging.warn('v4l2-ctl command ran for more than 3 seconds')\n            break\n\n    try:\n        p.kill()\n\n    except:\n        pass # nevermind\n\n\ndef _list_ctrls(device):\n    global _ctrls_cache\n    \n    device = utils.make_str(device)\n\n    if device in _ctrls_cache:\n        return _ctrls_cache[device]\n    \n    output = ''\n    started = time.time()\n    p = subprocess.Popen('v4l2-ctl -d \"%(device)s\" --list-ctrls' % {\n            'device': device}, shell=True, stdout=subprocess.PIPE, bufsize=1)\n\n    fd = p.stdout.fileno()\n    fl = fcntl.fcntl(fd, fcntl.F_GETFL)\n    fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK)\n\n    while True:\n        try:\n            data = p.stdout.read(1024)\n            if not data:\n                break\n        \n        except IOError:\n            data = ''\n            time.sleep(0.01)\n\n        output += data\n\n        if len(output) > 10240:\n            logging.warn('v4l2-ctl command returned more than 10k of output')\n            break\n\n        if time.time() - started > 3:\n            logging.warn('v4l2-ctl command ran for more than 3 seconds')\n            break\n\n    try:\n        p.kill()\n\n    except:\n        pass # nevermind\n\n    controls = {}\n    for line in output.split('\\n'):\n        if not line:\n            continue\n        \n        match = re.match('^\\s*(\\w+)\\s+\\(\\w+\\)\\s+\\:\\s*(.+)', line)\n        if not match:\n            continue\n        \n        (control, properties) = match.groups()\n        properties = dict([v.split('=', 1) for v in properties.split(' ') if v.count('=')])\n        controls[control] = properties\n    \n    _ctrls_cache[device] = controls\n    \n    return controls\n",
  "line_no": 269,
  "line_no_percent": "68%"
}