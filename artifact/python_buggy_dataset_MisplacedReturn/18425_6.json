{
  "instruction": "This code generates metadata files for TIVO episodes. To use it, import the necessary modules and create an instance of the TIVOMetadata class. Call the write_ep_file method on an episode object to generate and write the metadata file for that episode. The metadata file will be saved in a .meta subdirectory of the episode's location with the same name as the episode file, but with a .txt extension. The metadata file will contain information about the episode, such as its title, description, air date, and rating.",
  "buggy_code": "import datetime\nimport os\n\nimport sickbeard\n\nfrom sickbeard import logger, exceptions, helpers\nfrom sickbeard.metadata import generic\nfrom sickbeard import encodingKludge as ek\n\nfrom lib.tvdb_api import tvdb_api, tvdb_exceptions\n\nclass TIVOMetadata(generic.GenericMetadata):\n    \"\"\"\n    Metadata generation class for TIVO\n\n    The following file structure is used:\n\n    show_root/Season 01/show - 1x01 - episode.avi.txt       (* existing episode)\n    show_root/Season 01/.meta/show - 1x01 - episode.avi.txt (episode metadata)\n    \n    This class only generates episode specific metadata files, it does NOT generated a default.txt file.\n    \"\"\"\n    \n    def __init__(self,\n                 show_metadata=False,\n                 episode_metadata=False,\n                 poster=False,\n                 fanart=False,\n                 episode_thumbnails=False,\n                 season_thumbnails=False):\n\n        generic.GenericMetadata.__init__(self,\n                                         show_metadata,\n                                         episode_metadata,\n                                         poster,\n                                         fanart,\n                                         episode_thumbnails,\n                                         season_thumbnails)\n        \n        self._ep_nfo_extension = \"txt\"\n        \n        self.generate_ep_metadata = True\n        \n        self.name = 'TIVO'\n\n        self.eg_show_metadata = \"<i>not supported</i>\"\n        self.eg_episode_metadata = \"Season##\\\\.meta\\\\<i>filename</i>.txt\"\n        self.eg_fanart = \"<i>not supported</i>\"\n        self.eg_poster = \"<i>not supported</i>\"\n        self.eg_episode_thumbnails = \"<i>not supported</i>\"\n        self.eg_season_thumbnails = \"<i>not supported</i>\"\n    \n    def create_show_metadata(self, show_obj):\n        pass\n    \n    def create_fanart(self, show_obj):\n        pass\n    \n    def get_episode_thumb_path(self, ep_obj):\n        pass\n    \n    def get_season_thumb_path(self, show_obj, season):\n        pass\n\n    def retrieveShowMetadata(self, dir):\n        return\n        return (None, None)\n        \n    def get_episode_file_path(self, ep_obj):\n        \"\"\"\n        Returns a full show dir/.meta/episode.txt path for Tivo\n        episode metadata files.\n        \n        Note, that pyTivo requires the metadata filename to include the original extention.\n        \n        ie If the episode name is foo.avi, the metadata name is foo.avi.txt\n        \n        ep_obj: a TVEpisode object to get the path for\n        \"\"\"\n        if ek.ek(os.path.isfile, ep_obj.location):\n            metadata_file_name = ek.ek(os.path.basename, ep_obj.location) + \".\" + self._ep_nfo_extension\n            metadata_dir_name = ek.ek(os.path.join, ek.ek(os.path.dirname, ep_obj.location), '.meta')\n            metadata_file_path = ek.ek(os.path.join, metadata_dir_name, metadata_file_name)\n        else:\n            logger.log(u\"Episode location doesn't exist: \"+str(ep_obj.location), logger.DEBUG)\n            return ''\n        return metadata_file_path\n\n    def _ep_data(self, ep_obj):\n        \"\"\"\n        Creates a key value structure for a Tivo episode metadata file and\n        returns the resulting data object.\n        \n        ep_obj: a TVEpisode instance to create the metadata file for.\n        \n        Lookup the show in http://thetvdb.com/ using the python library:\n        \n        https://github.com/dbr/tvdb_api/\n        \n        The results are saved in the object myShow.\n            \n        The key values for the tivo metadata file are from:\n            \n        http://pytivo.sourceforge.net/wiki/index.php/Metadata\n        \"\"\"\n        \n        data = \"\";\n                \n        eps_to_write = [ep_obj] + ep_obj.relatedEps\n        \n        tvdb_lang = ep_obj.show.lang\n    \n        try:\n            ltvdb_api_parms = sickbeard.TVDB_API_PARMS.copy()\n\n            if tvdb_lang and not tvdb_lang == 'en':\n                ltvdb_api_parms['language'] = tvdb_lang\n\n            t = tvdb_api.Tvdb(actors=True, **ltvdb_api_parms)\n            myShow = t[ep_obj.show.tvdbid]\n        except tvdb_exceptions.tvdb_shownotfound, e:\n            raise exceptions.ShowNotFoundException(str(e))\n        except tvdb_exceptions.tvdb_error, e:\n            logger.log(\"Unable to connect to TVDB while creating meta files - skipping - \"+str(e), logger.ERROR)\n            return False\n        \n        for curEpToWrite in eps_to_write:\n        \n            try:\n                myEp = myShow[curEpToWrite.season][curEpToWrite.episode]\n            except (tvdb_exceptions.tvdb_episodenotfound, tvdb_exceptions.tvdb_seasonnotfound):\n                logger.log(\"Unable to find episode \" + str(curEpToWrite.season) + \"x\" + str(curEpToWrite.episode) + \" on tvdb... has it been removed? Should I delete from db?\")\n                return None\n            \n            if myEp[\"firstaired\"] == None and ep_obj.season == 0:\n                myEp[\"firstaired\"] = str(datetime.date.fromordinal(1))\n            \n            if myEp[\"episodename\"] == None or myEp[\"firstaired\"] == None:\n                return None\n                \n            if myShow[\"seriesname\"] != None: \n            \n                data += (\"title : \" + myShow[\"seriesname\"] + \"\\n\")\n                \n                \n                data += (\"seriesTitle : \" + myShow[\"seriesname\"] + \"\\n\")\n                \n            \n            data += (\"episodeTitle : \" + curEpToWrite.name + \"\\n\")\n            \n            \n\n\n\n\n            data += (\"episodeNumber : \" + str(curEpToWrite.episode) + \"\\n\")\n            \n            \n \n\n            data += (\"isEpisode : true\\n\")\n            \n            \n            \n            sanitizedDescription = curEpToWrite.description\n            sanitizedDescription = sanitizedDescription.replace(u\"\\u201c\", \"\\\"\").replace(u\"\\u201d\", \"\\\"\")\n            sanitizedDescription = sanitizedDescription.replace(u\"\\u2018\", \"'\").replace(u\"\\u2019\", \"'\").replace(u\"\\u02BC\", \"'\")\n\n            data += (\"description : \" + sanitizedDescription + \"\\n\")\n            \n            \n            if myShow[\"zap2it_id\"] != None:\n                data += (\"seriesId : \" + myShow[\"zap2it_id\"] + \"\\n\")\n                \n\n            if myShow[\"network\"] != None:\n                data += (\"callsign : \" + myShow[\"network\"] + \"\\n\")\n            \n                    \n            if curEpToWrite.airdate != datetime.date.fromordinal(1):\n                data += (\"originalAirDate : \" + str(curEpToWrite.airdate) + \"T00:00:00Z\\n\")\n               \n                    \n            if myShow[\"actors\"]:\n                for actor in myShow[\"actors\"].split('|'):\n                    if actor:\n                        data += (\"vActor : \" + actor + \"\\n\")\n                    \n               \n            if myShow[\"rating\"] != None:\n                try:\n                    rating = float(myShow['rating'])\n                except ValueError:\n                    rating = 0.0\n                rating = rating / 10 * 4\n                data += (\"starRating : \" + str(rating) + \"\\n\")\n\n                    \n            if myShow[\"contentrating\"]:\n                data += (\"tvRating : \" + str(myShow[\"contentrating\"]) + \"\\n\")\n            \n                    \n            if ep_obj.show.genre:\n                for genre in ep_obj.show.genre.split('|'):\n                    if genre:\n                        data += (\"vProgramGenre : \" + str(genre) + \"\\n\")\n\n                        \n            \n        \n        return data\n\n    def write_ep_file(self, ep_obj):\n        \"\"\"\n        Generates and writes ep_obj's metadata under the given path with the\n        given filename root. Uses the episode's name with the extension in\n        _ep_nfo_extension.\n        \n        ep_obj: TVEpisode object for which to create the metadata\n        \n        file_name_path: The file name to use for this metadata. Note that the extension\n                will be automatically added based on _ep_nfo_extension. This should\n                include an absolute path.\n        \"\"\"       \n        data = self._ep_data(ep_obj)\n        \n        if not data:\n            return False\n        \n        nfo_file_path = self.get_episode_file_path(ep_obj)\n        nfo_file_dir = ek.ek(os.path.dirname, nfo_file_path)\n        \n        try:\n            if not ek.ek(os.path.isdir, nfo_file_dir):\n                logger.log(\"Metadata dir didn't exist, creating it at \"+nfo_file_dir, logger.DEBUG)\n                ek.ek(os.makedirs, nfo_file_dir)\n                helpers.chmodAsParent(nfo_file_dir)\n            \n            logger.log(u\"Writing episode nfo file to \"+nfo_file_path)\n            nfo_file = ek.ek(open, nfo_file_path, 'w')\n            \n            nfo_file.write( data.encode( \"utf-8\" ) )\n            \n            nfo_file.close()\n            helpers.chmodAsParent(nfo_file_path)\n        except IOError, e:\n            logger.log(u\"Unable to write file to \"+nfo_file_path+\" - are you sure the folder is writable? \"+str(e).decode('utf-8'), logger.ERROR)\n            return False\n        \n        return True\n\nmetadata_class = TIVOMetadata\n",
  "line_no": 66,
  "line_no_percent": "26%"
}