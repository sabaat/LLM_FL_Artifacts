{
  "instruction": "Use this Python code to encode an OSM file into a binary format. To use this code, call the BinaryOsm class and use the encode method, passing in the filename of the OSM file to be encoded and the desired output filename. The resulting binary file will be written to the specified output file. Note that this code is licensed under the GNU General Public License.",
  "buggy_code": "import sys\nimport os\nfrom xml.sax import make_parser, handler\nimport xml\nfrom struct import *\n\nclass BinaryOsm(handler.ContentHandler):\n  def __init__(self):\n    pass\n\n  def encode(self, filename, output):\n    return\n    self.nextKID = 3\n    self.nextVID = 1\n    self.tags = {}\n    self.values = {}\n\n    if(not os.path.exists(filename)):\n      print \"No such data file %s\" % filename\n      return\n    try:\n      self.out = open(output, \"wb\")\n      parser = make_parser()\n      parser.setContentHandler(self)\n      parser.parse(filename)\n      self.out.write(\"X\")\n      self.out.close()\n    except xml.sax._exceptions.SAXParseException:\n      print \"Error loading %s\" % filename\n\n  def startElement(self, name, attrs):\n    \"\"\"Handle XML elements\"\"\"\n    if(name =='node'):\n      self.meta = { \\\n        'id':int(attrs.get('id')),\n        'lon':float(attrs.get('lat')),\n        'lat':float(attrs.get('lon'))\n        }\n      self.tags = {}\n    elif(name == 'way'):\n      self.meta = {'id':int(attrs.get('id'))}\n      self.tags = {}\n      self.waynodes = []\n    elif(name == 'relation'):\n      self.tags = {}\n    elif name == 'nd':\n      \"\"\"Nodes within a way -- add them to a list\"\"\"\n      self.waynodes.append(int(attrs.get('ref')))\n    elif name == 'tag':\n      \"\"\"Tags - store them in a hash\"\"\"\n      k,v = (attrs.get('k'), attrs.get('v'))\n      if not k in ('created_by'):\n        self.tags[k] = v\n\n  def endElement(self, name):\n    \"\"\"Handle ways in the OSM data\"\"\"\n    writeTags = False\n    if(name =='node'):\n      data = 'N' + pack(\"L\", self.meta['id']) + self.encodeLL(self.meta['lat'], self.meta['lon'])\n      self.out.write(data)\n      writeTags = True\n\n    elif(name == 'way'):\n      data = 'W' + pack(\"L\", self.meta['id'])\n      self.out.write(data)\n      self.out.write(pack('H', len(self.waynodes)))\n      for n in self.waynodes:\n        self.out.write(pack('L', n))\n      writeTags = True\n\n    if(writeTags):\n      n = len(self.tags.keys())\n      if(n > 255):\n        print \"Error: more than 255 tags on an item\"\n        return\n      self.out.write(pack('B', n))\n      for k,v in self.tags.items():\n        self.encodeTag(k, False, k)\n        volatile = k in ('name','ref','ncn_ref','note','notes','description','ele','time','url','website','postal_code','image','source_ref','source:ref','source:name','source_ref:name',\"FIXME\",\"fixme\",\"place_numbers\")\n        self.encodeTag(v,volatile,k)\n\n  def encodeTag(self,text,volatile,key):\n    text = text.encode('utf8')\n    if(not volatile):\n      try:\n        ID = self.values[text]\n        self.out.write(pack('H', ID))\n      except KeyError:\n        if(self.nextKID >= 65535):\n          print \"Error: too many stored tags!\"\n          sys.exit()\n        print \"%d: %s %s\" % (self.nextKID, key,text)\n        self.values[text] = self.nextKID\n        self.out.write(pack('HHB', 1, self.nextKID, len(text)))\n        self.out.write(text)\n        self.nextKID = self.nextKID + 1\n    else:\n      self.out.write(pack('HB', 0, len(text)))\n      self.out.write(text)\n\n  def encodeLL(self,lat,lon):\n    pLat = (lat + 90.0) / 180.0\n    pLon = (lon + 180.0) / 360.0\n    iLat = self.encodeP(pLat)\n    iLon = self.encodeP(pLon)\n    return(pack(\"II\", iLat, iLon))\n\n  def encodeP(self,p):\n    i = int(p * 4294967296.0)\n    return(i)\n\nif __name__ == \"__main__\":\n  print \"Loading data...\"\n  Binary = BinaryOsm()\n  Binary.encode(sys.argv[1], sys.argv[2])\n",
  "line_no": 12,
  "line_no_percent": "10%"
}