{
  "instruction": "Create a Python program that adds logic programming (Prolog) syntax and resolution into Python. Define a Struct class that takes a database, head, and subs as input and adds it to the database. Implement unary + to insert into the database as fact, unary ~ to insert into the database as a query, and << to add a conditional. Define a Symbol class that takes a name and database as input and returns a Variable or Constant object. Implement a Database class that stores facts, conditionals, and queries. Implement a solve method that extends valuations in V satisfying the last query. Implement a unify method that finds one valuation extending v and unifying x with y. Define a LogicalFunction class that replaces a logical function once it has been consulted.",
  "buggy_code": "import string\nimport copy\n \nclass Struct:\n    def __init__(self, database, head, subs):\n        \"\"\"\n        The head and subs are essential - what makes this struct.\n        The database should only be used while structs are constructed,\n        and later removed.\n        \"\"\"\n        self.database = database\n        self.head = head\n        self.subs = subs\n\n    def __pos__(self):\n        \"\"\"\n        unary + means insert into database as fact\n        \"\"\"\n        self.database.add_fact(self)\n\n    def __invert__(self):\n        \"\"\"\n        unary ~ means insert into database as query\n        \"\"\"\n        self.database.add_query(self)\n\n    def __lshift__(self, requisites):\n        \"\"\"\n        The ideal is\n        consequent(args) << cond1(args1),...\n        for now we must do with\n        consequent(args) << [cond1(args1),...]\n        \"\"\"\n        self.database.add_conditional(self, requisites)\n\n    def __str__(self):\n        subs = map (str, self.subs)\n        return str(self.head) + \"(\" + string.join(subs,',') + \")\"\n\nclass Symbol:\n    def __init__ (self, name, database):\n        self.name = name\n        self.database = database\n            \n    def __call__(self, *args):\n        return Struct(self.database, self, args)\n            \n    def __str__(self):\n        return self.name\n\nclass Constant(Symbol):\n    \"\"\"\n    A constant is a name. Its value is its name too.\n    \"\"\"\n    def value(self): return self.name\n\nclass Variable(Symbol):\n    pass\n\n\ndef symbol(name, database):\n    if (name[0] in string.uppercase):\n        return Variable(name,database)\n    else:\n        return Constant(name, database)\n\t\nclass Database:\n    def __init__(self, name):\n        self.name= name\n        self.facts = []\n        self.conditionals = []\n        self.queries = []\n            \n    def add_fact(self, fact):\n        self.facts.append(fact)\n\n    def add_query(self, query):\n        self.queries.append(query)\n            \n    def add_conditional(self,head,requisites):\n        if not(isinstance(requisites, list)):\n            requisites = [requisites]\n        self.conditionals.append((head,requisites))\n\n    def __str__(self):\n        factsStr= string.join(map(str, self.facts),'\\n')\n        condsStr= ''\n        for (h,r) in self.conditionals:\n            condsStr = condsStr +  \"%s << %s\\n\"%(h,string.join( map(str, r), ', '))\n        queryStr= string.join( map(str, self.queries),'\\n')\n        return self.name + ' facts\\n' + factsStr +'\\n'+self.name + ' conditionals\\n'+ condsStr  + '\\n'+self.name + ' queries\\n'+queryStr + '\\n'\n\n    def append(self, func):\n        \"\"\"\n        Include definitions from func into database\n        \"\"\"\n        try:\n            code = func.func_code\n        except:\n            raise TypeError, \"function or method argument expected\"\n        names = code.co_names\n        locally_defined = code.co_varnames\n        globally_defined = func.func_globals.keys()\n        defined = locally_defined+tuple(globally_defined)\n        undefined = [name for name in names if name not in defined]\n        newglobals = func.func_globals.copy()\n        for name in undefined:\n            newglobals[name] = symbol(name, self)\n        exec code in newglobals\n\n    def __lshift__(self, func):\n        \"\"\"\n        A helper for decorator implementation\n        \"\"\"\n        self.append(func)\n        return LogicalFunction(self, func)\t\t\n            \n    def solve(self, V = [{}]):\n        \"\"\"        \n        The query queue is LIFO:\n        Extend valuations in V satisfying the last query.\n        \"\"\"\n        def solve1( v ):\n            unify_facts = [unify(query, fact, v) for fact in self.facts]\n\n            unify_conditionals = []            \n            for ( header , condition_list ) in self.conditionals:\n                u = unify(query, header , v) # unify headers\n                U = [ u ]\n                \n                if u != None:\n                    oldQueries = copy.deepcopy(self.queries)\n\n                    D = copy.copy( condition_list )\n                    D.reverse() \n                    \n                    for condition in D:\n                        if type( condition ) == type('string'):\n                            self.queries.append( condition )\n                        else:\n                            unified_condition = subst(u, condition )\n                            self.queries.append( unified_condition )\n\n                    for condition in D:\n                        U =  self.solve( U )\n\n                    self.queries = oldQueries\n\n                    unify_conditionals = unify_conditionals + U\n            return [ u for u in (unify_facts + unify_conditionals) if not u in [None, {}] ] \n        \n        if self.queries:\n            query = self.queries[-1]\n            del self.queries[-1]\n        else:\n            return []\n\n        if type( query ) == type( 'string' ):\n            U = [ v for v in V if python_eval_string(query, v) ]                    \n        else:\n            U = []\n            \n            for v in V:\n                U = U + solve1(v)\n            \n        return U\n                    \ndef python_eval_string(s, v):\n    for k in v:\n        s=string.replace(s, str(k), str(v[k]))\n    return eval( s, {} )\n\ndef subst(v, x):\n    if v.has_key(x):\n        return v[x]\n    elif isinstance(x, Variable):\n        return x\n    elif isinstance(x, Struct):\n        return Struct( x.database, x.head, [subst(v, xi) for xi in x.subs])\n\ndef unify(x,y,v={}):\n    \"\"\"\n    Find one valuation extending v and unifying x with y\n    \"\"\"\n    \n    def extend(v, x, t):\n        \"\"\"\n        Extend valuation v with v[x] = t\n        \"\"\"\n        v1 = copy.copy(v)\n        v1[x] = t\n        return v1\n\n    def occur_check(x, t):\n        \"\"\"\n        Test if the variable x occurr in structure t\n        \"\"\"\n        if x == t:\n            return True\n        elif isinstance(t, Struct):\n            return t.head == x.head or occur_check(x, t.subs)\n        return False\n\n    def unify_var(x, t, v):\n        \"\"\"\n        Test if v can be extended with v[x] = t;\n        In that case return the extention\n        Else return None\n        \"\"\"\n        if x in v:\n            return unify( v[ x ], t, v)\n        elif occur_check(x, t):\n            return None\n        else:\n            return extend(v, x, t)\n\n    if v == None:\n        return None\n    elif x == y:\n        return v\n    elif isinstance(x, Variable):\n        return unify_var(x, y, v)\n    elif isinstance(y, Variable):\n        return unify_var(y, x, v)\n    elif isinstance(x, Struct) and isinstance(y, Struct) and (x.head == y.head):\n        z = v\n        n = len(x.subs)\n        m = len(y.subs)\n        if n == m:\n            for i in range( n ):\n                z = unify( x.subs[i], y.subs[i], z)\n            return z\n        else:\n            return None\n    else:\n        return None\n\n    \nclass LogicalFunction:\n    \"\"\"\n    This class replaces a logical function once it has\n    been consulted, to avoid erroneous use\n    \"\"\"\n    def __init__(self, database, func):\n        self.database=database\n        self.logical_function=func\n    def __call__(self):\n        return\n        raise TypeError, \"Logical functions are not really callable\"\n\nif __name__ == \"__main__\":\n\n    db = Database('TEST')\n\n    print \"Defining a prolog program... \",\n\n    def prolog_func():\n        \n        + number(0) \n        + number(1)\n        + number(2)\n        + number(3)\n        + number(4)\n\n        test(X, Y) << [number(X),  number(Y), 'X==2*Y' ]\n        \n        ~ test(X, Y)\n        \n    db << prolog_func\n    print \"done\"\n\n    print \"Before solving\"\n    print db\n    \n    x = db.solve()\n    print 'Solutions'\n    for v in x:\n        for k in v: print k,\"=\", v[k],' ',\n        print\n\n    print \"After solving\"\n    print db\n",
  "line_no": 248,
  "line_no_percent": "88%"
}