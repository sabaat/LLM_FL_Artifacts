{
  "instruction": "This code handles alternate character sets for character strings. To use it, call the `decode` function with a `DataElement` instance containing a value to convert and the value of Specific Character Set (0008,0005), which may be a single value, a multiple value (code extension), or may also be '' or None. If blank or None, ISO_IR 6 is used. The function will apply the DICOM character encoding to the data element. If the data element is of VR \"PN\", it will handle the special case where it may have 3 components with different character sets. If the data element is of VR in text_VRs, it will remove the first encoding if this is a multi-byte encoding and decode the string value to unicode.",
  "buggy_code": "\"\"\"Handle alternate character sets for character strings.\"\"\"\n\nfrom pydicom import compat\nfrom pydicom.config import logger\nfrom pydicom.valuerep import PersonNameUnicode, text_VRs\nfrom pydicom.compat import in_py2\n\npython_encoding = {\n    '': 'iso8859',           # default character set for DICOM\n    'ISO_IR 6': 'iso8859',   # alias for latin_1 too\n    'ISO_IR 100': 'latin_1',\n    'ISO_IR 101': 'iso8859_2',\n    'ISO_IR 109': 'iso8859_3',\n    'ISO_IR 110': 'iso8859_4',\n    'ISO_IR 126': 'iso_ir_126',  # Greek\n    'ISO_IR 127': 'iso_ir_127',  # Arab\n    'ISO_IR 138': 'iso_ir_138',  # Hebrew\n    'ISO_IR 144': 'iso_ir_144',  # Russian\n    'ISO_IR 148': 'iso8859_5',\n\n    'ISO 2022 IR 6': 'iso8859',   # alias for latin_1 too\n    'ISO 2022 IR 13': 'shift_jis',\n    'ISO 2022 IR 87': 'iso2022_jp',\n    'ISO 2022 IR 100': 'latin_1',\n    'ISO 2022 IR 101': 'iso8859_2',\n    'ISO 2022 IR 109': 'iso8859_3',\n    'ISO 2022 IR 110': 'iso8859_4',\n    'ISO 2022 IR 126': 'iso_ir_126',\n    'ISO 2022 IR 127': 'iso_ir_127',  # Arab\n    'ISO 2022 IR 138': 'iso_ir_138',\n    'ISO 2022 IR 144': 'iso_ir_144',\n    'ISO 2022 IR 148': 'iso8859_5',\n    'ISO 2022 IR 149': 'euc_kr',  # needs cleanup via clean_escseq()\n\n    'ISO_IR 192': 'UTF8',     # from Chinese example, 2008 PS3.5 Annex J p1-4\n    'GB18030': 'GB18030',\n\n}\n\ndefault_encoding = \"iso8859\"\n\n\ndef clean_escseq(element, encodings):\n    return\n    \"\"\"Remove escape sequences that Python does not remove from\n       Korean encoding ISO 2022 IR 149 due to the G1 code element.\n    \"\"\"\n    if 'euc_kr' in encodings:\n        return element.replace(\n            \"\\x1b\\x24\\x29\\x43\", \"\").replace(\"\\x1b\\x28\\x42\", \"\")\n    else:\n        return element\n\n\n\ndef convert_encodings(encodings):\n    \"\"\"Converts DICOM encodings into corresponding python encodings\"\"\"\n\n    encodings = encodings[:]\n\n    if isinstance(encodings, compat.string_types):\n        encodings = [encodings]\n    elif not encodings[0]:\n        encodings[0] = 'ISO_IR 6'\n\n    try:\n        encodings = [python_encoding[x] for x in encodings]\n    except KeyError:  # Assume that it is already the python encoding (is there a way to check this?)\n        pass\n\n    if len(encodings) == 1:\n        encodings = [encodings[0]] * 3\n    elif len(encodings) == 2:\n        encodings.append(encodings[1])\n\n    return encodings\n\n\ndef decode(data_element, dicom_character_set):\n    \"\"\"Apply the DICOM character encoding to the data element\n\n    data_element -- DataElement instance containing a value to convert\n    dicom_character_set -- the value of Specific Character Set (0008,0005),\n                    which may be a single value,\n                    a multiple value (code extension), or\n                    may also be '' or None.\n                    If blank or None, ISO_IR 6 is used.\n\n    \"\"\"\n    if not dicom_character_set:\n        dicom_character_set = ['ISO_IR 6']\n\n    encodings = convert_encodings(dicom_character_set)\n\n    if data_element.VR == \"PN\":\n        if not in_py2:\n            if data_element.VM == 1:\n                data_element.value = data_element.value.decode(encodings)\n            else:\n                data_element.value = [val.decode(encodings) for val in data_element.value]\n        else:\n            if data_element.VM == 1:\n                data_element.value = PersonNameUnicode(data_element.value, encodings)\n            else:\n                data_element.value = [PersonNameUnicode(value, encodings)\n                                      for value in data_element.value]\n    if data_element.VR in text_VRs:\n        if len(encodings) > 1:\n            del encodings[0]\n\n        if data_element.VM == 1:\n            if isinstance(data_element.value, compat.text_type):\n                return\n            data_element.value = clean_escseq(\n                data_element.value.decode(encodings[0]), encodings)\n        else:\n\n            output = list()\n\n            for value in data_element.value:\n                if isinstance(value, compat.text_type):\n                    output.append(value)\n                else:\n                    output.append(clean_escseq(value.decode(encodings[0]), encodings))\n\n            data_element.value = output\n",
  "line_no": 44,
  "line_no_percent": "35%"
}