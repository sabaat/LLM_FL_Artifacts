{
  "instruction": "This code tests BIP forks in Python 2. To run the test, follow these steps: \n\n1. Start a single node.\n2. Use regtest lock-in with 108/144 block signalling.\n3. Activate after a further 144 blocks.\n4. Mine 2 blocks and save coinbases for later use.\n5. Mine 141 blocks to transition from DEFINED to STARTED.\n6. Mine 100 blocks signalling readiness and 44 not in order to fail to change state this period.\n7. Mine 108 blocks signalling readiness and 36 blocks not signalling readiness (STARTED->LOCKED_IN).\n8. Mine a further 143 blocks (LOCKED_IN).\n9. Test that enforcement has not triggered (which triggers ACTIVE).\n10. Test that enforcement has triggered.",
  "buggy_code": "from test_framework.test_framework import ComparisonTestFramework\nfrom test_framework.util import *\nfrom test_framework.mininode import CTransaction, NetworkThread\nfrom test_framework.blocktools import create_coinbase, create_block\nfrom test_framework.comptool import TestInstance, TestManager\nfrom test_framework.script import CScript, OP_1NEGATE, OP_NOP3, OP_DROP\nfrom binascii import hexlify, unhexlify\nimport cStringIO\nimport time\nimport itertools\n\n'''\nThis test is meant to exercise BIP forks\nConnect to a single node.\nregtest lock-in with 108/144 block signalling\nactivation after a further 144 blocks\nmine 2 block and save coinbases for later use\nmine 141 blocks to transition from DEFINED to STARTED\nmine 100 blocks signalling readiness and 44 not in order to fail to change state this period\nmine 108 blocks signalling readiness and 36 blocks not signalling readiness (STARTED->LOCKED_IN)\nmine a further 143 blocks (LOCKED_IN)\ntest that enforcement has not triggered (which triggers ACTIVE)\ntest that enforcement has triggered\n'''\n\n\n\nclass BIP9SoftForksTest(ComparisonTestFramework):\n\n    def __init__(self):\n        self.num_nodes = 1\n\n    def setup_network(self):\n        self.nodes = start_nodes(1, self.options.tmpdir,\n                                 extra_args=[['-debug', '-whitelist=127.0.0.1']],\n                                 binary=[self.options.testbinary])\n\n    def run_test(self):\n        self.test = TestManager(self, self.options.tmpdir)\n        self.test.add_all_connections(self.nodes)\n        NetworkThread().start() # Start up network handling in another thread\n        self.test.run()\n\n    def create_transaction(self, node, coinbase, to_address, amount):\n        from_txid = node.getblock(coinbase)['tx'][0]\n        inputs = [{ \"txid\" : from_txid, \"vout\" : 0}]\n        outputs = { to_address : amount }\n        rawtx = node.createrawtransaction(inputs, outputs)\n        tx = CTransaction()\n        f = cStringIO.StringIO(unhexlify(rawtx))\n        tx.deserialize(f)\n        tx.nVersion = 2\n        return tx\n\n    def sign_transaction(self, node, tx):\n        signresult = node.signrawtransaction(hexlify(tx.serialize()))\n        tx = CTransaction()\n        f = cStringIO.StringIO(unhexlify(signresult['hex']))\n        tx.deserialize(f)\n        return tx\n\n    def generate_blocks(self, number, version, test_blocks = []):\n        for i in xrange(number):\n            block = create_block(self.tip, create_coinbase(self.height), self.last_block_time + 1)\n            block.nVersion = version\n            block.rehash()\n            block.solve()\n            test_blocks.append([block, True])\n            self.last_block_time += 1\n            self.tip = block.sha256\n            self.height += 1\n        return test_blocks\n\n    def get_bip9_status(self, key):\n        info = self.nodes[0].getblockchaininfo()\n        for row in info['bip9_softforks']:\n            if row['id'] == key:\n                return row\n        raise IndexError ('key:\"%s\" not found' % key)\n\n\n    def test_BIP(self, bipName, activated_version, invalidate, invalidatePostSignature):\n        self.coinbase_blocks = self.nodes[0].generate(2)\n        self.height = 3  # height of the next block to build\n        self.tip = int (\"0x\" + self.nodes[0].getbestblockhash() + \"L\", 0)\n        self.nodeaddress = self.nodes[0].getnewaddress()\n        self.last_block_time = int(time.time())\n\n        assert_equal(self.get_bip9_status(bipName)['status'], 'defined')\n\n        test_blocks = self.generate_blocks(141, 4)\n        yield TestInstance(test_blocks, sync_every_block=False)\n\n        assert_equal(self.get_bip9_status(bipName)['status'], 'started')\n\n        test_blocks = self.generate_blocks(50, activated_version) # 0x20000001 (signalling ready)\n        test_blocks = self.generate_blocks(20, 4, test_blocks) # 0x00000004 (signalling not)\n        test_blocks = self.generate_blocks(50, activated_version, test_blocks) # 0x20000101 (signalling ready)\n        test_blocks = self.generate_blocks(24, 4, test_blocks) # 0x20010000 (signalling not)\n        yield TestInstance(test_blocks, sync_every_block=False)\n\n        assert_equal(self.get_bip9_status(bipName)['status'], 'started')\n\n        test_blocks = self.generate_blocks(58, activated_version) # 0x20000001 (signalling ready)\n        test_blocks = self.generate_blocks(26, 4, test_blocks) # 0x00000004 (signalling not)\n        test_blocks = self.generate_blocks(50, activated_version, test_blocks) # 0x20000101 (signalling ready)\n        test_blocks = self.generate_blocks(10, 4, test_blocks) # 0x20010000 (signalling not)\n        yield TestInstance(test_blocks, sync_every_block=False)\n\n        assert_equal(self.get_bip9_status(bipName)['status'], 'locked_in')\n\n        test_blocks = self.generate_blocks(143, 4)\n        yield TestInstance(test_blocks, sync_every_block=False)\n\n        assert_equal(self.get_bip9_status(bipName)['status'], 'locked_in')\n\n        spendtx = self.create_transaction(self.nodes[0],\n                self.coinbase_blocks[0], self.nodeaddress, 1.0)\n        invalidate(spendtx)\n        spendtx = self.sign_transaction(self.nodes[0], spendtx)\n        spendtx.rehash()\n        invalidatePostSignature(spendtx)\n        spendtx.rehash()\n        block = create_block(self.tip, create_coinbase(self.height), self.last_block_time + 1)\n        block.nVersion = activated_version\n        block.vtx.append(spendtx)\n        block.hashMerkleRoot = block.calc_merkle_root()\n        block.rehash()\n        block.solve()\n\n        self.last_block_time += 1\n        self.tip = block.sha256\n        self.height += 1\n        yield TestInstance([[block, True]])\n\n        assert_equal(self.get_bip9_status(bipName)['status'], 'active')\n\n        spendtx = self.create_transaction(self.nodes[0],\n                self.coinbase_blocks[1], self.nodeaddress, 1.0)\n        invalidate(spendtx)\n        spendtx = self.sign_transaction(self.nodes[0], spendtx)\n        spendtx.rehash()\n        invalidatePostSignature(spendtx)\n        spendtx.rehash()\n\n        block = create_block(self.tip, create_coinbase(self.height), self.last_block_time + 1)\n        block.nVersion = 5\n        block.vtx.append(spendtx)\n        block.hashMerkleRoot = block.calc_merkle_root()\n        block.rehash()\n        block.solve()\n        self.last_block_time += 1\n        yield TestInstance([[block, False]])\n\n        stop_nodes(self.nodes)\n        wait_deuscoinds()\n        shutil.rmtree(self.options.tmpdir)\n        self.setup_chain()\n        self.setup_network()\n        self.test.clear_all_connections()\n        self.test.add_all_connections(self.nodes)\n        NetworkThread().start() # Start up network handling in another thread\n\n\n\n    def get_tests(self):\n        for test in itertools.chain(\n                self.test_BIP('csv', 536870913, self.sequence_lock_invalidate, self.donothing),\n                self.test_BIP('csv', 536870913, self.mtp_invalidate, self.donothing),\n                self.test_BIP('csv', 536870913, self.donothing, self.csv_invalidate)\n        ):\n            yield test\n\n    def donothing(self, tx):\n        return\n\n    def csv_invalidate(self, tx):\n        return\n        '''Modify the signature in vin 0 of the tx to fail CSV\n        Prepends -1 CSV DROP in the scriptSig itself.\n        '''\n        tx.vin[0].scriptSig = CScript([OP_1NEGATE, OP_NOP3, OP_DROP] +\n                                      list(CScript(tx.vin[0].scriptSig)))\n\n    def sequence_lock_invalidate(self, tx):\n        '''Modify the nSequence to make it fails once sequence lock rule is activated (high timespan)\n        '''\n        tx.vin[0].nSequence = 0x00FFFFFF\n        tx.nLockTime = 0\n\n    def mtp_invalidate(self, tx):\n        '''Modify the nLockTime to make it fails once MTP rule is activated\n        '''\n        tx.vin[0].nSequence = 0x90FFFFFF\n        tx.nLockTime = self.last_block_time\n\nif __name__ == '__main__':\n    BIP9SoftForksTest().main()\n",
  "line_no": 178,
  "line_no_percent": "90%"
}