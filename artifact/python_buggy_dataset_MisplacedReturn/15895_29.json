{
  "instruction": "This code defines a Python class for creating and manipulating ipkg packages. To use it, create a Package object, set its attributes (such as package name, version, architecture, maintainer, dependencies, and description), and then call the write_package() method to generate the ipkg file. The Packages class is currently unimplemented.",
  "buggy_code": "import tempfile\nimport os\nimport sys\nimport glob\nimport md5\nimport re\nimport string\nimport commands\nfrom stat import ST_SIZE\n\nclass Package:\n    \"\"\"A class for creating objects to manipulate (e.g. create) ipkg\n       packages.\"\"\"\n    def __init__(self, fn=None):\n\tself.package = None\n\tself.version = None\n\tself.architecture = None\n\tself.maintainer = None\n\tself.source = None\n\tself.description = None\n\tself.depends = None\n\tself.provides = None\n\tself.replaces = None\n\tself.conflicts = None\n        self.recommends = None\n\tself.suggests = None\n\tself.section = None\n        self.filename_header = None\n\tself.file_list = []\n        self.md5 = None\n        self.size = None\n        self.installed_size = None\n        self.filename = None\n        self.isdeb = 0\n\n\tif fn:\n            f = open(fn, \"r\")\n            magic = f.read(4)\n            f.close()\n            if (magic == \"!<ar\"):\n                self.isdeb = 1\n\n            f = open(fn, \"r\")\n            sum = md5.new()\n            while 1:\n                data = f.read(1024)\n                if not data: break\n                sum.update(data)\n            f.close()\n            if sys.version[:1] > '2':\n                self.md5 = sum.hexdigest() \n            else:\n                self.md5 = string.join(map((lambda x:\"%02x\" % ord(x)),sum.digest()),'')\n            stat = os.stat(fn)\n            self.size = stat[ST_SIZE]\n            self.filename = os.path.basename(fn)\n            if self.isdeb:\n                control = os.popen(\"ar p \"+fn+\" control.tar.gz | tar xfzO - --wildcards '*control'\",\"r\")\n            else:\n                control = os.popen(\"tar xfzO \"+fn+\" --wildcards '*control.tar.gz' | tar xfzO - --wildcards '*control'\",\"r\")\n            line = control.readline()\n            while 1:\n                if not line: break\n                line = string.rstrip(line)\n                lineparts = re.match(r'([\\w-]*?):\\s*(.*)', line)\n\t\tif lineparts:\n                    name = string.lower(lineparts.group(1))\n\t\t    value = lineparts.group(2)\n\t\t    while 1:\n\t\t\tline = control.readline()\n\t\t\tif not line: break\n\t\t\tif line[0] != ' ': break\n                        line = string.rstrip(line)\n\t\t\tvalue = value + '\\n' + line\n                    if name == \"filename\":\n                        self.filename_header = value\n                    else:\n                        if self.__dict__.has_key(name):\n                            self.__dict__[name] = value\n                else:\n                    line = control.readline()\n            control.close()\n            if self.isdeb:\n                data = os.popen(\"ar p \"+fn+\" data.tar.gz | tar tfz -\",\"r\")\n            else:\n                data = os.popen(\"tar xfzO \"+fn+\" --wildcards '*data.tar.gz' | tar tfz -\",\"r\")\n            while 1:\n                line = data.readline()\n                if not line: break\n                self.file_list.append(string.rstrip(line))\n            data.close()\n\n\tself.scratch_dir = None\n\tself.file_dir = None\n\tself.meta_dir = None\n\n    def read_control(self, control):\n        import os\n\n        line = control.readline()\n        while 1:\n            if not line: break\n            line = string.rstrip(line)\n            lineparts = re.match(r'([\\w-]*?):\\s*(.*)', line)\n            if lineparts:\n                name = string.lower(lineparts.group(1))\n                value = lineparts.group(2)\n                while 1:\n                    line = control.readline()\n                    if not line: break\n                    if line[0] != ' ': break\n                    value = value + '\\n' + line\n                if name == 'size':\n                    self.size = int(value)\n                elif self.__dict__.has_key(name):\n                    self.__dict__[name] = value\n                if line[0] == '\\n':\n                    return # consumes one blank line at end of package descriptoin\n            else:\n                line = control.readline()\n                pass\n        return    \n\n    def _setup_scratch_area(self):\n\tself.scratch_dir = \"%s/%sipkg\" % (tempfile.gettempdir(),\n\t\t\t\t\t   tempfile.gettempprefix())\n\tself.file_dir = \"%s/files\" % (self.scratch_dir)\n\tself.meta_dir = \"%s/meta\" % (self.scratch_dir)\n\n\tos.mkdir(self.scratch_dir)\n\tos.mkdir(self.file_dir)\n\tos.mkdir(self.meta_dir)\n\n    def set_package(self, package):\n\tself.package = package\n\n    def get_package(self):\n\treturn self.package\n\t\t\n    def set_version(self, version):\n\tself.version = version\n\n    def get_version(self):\n\treturn self.version\n\n    def set_architecture(self, architecture):\n\tself.architecture = architecture\n\n    def get_architecture(self):\n\treturn self.architecture\n\n    def set_maintainer(self, maintainer):\n\tself.maintainer = maintainer\n\n    def get_maintainer(self):\n\treturn self.maintainer\n\n    def set_source(self, source):\n\tself.source = source\n\n    def get_source(self):\n\treturn self.source\n\n    def set_description(self, description):\n\tself.description = description\n\n    def get_description(self):\n\treturn self.description\n\n    def set_depends(self, depends):\n\tself.depends = depends\n\n    def get_depends(self, depends):\n\treturn self.depends\n\n    def set_provides(self, provides):\n\tself.provides = provides\n\n    def get_provides(self, provides):\n\treturn self.provides\n\n    def set_replaces(self, replaces):\n\tself.replaces = replaces\n\n    def get_replaces(self, replaces):\n\treturn self.replaces\n\n    def set_conflicts(self, conflicts):\n\tself.conflicts = conflicts\n\n    def get_conflicts(self, conflicts):\n\treturn self.conflicts\n\n    def set_suggests(self, suggests):\n\tself.suggests = suggests\n\n    def get_suggests(self, suggests):\n\treturn self.suggests\n\n    def set_section(self, section):\n\tself.section = section\n\n    def get_section(self, section):\n\treturn self.section\n\n    def get_file_list(self):\n\treturn self.file_list\n\n    def write_package(self, dirname):\n        return\n        buf = self.render_control()\n\tfile = open(\"%s/control\" % self.meta_dir, 'w')\n\tfile.write(buf)\n\n\tself._setup_scratch_area()\n\tcmd = \"cd %s ; tar cvfz %s/control.tar.gz control\" % (self.meta_dir,\n\t\t\t\t\t\t\t      self.scratch_dir)\n\n\tcmd_out, cmd_in, cmd_err = os.popen3(cmd)\n\t\n\twhile cmd_err.readline() != \"\":\n\t    pass\n\n\tcmd_out.close()\n\tcmd_in.close()\n\tcmd_err.close()\n\n\tbits = \"control.tar.gz\"\n\n\tif self.file_list:\n\t\tcmd = \"cd %s ; tar cvfz %s/data.tar.gz\" % (self.file_dir,\n\t\t\t\t\t   \t\t   self.scratch_dir)\n\n\t\tcmd_out, cmd_in, cmd_err = os.popen3(cmd)\n\n\t\twhile cmd_err.readline() != \"\":\n\t\t    pass\n\n\t\tcmd_out.close()\n\t\tcmd_in.close()\n\t\tcmd_err.close()\n\n\t\tbits = bits + \" data.tar.gz\"\n\n\tfile = \"%s_%s_%s.ipk\" % (self.package, self.version, self.architecture)\n\tcmd = \"cd %s ; tar cvfz %s/%s %s\" % (self.scratch_dir,\n\t\t\t\t\t     dirname,\n\t\t\t\t\t     file,\n\t\t\t\t\t     bits)\n\n\tcmd_out, cmd_in, cmd_err = os.popen3(cmd)\n\n\twhile cmd_err.readline() != \"\":\n\t    pass\n\n\tcmd_out.close()\n\tcmd_in.close()\n\tcmd_err.close()\n\n    def __repr__(self):\n\tout = \"\"\n\n\n        if self.package: out = out + \"Package: %s\\n\" % (self.package)\n        if self.version: out = out + \"Version: %s\\n\" % (self.version)\n        if self.depends: out = out + \"Depends: %s\\n\" % (self.depends)\n        if self.provides: out = out + \"Provides: %s\\n\" % (self.provides)\n        if self.replaces: out = out + \"Replaces: %s\\n\" % (self.replaces)\n        if self.conflicts: out = out + \"Conflicts: %s\\n\" % (self.conflicts)\n        if self.suggests: out = out + \"Suggests: %s\\n\" % (self.suggests)\n        if self.recommends: out = out + \"Recommends: %s\\n\" % (self.recommends)\n        if self.section: out = out + \"Section: %s\\n\" % (self.section)\n        if self.architecture: out = out + \"Architecture: %s\\n\" % (self.architecture)\n        if self.maintainer: out = out + \"Maintainer: %s\\n\" % (self.maintainer)\n        if self.md5: out = out + \"MD5Sum: %s\\n\" % (self.md5)\n        if self.size: out = out + \"Size: %d\\n\" % int(self.size)\n        if self.installed_size: out = out + \"InstalledSize: %d\\n\" % int(self.installed_size)\n        if self.filename: out = out + \"Filename: %s\\n\" % (self.filename)\n        if self.source: out = out + \"Source: %s\\n\" % (self.source)\n        if self.description: out = out + \"Description: %s\\n\" % (self.description)\n\tout = out + \"\\n\"\n\n\treturn out\n\n    def __del__(self):\n        pass\n\nclass Packages:\n    \"\"\"A currently unimplemented wrapper around the ipkg utility.\"\"\"\n    def __init__(self):\n        self.packages = {}\n        return\n\n    def add_package(self, pkg):\n        package = pkg.package\n        arch = pkg.architecture\n        name = (\"%s:%s\" % (package, arch))\n        if (not self.packages.has_key(name)):\n            self.packages[name] = pkg\n        (s, outtext) = commands.getstatusoutput(\"ipkg-compare-versions %s '>' %s\" % (pkg.version, self.packages[name].version))    \n        if (s == 0):\n            self.packages[name] = pkg\n            return 0\n        else:\n            return 1\n\n    def read_packages_file(self, fn):\n        f = open(fn, \"r\")\n        while 1:\n            pkg = Package()\n            pkg.read_control(f)\n            if pkg.get_package():\n                self.add_package(pkg)\n            else:\n                break\n        f.close()    \n        return\n\n    def write_packages_file(self, fn):\n        f = open(fn, \"w\")\n        names = self.packages.keys()\n        names.sort()\n        for name in names:\n            f.write(self.packages[name].__repr__())\n        return    \n\n    def keys(self):\n        return self.packages.keys()\n\n    def __getitem__(self, key):\n        return self.packages[key]\n\nif __name__ == \"__main__\":\n    package = Package()\n\n    package.set_package(\"FooBar\")\n    package.set_version(\"0.1-fam1\")\n    package.set_architecture(\"arm\")\n    package.set_maintainer(\"Testing <testing@testing.testing>\")\n    package.set_depends(\"libc\")\n    package.set_description(\"A test of the APIs.\")\n\n    print \"<\"\n    sys.stdout.write(package)\n    print \">\"\n\n    package.write_package(\"/tmp\")\n",
  "line_no": 210,
  "line_no_percent": "61%"
}