{
  "instruction": "This code is a DNS server that listens for queries and responds based on pre-defined rules. To use it, run the \"run\" function with input and output file objects. The input file should contain lines representing DNS queries in the format \"cmd\\tqname\\tqclass\\tqtype\\tid\\tremote-ip\\tlocal-ip\\tedns-subnet-address\". The output file will contain the server's responses in the format \"DATA\\tqname\\tqclass\\tqtype\\tttl\\tid\\tdata\". The server's behavior is controlled by defining \"match\" functions with specific conditions and return values. These functions should be decorated with the \"match\" decorator and added to the \"matches\" list. The server also defines several helper functions for constructing DNS responses and logging.",
  "buggy_code": "from sys import exit, stdin, stderr, argv, stdout\nfrom inspect import stack\nfrom config import *\nimport os\nimport csv\n\nCONT=0\nFINAL=1\n\ndefault_ttl=60\nloglevel=3\n\nclass istr(str):\n    def __eq__(self, text):\n        return str.__eq__(self.lower(), text.lower())\n\nclass qname(istr):\n    def __new__(cls, value, *args, **kwargs):\n        return istr.__new__(cls, value)\n    def _domain_parts(self,request):\n        return map(lambda x: istr(x), filter(lambda x: x!='', self.split('.')))\n    def _domain_parts_len(self,request):\n        return len(domain_parts(request))\n    def _tld(self, count=2):\n        return istr('.'.join(self.domain_parts[-count:]))\n    def __init__(self, value, minlen=None, maxlen=None):\n        self.domain_parts=self._domain_parts(value)\n        self.domain_parts_count=len(self.domain_parts)\n        self.tld=self._tld()\n    def host_part(self, substring):\n        try:\n            if self.lower().index(substring+'.')==0:\n                return True\n        except ValueError:\n            return False\n        return False\n    def is_subdomain(string, substring):\n        try:\n            return (string.lower().rindex('.'+substring)+len(substring)+1 == len(string))\n        except ValueError:\n            return False\n        return False\n\ndef logd(level=loglevel, message=None, kwargs={}):\n    if level>=loglevel:\n        print(\"LOG\\t%s(): %s\" % (stack()[1][3],'; '.join([message,', '.join(map(lambda (k,v): \"%s='%s'\" % (k,v), kwargs.iteritems()))])))\n\ndef log(level=loglevel, message=None, **kwargs):\n    return\n    if level>=loglevel:\n        print(\n            \"LOG\\t%s(): %s\" % (\n                stack()[1][3],\n                '; '.join(\n                    [\n                        message,\n                        ', '.join(\n                            map(lambda (k,v): \"%s='%s'\" % (k,v), kwargs.iteritems())\n                            )\n                    ]\n                )\n            )\n        )\n\ndef MX(priority=0, data=None, ttl=default_ttl):\n    if data:\n        return {\n            'qtype': 'MX',\n            'data':\"%s\\t%s\" % (priority, data),\n            'ttl': ttl\n        }\n    else:\n        return {}\n\ndef LOG(msg):\n    pass\n\ndef A(data=None, ttl=default_ttl):\n    if data:\n        return {\n            'qtype': 'A',\n            'data': data,\n            'ttl': ttl\n        }\n    else:\n        return {}\n\ndef match_domain(name, domain):\n    if name[-len(domain):] == domain or name[-len(domain)-1:] == '.'+domain:\n        return True\n    return False\n\nmatches=[]\ndef match(host=None, fqdn=None, domain=None, dns_class=None, type=None, remote_ip=None, local_ip=None, cache=True):\n    params=locals()\n    def wrapper(f):\n        matches.append([f, params])\n    return wrapper\n\ndef represent(response):\n    return \"\\t\".join([\n        'DATA',\n        response['qname'],\n        response['qclass'],\n        response['qtype'],\n        str(response['ttl']),\n        response['id'],\n        response['data']\n    ])\n\ndef route(request):\n    retval=[]\n    if request['qname'] in skip_zones:\n        retval.append(\"LOG\\tqname '%s' is in skipped zones list, skipping\" % request['qname'])\n        return retval\n    for f, conditions in matches:\n        if (conditions['fqdn'] is None or conditions['fqdn'] == request['qname']) and \\\n            (conditions['domain'] is None or match_domain(request['qname'], conditions['domain'])) and \\\n            (conditions['type'] is None or conditions['type'] == request['qtype'] or request['qtype'] == 'ANY') and \\\n            (conditions['dns_class'] is None or conditions['dns_class'] == request['qclass']) and \\\n            (conditions['remote_ip'] is None or conditions['remote_ip'] == request['remote-ip']) and \\\n            (conditions['local_ip'] is None or conditions['local_ip'] == request['local-ip']):\n            returned=f(request)\n            if returned:\n                if returned[1]:\n                    if type(returned[1]) is list:\n                        for item in returned[1]:\n                            retval.append(\n                                represent(\n                                    dict(request.items() + item.items())\n                                )\n                            )\n                    else:\n                        retval.append(\n                            represent(\n                                dict(request.items() + returned[1].items())\n                            )\n                        )\n                    if returned[0] == FINAL:\n                        break\n    return retval\n\ndef run(f_in=stdin, f_out=stdout):\n    line = f_in.readline().strip()\n    if not line.startswith('HELO'):\n        print >>f_out, 'FAIL'\n        f_out.flush()\n        f_in.readline()\n    else:\n        print >>f_out, \"OK\\tapp firing up\"\n        f_out.flush()\n    while True:\n        line = f_in.readline().strip()\n        if not line:\n            break\n        request = dict(\n            zip(\n                ['cmd','qname','qclass','qtype','id','remote-ip','local-ip','edns-subnet-address'],\n                line.split('\\t')\n            )\n        )\n        request['qname']=qname(request['qname'])\n        if request['cmd'] == 'Q':\n            if request['qname'] != '':\n                datas=route(request)\n                if datas:\n                    print >>f_out, \"\\n\".join(datas)\n            print >>f_out, \"END\"\n            f_out.flush()\n        elif request['cmd'] == 'PING':\n            print >>f_out, \"LOG\\tPONG\"\n            f_out.flush()\n            continue\n        elif request['cmd'] == 'HELO':\n            print >>f_out, \"OK\\trunning\"\n            f_out.flush()\n            continue\n        elif request['cmd'] == 'AXFR':\n            print >>f_out, \"END\"\n            f_out.flush()\n            continue\n        else:\n            print >>f_out, \"LOG\\tUnprocessed\"\n\ndef acme_b64encode(acme_challenge):\n    return acme_challenge.replace('_','_u').replace('-','_h')\n\ndef acme_b64decode(acme_challenge):\n    return acme_challenge.replace('_h','-').replace('_u','_')\n",
  "line_no": 49,
  "line_no_percent": "26%"
}