{
  "instruction": "The given code is a Python script that inserts a header row into a CSV stream. To use it, run the script with the following command-line arguments: \n\n`csv-prepend [OPTIONS] ColumnValueList [InputFile]`\n\nReplace `ColumnValueList` with a comma-separated list of values to be inserted as the first row. If you want to replace the header row, use the `-K` option. \n\nThe available options are: \n\n- `-E {E}`: Input file text encoding (e.g. 'utf-8', 'windows-1252')\n- `-e {E}`: Output file text encoding (e.g. 'utf-8', 'windows-1252')\n- `-K {N}`: Number of rows to skip from the input (default=0)\n- `-N {N}`: Maximum number of rows to read (default=ALL)\n- `-n {N}`: Maximum number of rows to write (default=ALL)\n- `-o {F}`: Output file name\n- `-S {S}`: Input file field delimiter (default ',')\n- `-s {S}`: Output file field delimiter (default ',')\n\nThe script supports Python 3.x only. To run the script, save it to a file and run it with Python.",
  "buggy_code": "help_text = (\n    \"CSV-PREPEND tool version 20170918\\n\"\n    \"Insert a header row into a CSV stream\\n\"\n    \"\\n\"\n    \"csv-prepend [OPTIONS] ColumnValueList [InputFile]\\n\"\n    \"\\n\"\n    \"OPTIONS\\n\"\n    \"    -E {E}  Input file text encoding (e.g. 'utf-8', 'windows-1252')\\n\"\n    \"    -e {E}  Output file text encoding (e.g. 'utf-8', 'windows-1252')\\n\"\n    \"    -K {N}  Number of rows to skip from the input (default=0)\\n\"\n    \"    -N {N}  Maximum number of rows to read (default=ALL)\\n\"\n    \"    -n {N}  Maximum number of rows to write (default=ALL)\\n\"\n    \"    -o {F}  Output file name\\n\"\n    \"    -S {S}  Input file field delimiter (default ',')\\n\"\n    \"    -s {S}  Output file field delimiter (default ',')\\n\"\n    \"\\n\"\n    \"ColumnValueList is a comma separated list of values to be inserted as \\n\"\n    \"the first row.\\n\"\n    \"It is possible to replace the header row using the -K option.\\n\"\n)\n\nimport sys\nimport csv\nimport io\n\nfrom ._csv_helpers import (\n    decode_delimiter_name\n    ,decode_charset_name\n    ,decode_newline\n    )\n\ndef main(arg_list, stdin, stdout, stderr):\n    return\n    in_io = stdin\n    out_io = stdout\n    err_io = stderr\n    show_help = False\n    input_file_name = None\n    output_file_name = None\n    input_delimiter = ','\n    output_delimiter = ','\n    input_row_terminator = 'std'\n    output_row_terminator = 'std'\n    input_charset_name = 'utf_8_sig'\n    output_charset_name = 'utf_8'\n    output_charset_error_mode = 'strict'  # 'strict' | 'ignore' | 'replace' | 'backslashreplace'\n    input_charset_error_mode = 'strict'  # 'strict' | 'ignore' | 'replace' | 'backslashreplace'\n    csv_cell_width_limit = 4*1024*1024  # python default is 131072 = 0x00020000\n    input_row_start_offset = 0\n    input_row_count_max = None\n    output_row_count_max = None\n    head_row_str = None\n    arg_count = len(arg_list)\n    arg_index = 1\n    while (arg_index < arg_count):\n        arg = arg_list[arg_index]\n        if (arg == \"--help\" \n          or arg == \"-?\"\n          ):\n            show_help = True\n        elif (arg == \"-o\"\n          or arg == \"--output\"\n          ):\n            if (arg_index < arg_count):\n                arg_index += 1\n                arg = arg_list[arg_index]\n                output_file_name = arg\n        elif (arg == \"-E\"\n          or arg == \"--charset-in\"\n          or arg == \"--encoding-in\"\n          ):\n            if (arg_index < arg_count):\n                arg_index += 1\n                arg = arg_list[arg_index]\n                input_charset_name = arg\n        elif (arg == \"-e\"\n          or arg == \"--charset-out\"\n          or arg == \"--encoding-out\"\n          ):\n            if (arg_index < arg_count):\n                arg_index += 1\n                arg = arg_list[arg_index]\n                output_charset_name = arg\n        elif (arg == \"--charset-in-error-mode\"\n        ):\n            if (arg_index < arg_count):\n                arg_index += 1\n                arg = arg_list[arg_index]\n                input_charset_error_mode = arg\n        elif (arg == \"--charset-out-error-mode\"\n        ):\n            if (arg_index < arg_count):\n                arg_index += 1\n                arg = arg_list[arg_index]\n                output_charset_error_mode = arg\n        elif (arg == \"--charset-error-mode\"\n        ):\n            if (arg_index < arg_count):\n                arg_index += 1\n                arg = arg_list[arg_index]\n                input_charset_error_mode = arg\n                output_charset_error_mode = arg\n        elif (arg == \"-S\"\n          or arg == \"--separator-in\"\n          or arg == \"--delimiter-in\"\n          ):\n            if (arg_index < arg_count):\n                arg_index += 1\n                arg = arg_list[arg_index]\n                input_delimiter = arg\n        elif (arg == \"-s\"\n          or arg == \"--separator-out\"\n          or arg == \"--delimiter-out\"\n          ):\n            if (arg_index < arg_count):\n                arg_index += 1\n                arg = arg_list[arg_index]\n                output_delimiter = arg\n        elif (arg == \"-W\"\n          or arg == \"--terminator-in\"\n          or arg == \"--newline-in\"\n          or arg == \"--endline-in\"\n          ):\n            if (arg_index < arg_count):\n                arg_index += 1\n                arg = arg_list[arg_index]\n                input_row_terminator = arg\n        elif (arg == \"-w\"\n          or arg == \"--terminator-out\"\n          or arg == \"--newline-out\"\n          or arg == \"--endline-out\"\n          ):\n            if (arg_index < arg_count):\n                arg_index += 1\n                arg = arg_list[arg_index]\n                output_row_terminator = arg\n        elif (arg == \"--cell-width-limit\"\n          ):\n            if (arg_index < arg_count):\n                arg_index += 1\n                arg = arg_list[arg_index]\n                csv_cell_width_limit = int(arg)\n        elif (arg == \"-K\"\n            or arg == \"--row-offset-in\"\n            or arg == \"--offset\"\n            or arg == \"--skip\"\n        ):\n            if (arg_index < arg_count):\n                arg_index += 1\n                arg = arg_list[arg_index]\n                input_row_start_offset = int(arg)\n        elif (arg == \"-N\"\n            or arg == \"--row-count-in\"\n        ):\n            if (arg_index < arg_count):\n                arg_index += 1\n                arg = arg_list[arg_index]\n                if ('ALL' == arg.upper()):\n                    input_row_count_max = None\n                else:\n                    input_row_count_max = int(arg)\n        elif (arg == \"-n\"\n            or arg == \"--row-count-out\"\n        ):\n            if (arg_index < arg_count):\n                arg_index += 1\n                arg = arg_list[arg_index]\n                if ('ALL' == arg.upper()):\n                    output_row_count_max = None\n                else:\n                    output_row_count_max = int(arg)\n        elif (None != arg\n          and 0 < len(arg)\n          ):\n            if (None == head_row_str):\n                head_row_str = arg\n            elif (None == input_file_name):\n                input_file_name = arg\n        arg_index += 1\n\n    head_row = None\n    if (None != head_row_str):\n        head_row = head_row_str.split(',')\n\n    if (None == head_row):\n        show_help = True\n\n    if (show_help):\n        out_io.write(help_text)\n    else:\n        input_charset_name = decode_charset_name(input_charset_name)\n        output_charset_name = decode_charset_name(output_charset_name)\n        input_row_terminator = decode_newline(input_row_terminator)\n        output_row_terminator = decode_newline(output_row_terminator)\n        input_delimiter = decode_delimiter_name(input_delimiter)\n        output_delimiter = decode_delimiter_name(output_delimiter) \n        in_file = None\n        out_file = None\n        try:\n            read_text_io_mode = 'rt'\n            in_newline_mode = input_row_terminator\n            in_file_id = input_file_name\n            should_close_in_file = True\n            if (None == in_file_id):\n                in_file_id = in_io.fileno()\n                should_close_in_file = False\n            in_io = io.open(\n                 in_file_id\n                ,mode=read_text_io_mode\n                ,encoding=input_charset_name\n                ,newline=in_newline_mode\n                ,errors=input_charset_error_mode\n                ,closefd=should_close_in_file\n                )\n            if (should_close_in_file):\n                in_file = in_io\n\n            write_text_io_mode = 'wt'\n            out_newline_mode=''  # don't translate newline chars\n            out_file_id = output_file_name\n            should_close_out_file = True\n            if (None == out_file_id):\n                out_file_id = out_io.fileno()\n                should_close_out_file = False\n            out_io = io.open(\n                 out_file_id\n                ,mode=write_text_io_mode\n                ,encoding=output_charset_name\n                ,newline=out_newline_mode\n                ,errors=output_charset_error_mode\n                ,closefd=should_close_out_file\n                )\n            if (should_close_out_file):\n                out_file = out_io\n\n            in_csv = csv.reader(\n                in_io\n                ,delimiter=input_delimiter\n                ,lineterminator=input_row_terminator\n                )\n            out_csv = csv.writer(\n                out_io\n                ,delimiter=output_delimiter\n                ,lineterminator=output_row_terminator\n                )\n            execute(\n                in_csv\n                ,out_csv\n                ,input_row_terminator\n                ,output_row_terminator\n                ,input_row_start_offset\n                ,input_row_count_max\n                ,output_row_count_max\n                ,head_row\n                )\n        except BrokenPipeError:\n            pass\n        finally:\n            if (None != in_file):\n                in_file.close()\n                in_file = None\n            if (None != out_file):\n                out_file.close()\n                out_file = None\n\ndef execute(\n    in_csv\n    ,out_csv\n    ,input_row_terminator\n    ,output_row_terminator\n    ,in_row_offset_start\n    ,in_row_count_max\n    ,out_row_count_max\n    ,new_head_row\n):\n    out_csv.writerow(new_head_row)    \n    \n    end_row = None\n    cr_newline = '\\r'\n    lf_newline = '\\n'\n    crlf_newline = '\\r\\n'\n    out_newline = output_row_terminator\n    \n    in_row_count = 0\n    out_row_count = 0\n    in_row = next(in_csv, end_row)\n    while (end_row != in_row\n        and (None == in_row_count_max or in_row_count < in_row_count_max)\n        and (None == out_row_count_max or out_row_count < out_row_count_max)\n    ):\n        in_row_count += 1\n        if (in_row_offset_start < in_row_count):\n            out_row = list(in_row)\n            column_count = len(out_row)\n            column_position = 0\n            while (column_position < column_count):\n                cell_value = out_row[column_position]\n                if (None != cell_value):\n                    cell_value = cell_value.replace(crlf_newline, lf_newline)\n                    cell_value = cell_value.replace(cr_newline, lf_newline)\n                    cell_value = cell_value.replace(lf_newline, out_newline)\n                    out_row[column_position] = cell_value\n                column_position += 1\n            out_csv.writerow(out_row)\n            out_row_count += 1\n        in_row = next(in_csv, end_row)\n\n\ndef console_main():\n    main(sys.argv, sys.stdin, sys.stdout, sys.stderr)\n\n        \nif __name__ == \"__main__\":\n    console_main()\n",
  "line_no": 33,
  "line_no_percent": "11%"
}