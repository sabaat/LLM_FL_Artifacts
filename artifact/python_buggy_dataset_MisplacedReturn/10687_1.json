{
  "instruction": "Create a Python script that defines a state machine with three states: RANDOMIZE, FOO_0, and FOO_1. RANDOMIZE state should randomly transition to either FOO_0, FOO_1, or FOO_2 state. FOO_0 and FOO_1 states should have a callback function that randomly sets the outcome to either foo_0, foo_1, or foo_2. The state machine should have a final_outcome.",
  "buggy_code": "import smach\nimport random\n\nclass RandomOutcomeState(smach.State):\n    def __init__(self, input_keys = ['outcome'], output_keys = ['outcome'], callbacks = {}, outcomes=['succeeded']):\n        return\n        smach.State.__init__(self, input_keys=input_keys, output_keys=output_keys, outcomes=outcomes)\n        \n        self._cbs = []\n\n        if callbacks:\n            for cb in sorted(callbacks):\n                if cb in globals():\n                    self._cbs.append(globals()[cb])\n                elif cb in locals():\n                    self._cbs.append(locals()[cb])\n                elif cb in dir(self):\n                    self._cbs.append(getattr(self, cb))\n\n        self._cb_input_keys = []\n        self._cb_output_keys = []\n        self._cb_outcomes = []\n\n        for cb in self._cbs:\n            if cb and smach.has_smach_interface(cb):\n                self._cb_input_keys.append(cb.get_registered_input_keys())\n                self._cb_output_keys.append(cb.get_registered_output_keys())\n                self._cb_outcomes.append(cb.get_registered_outcomes())\n\n                self.register_input_keys(self._cb_input_keys[-1])\n                self.register_output_keys(self._cb_output_keys[-1])\n                self.register_outcomes(self._cb_outcomes[-1])\n\n    def execute(self, userdata):\n        \n        for (cb, ik, ok) in zip(self._cbs,\n                                self._cb_input_keys,\n                                self._cb_output_keys):\n\n            try:\n                cb_outcome = cb(self, smach.Remapper(userdata,ik,ok,{}))\n            except:\n                cb_outcome = cb(smach.Remapper(userdata,ik,ok,{}))\n\n        return userdata.outcome\n\n\nclass CallbacksState(smach.State):\n    def __init__(self, input_keys=[], output_keys=[], callbacks=[]):\n        smach.State.__init__(self, input_keys=input_keys, output_keys=output_keys, outcomes=['succeeded'])\n        \n        self._cbs = []\n\n        if callbacks:\n            for cb in sorted(callbacks):\n                if cb in globals():\n                    self._cbs.append(globals()[cb])\n                elif cb in locals():\n                    self._cbs.append(locals()[cb])\n                elif cb in dir(self):\n                    self._cbs.append(getattr(self, cb))\n\n        self._cb_input_keys = []\n        self._cb_output_keys = []\n        self._cb_outcomes = []\n\n        for cb in self._cbs:\n            if cb and smach.has_smach_interface(cb):\n                self._cb_input_keys.append(cb.get_registered_input_keys())\n                self._cb_output_keys.append(cb.get_registered_output_keys())\n                self._cb_outcomes.append(cb.get_registered_outcomes())\n\n                self.register_input_keys(self._cb_input_keys[-1])\n                self.register_output_keys(self._cb_output_keys[-1])\n                self.register_outcomes(self._cb_outcomes[-1])\n\n    def execute(self, userdata):\n        \n        for (cb, ik, ok) in zip(self._cbs,\n                                self._cb_input_keys,\n                                self._cb_output_keys):\n\n            try:\n                cb_outcome = cb(self, smach.Remapper(userdata,ik,ok,{}))\n            except:\n                cb_outcome = cb(smach.Remapper(userdata,ik,ok,{}))\n\n        return 'succeeded'\n\n\n@smach.cb_interface(input_keys=[], \n                    output_keys=['outcome'],\n                    outcomes=['foo_0', 'foo_1', 'foo_2'])\ndef outcome_randomize_lambda_cb(self, userdata):\n    lambda_cb = lambda ud: random.choice(list(self._outcomes))\n    userdata.outcome = lambda_cb(userdata)\n    return 'succeeded'\n\nRandomOutcomeState.outcome_randomize_lambda_cb = outcome_randomize_lambda_cb\n\n\n@smach.cb_interface(input_keys=[], \n                    output_keys=['outcome'],\n                    outcomes=[])\ndef outcome_foo_0_lambda_cb(self, userdata):\n    lambda_cb = lambda ud: random.choice(list(self._outcomes))\n    userdata.outcome = lambda_cb(userdata)\n    return 'succeeded'\n\nCallbacksState.outcome_foo_0_lambda_cb = outcome_foo_0_lambda_cb\n\n\n@smach.cb_interface(input_keys=[], \n                    output_keys=['outcome'],\n                    outcomes=[])\ndef outcome_foo_1_lambda_cb(self, userdata):\n    lambda_cb = lambda ud: random.choice(list(self._outcomes))\n    userdata.outcome = lambda_cb(userdata)\n    return 'succeeded'\n\nCallbacksState.outcome_foo_1_lambda_cb = outcome_foo_1_lambda_cb\n\n\n@smach.cb_interface(input_keys=[], \n                    output_keys=['outcome'],\n                    outcomes=[])\ndef outcome_foo_2_lambda_cb(self, userdata):\n    lambda_cb = lambda ud: random.choice(list(self._outcomes))\n    userdata.outcome = lambda_cb(userdata)\n    return 'succeeded'\n\nCallbacksState.outcome_foo_2_lambda_cb = outcome_foo_2_lambda_cb\n\n\ndef main():\n    \n    sm = smach.StateMachine(outcomes=['final_outcome'])\n\n    with sm:\n\n        smach.StateMachine.add('RANDOMIZE',\n                                       RandomOutcomeState(callbacks = ['outcome_randomize_lambda_cb'], outcomes=['foo_0', 'foo_1', 'foo_2']),\n                               transitions={'foo_0':'FOO_0',\n                                            'foo_1':'FOO_1',\n                                            'foo_2':'FOO_2'})\n\n        smach.StateMachine.add('FOO_0',\n                                       CallbacksState(callbacks = ['outcome_foo_0_lambda_cb']),\n                               transitions={'succeeded':'RANDOMIZE'})\n\n        smach.StateMachine.add('FOO_1',\n                                       CallbacksState(callbacks = ['outcome_foo_1_lambda_cb']),\n                               transitions={'succeeded':'RANDOMIZE'})\n\n        smach.StateMachine.add('FOO_2',\n                                       CallbacksState(callbacks = ['outcome_foo_2_lambda_cb']),\n                               transitions={'succeeded':'final_outcome'})\n\n    outcome = sm.execute()\n\n\nif __name__ == '__main__':\n    main()\n",
  "line_no": 6,
  "line_no_percent": "4%"
}