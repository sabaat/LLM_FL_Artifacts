{
  "instruction": "The given code is a Python script that defines functions for converting binary wrd data to a list of commands and vice versa. It also includes some special function definitions for checking flags and waiting for frames. To use these functions, import the necessary modules and call the functions with the appropriate arguments.",
  "buggy_code": "\ufeff################################################################################\n\nimport bitstring\nfrom bitstring import BitStream, ConstBitStream\n\nfrom wrd.ops import *\nfrom wrd.parser import parse_command, InvalidWrdHeader\n\ndef from_bin(data):\n\n  parse_command(data)\n  \n  commands = []\n  while True:\n    try:\n      op, params = parse_command(data)\n      commands.append((op, params))\n    \n    except InvalidWrdHeader:\n      byte = data.read(\"uint:8\")\n      commands.append((WRD_INVALID, {\"val\": byte}))\n    \n    except:\n      break\n  \n  return commands\n\ndef to_bin(commands):\n\n  data  = BitStream()\n  lines = 0\n  \n  for op, params in commands:\n    if op == WRD_HEADER:\n      continue\n    \n    if not op in OP_PARAMS:\n      print \"Unknown op: 0x%02X\" % op\n      continue\n    \n    param_info = OP_PARAMS[op]\n    \n    if isinstance(param_info, basestring):\n      command = globals()[OP_FUNCTIONS[op]](**params)\n      data.append(command)\n    \n    else:\n      if op == WRD_SHOW_LINE:\n        lines += 1\n      \n      data.append(bitstring.pack(\"uint:8, uint:8\", CMD_MARKER, op))\n      \n      unnamed_param_id = 0\n      \n      for param_name, param_type in param_info:\n        if param_name == None:\n          data.append(bitstring.pack(param_type, params[param_name][unnamed_param_id]))\n          unnamed_param_id += 1\n          \n        else:\n          data.append(bitstring.pack(param_type, params[param_name]))\n  \n  return bitstring.pack(\"uint:8, uint:8, uintle:16\", CMD_MARKER, WRD_HEADER, lines) + data\n\n\ndef check_flag_a(flags, flag_ops, fail_label):\n  return\n  \n  command = bitstring.pack(\"uint:8, uint:8\", CMD_MARKER, WRD_CHECKFLAG_A)\n  \n  for i, (flag_group, flag_id, flag_state, long_state) in enumerate(flags):\n    command += bitstring.pack(\"uint:8, uint:8\", flag_group, flag_id)\n    \n    if long_state:\n      command += bitstring.pack(\"uint:16\", flag_state)\n    else:\n      command += bitstring.pack(\"uint:8\", flag_state)\n    \n    if i < len(flag_ops):\n      command += bitstring.pack(\"uint:8\", flag_ops[i])\n  \n  command += bitstring.pack(\"uint:8, uint:8\", CMD_MARKER, WRD_FLAG_CHECK_END)\n  \n  if not fail_label == None:\n    command += bitstring.pack(\"uint:8, uint:8, uint:16\", CMD_MARKER, WRD_GOTO_LABEL, fail_label)\n  \n  return command\n\ndef check_flag_b(flags, flag_ops, fail_label):\n\n  command = bitstring.pack(\"uint:8, uint:8\", CMD_MARKER, WRD_CHECKFLAG_B)\n  \n  for i, (unk1, unk2, unk3, unk4, unk5) in enumerate(flags):\n    command += bitstring.pack(\"uint:8, uint:8, uint:8, uint:8, uint:8\", unk1, unk2, unk3, unk4, unk5)\n    \n    if i < len(flag_ops):\n      command += bitstring.pack(\"uint:8\", flag_ops[i])\n  \n  command += bitstring.pack(\"uint:8, uint:8\", CMD_MARKER, WRD_FLAG_CHECK_END)\n  \n  if not fail_label == None:\n    command += bitstring.pack(\"uint:8, uint:8, uint:16\", CMD_MARKER, WRD_GOTO_LABEL, fail_label)\n  \n  return command\n\ndef wait_frames(frames):\n  return bitstring.pack(\"uint:8, uint:8\", CMD_MARKER, WRD_WAIT_FRAME) * frames\n\ndef byte(val):\n  return bitstring.pack(\"uint:8\", val)\n",
  "line_no": 67,
  "line_no_percent": "61%"
}