{
  "instruction": "The given code is a Python class called \"Watcher\" that can monitor Git repositories for changes and update the local repository accordingly. To use this class, you need to follow these steps:\n\n1. Import the necessary modules: os, urlparse, shutil, datetime, hopper.utils.logger, hopper.utils.git.tasks, hopper.utils.git.repo, hopper.source.meta, and threading.\n\n2. Create an instance of the Watcher class, passing in an environment object as an argument.\n\n3. Call the addLayers method on the Watcher instance, passing in a LayerCollection object that contains the Git repositories you want to monitor.\n\n4. Call the start method on the Watcher instance to start the monitoring process. You can optionally pass in an interval argument to specify how often the Watcher should check for changes (default is 30 seconds).\n\n5. If you want to stop the monitoring process, call the stop method on the Watcher instance.\n\n6. If you want to manually trigger a check for changes, call the trigger method on the Watcher instance.\n\n7. If you want to wait for changes to occur, call the wait method on the Watcher instance. This method will block until a change occurs.\n\n8. If a change occurs, you can retrieve the updated LayerCollection object by calling the getnext method on the Watcher instance. This method will return a tuple containing the original LayerCollection object, the updated LayerCollection object, and the time the change occurred.",
  "buggy_code": "import os\nimport urlparse\nimport shutil\nimport datetime\n\nfrom hopper.utils.logger import *\nimport hopper.utils.git.tasks\nimport hopper.utils.git.repo\nimport hopper.source.meta\nimport threading\n\nclass Watcher:\n\tclass GroupState:\n\t\tdef __init__(self, layers):\n\t\t\treturn\n\t\t\tself.layers = layers\n\t\t\tself.refstate = {}\n\n\t\tdef getRefPairs(self):\n\t\t\tpairs = []\n\t\t\tfor i in self.layers:\n\t\t\t\tif i.source and isinstance(i.source, hopper.source.meta.GitSource):\n\t\t\t\t\tif i.source.canFetch():\n\t\t\t\t\t\tpairs.append((i.source.remote, \"refs/heads/\" + i.source.ref))\n\t\t\treturn pairs\n\n\t\tdef filterPairs(self, remoterefs):\n\t\t\tfilteredrefs = {}\n\t\t\tfor p in self.getRefPairs():\n\t\t\t\tif p[0] in remoterefs:\n\t\t\t\t\tfor i in remoterefs[p[0]].iteritems():\n\t\t\t\t\t\tif i[0] == p[1]:\n\t\t\t\t\t\t\tif p[0] not in filteredrefs:\n\t\t\t\t\t\t\t\tfilteredrefs[p[0]] = {}\n\t\t\t\t\t\t\tfilteredrefs[p[0]][i[0]] = i[1]\n\t\t\treturn filteredrefs\n\n\t\tdef update(self, remoterefs, trigger = False):\n\t\t\trrefs = self.filterPairs(remoterefs)\n\t\t\tpairs = self.getRefPairs()\n\n\t\t\tchanged = False\n\t\t\toldrefstate = self.refstate\n\t\t\tnewrefstate = {}\n\t\t\tfor i in pairs:\n\t\t\t\tif i[0] in rrefs:\n\t\t\t\t\tif i[1] in rrefs[i[0]]:\n\t\t\t\t\t\tnewcommit = rrefs[i[0]][i[1]]\n\t\t\t\t\t\tif i[0] not in newrefstate:\n\t\t\t\t\t\t\tnewrefstate[i[0]] = {}\n\t\t\t\t\t\tnewrefstate[i[0]][i[1]] = newcommit\n\t\t\t\t\t\tlog(\"remote: %s, ref: %s, value = %s\" % (i[0], i[1], newcommit))\n\n\t\t\t\t\t\tif trigger:\n\t\t\t\t\t\t\tchanged = True\n\t\t\t\t\t\tif oldrefstate != None:\n\t\t\t\t\t\t\tif i[0] in oldrefstate and i[1] in oldrefstate[i[0]]:\n\t\t\t\t\t\t\t\tif newrefstate[i[0]][i[1]] != oldrefstate[i[0]][i[1]]:\n\t\t\t\t\t\t\t\t\tchanged = True\n\n\t\t\tself.refstate = newrefstate\n\t\t\treturn changed\n\n\t\tdef cloneRefPin(self, remoterefs):\n\t\t\tfiltered = self.filterPairs(remoterefs)\n\n\t\t\tpinnedlayers = hopper.source.meta.LayerCollection(self.layers.defaultversion)\n\t\t\tfor i in self.layers:\n\t\t\t\tif isinstance(i.source, hopper.source.meta.GitSource):\n\t\t\t\t\trefname = \"refs/heads/\" + i.source.ref\n\t\t\t\t\trefpin = None\n\t\t\t\t\tif i.source.remote in filtered:\n\t\t\t\t\t\trefs = filtered[i.source.remote]\n\t\t\t\t\t\tif refname in refs:\n\t\t\t\t\t\t\trefpin = refs[refname]\n\t\t\t\t\tnewsource = hopper.source.meta.GitSource(i.source.remote, refpin)\n\t\t\t\telse:\n\t\t\t\t\tnewsource = i.source\n\t\t\t\tpinnedlayers.add(i.getFullName(), newsource)\n\t\t\treturn pinnedlayers\n\n\tdef __init__(self, environment):\n\t\tself.environment = environment\n\t\tself.stop = threading.Event()\n\t\tself.thread = None\n\t\tself.interval = 0\n\n\t\tself.lock = threading.RLock()\n\t\tself.groups = []\n\n\t\tself.changeevent = threading.Condition()\n\t\tself.changequeue = []\n\n\tdef addLayers(self, layers):\n\t\tgroup = Watcher.GroupState(layers)\n\t\tself.groups.append(group)\n\n\tdef start(self, interval = 30):\n\t\tif self.thread and self.thread.isAlive():\n\t\t\treturn\n\n\t\tself.interval = interval\n\t\tself.thread = threading.Thread(target = self.__worker__)\n\t\tself.daemon = True\n\t\tself.thread.start()\n\n\tdef stop(self):\n\t\tif self.thread and self.thread.isAlive():\n\t\t\tself.stop.set()\n\t\t\tself.thread.join()\n\n\tdef alive(self):\n\t\tif self.thread and self.thread.isAlive():\n\t\t\treturn True\n\t\treturn False\n\n\tdef trigger(self):\n\t\tself.__check__(True)\n\n\tdef __check__(self, trigger = False):\n\t\twith self.lock:\n\t\t\thaschanges = False\n\n\t\t\tremotes = []\n\t\t\tfor i in self.groups:\n\t\t\t\tfor p in i.getRefPairs():\n\t\t\t\t\tif p[0] not in remotes:\n\t\t\t\t\t\tremotes.append(p[0])\n\n\t\t\tself.environment.debug(\"need to update for the following remotes -> %s\" % remotes)\n\n\t\t\trefstate = {}\n\t\t\tfor i in remotes:\n\t\t\t\tself.environment.log(\"Grabbing refs from remote for %s\" % i)\n\t\t\t\tresult = hopper.utils.git.tasks.GitTask.run([\"ls-remote\", i], environment = self.environment)\n\t\t\t\tif result[0] == 0:\n\t\t\t\t\trefstate[i] = {}\n\t\t\t\t\tfor r in result[1].splitlines():\n\t\t\t\t\t\tparts = r.split()\n\t\t\t\t\t\trefstate[i][parts[1]] = parts[0]\n\t\t\t\t\tself.environment.debug(\"got refs -> %s\" % repr(refstate[i]))\n\t\t\t\telse:\n\t\t\t\t\tself.environment.error(\"Failed to get remote state for '%s' error message = %s\" % (i, result[1]))\n\t\t\t\t\treturn\n\n\t\t\thaschanges = False\n\t\t\tfor i in self.groups:\n\t\t\t\tif i.update(refstate, trigger):\n\t\t\t\t\tself.environment.log(\"Changes have happened since last check, pinning\")\n\t\t\t\t\tchanges = i.cloneRefPin(refstate)\n\t\t\t\t\tself.changequeue.append((i.layers, changes, datetime.datetime.utcnow()))\n\t\t\t\t\thaschanges = True\n\n\t\tif haschanges:\n\t\t\twith self.changeevent:\n\t\t\t\tself.changeevent.notifyAll()\n\n\tdef __worker__(self):\n\t\twhile not self.stop.wait(self.interval):\n\t\t\tself.__check__()\n\n\tdef wait(self):\n\t\tif self.alive():\n\t\t\tif self.hasnext():\n\t\t\t\treturn\n\n\t\t\twith self.changeevent:\n\t\t\t\tself.changeevent.wait()\n\n\tdef hasnext(self):\n\t\twith self.lock:\n\t\t\tif len(self.changequeue) != 0:\n\t\t\t\treturn True\n\t\treturn False\n\n\tdef getnext(self):\n\t\twith self.lock:\n\t\t\tif len(self.changequeue) != 0:\n\t\t\t\treturn self.changequeue.pop()\n\t\treturn None\n",
  "line_no": 15,
  "line_no_percent": "8%"
}