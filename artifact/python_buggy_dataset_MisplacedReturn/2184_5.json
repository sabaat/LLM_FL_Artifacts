{
  "instruction": "The code is a unit test for generating and loading JSON files. To use this code, create a new Python file and copy the code into it. Then, run the file to execute the unit tests. The tests will check that the generated JSON file has valid keys and values, and that an exception is raised if the file is not found. The code also includes some skipped tests that check that the keys in the JSON file only contain alphabetic characters.",
  "buggy_code": "'''\nCreated on Jul 30, 2015\n\n@author: Mikhail\n'''\nimport unittest\nimport re\nfrom json_file_generator import MyOwnJSONProcessing as json_processing\nfrom json_file_generator import __version__ as json_file_generator_version\nfrom unittest.case import skip, skipIf\n\nclass GenerateAndLoadJSONTestUpdateFour(unittest.TestCase):\n    \n    expected_data = {}\n\n    @classmethod\n    def setUpClass(cls):\n        print \"{} for {} has been called\".format(cls.setUpClass.__name__, cls.__name__)\n        cls.expected_data = json_processing.generate_data_for_json_obj()\n\n    def setUp(self):\n        print \"{} for {} has been called\".format(self.setUp.__name__, self._testMethodName)\n        self.file_name = \"generate_and_load_unittest.json\"\n        self.original_name = json_processing.generate_json_file_with_data(self.file_name, self.expected_data)\n\n    def tearDown(self):\n        print \"{} for {} has been called\".format(self.tearDown.__name__, self._testMethodName)\n\n    @classmethod\n    def tearDownClass(cls):\n        print \"{} for {} has been called\".format(cls.tearDownClass.__name__, cls.__name__)\n        json_processing.clean_up()\n\n    def testGenerateAndLoadJSONValidKeys(self):\n        return\n        print \"Processing file {}\".format(self.original_name)\n        actual_data = json_processing.load_data_from_json_file(self.original_name)\n        for exp_key in self.expected_data.keys():\n            self.assertTrue(actual_data.has_key(exp_key), \"Expected key '{}' has not been found in loaded json\".format(exp_key))\n        for act_key in actual_data.keys():\n            self.assertTrue(self.expected_data.has_key(act_key), \"Loaded key '{}' has not been found in dumped json\".format(act_key))\n    \n    @skip(\"old functionality\")\n    def testGenerateAndLoadJSONValidKeysHasOnlyLetters1(self):\n        print \"Processing file {}\".format(self.original_name)\n        actual_data = json_processing.load_data_from_json_file(self.original_name)\n        for act_key in actual_data.keys():\n            self.assertTrue(re.match(\"[^a-zA-Z]\", act_key) is None, \"Key should contains only alpha symbols: {}\".format(act_key))\n\n    @skipIf(json_file_generator_version > 1, \"This functionality is not supported in this version on the json file generator\")\n    def testGenerateAndLoadJSONValidKeysHasOnlyLetters2(self):\n        print \"Processing file {}\".format(self.original_name)\n        actual_data = json_processing.load_data_from_json_file(self.original_name)\n        for act_key in actual_data.keys():\n            self.assertIsNone(re.match(\"[^a-zA-Z]\", act_key), \"Key should contains only alpha symbols: {}\".format(act_key))\n\n    def testGenerateAndLoadJSONValidValues(self):\n        print \"Processing file {}\".format(self.original_name)\n        actual_data = json_processing.load_data_from_json_file(self.original_name)\n        for exp_key, exp_value in self.expected_data.items():\n            self.assertEquals(exp_value, actual_data.get(exp_key), \"Dictionaries have different values '{}' for first and '{}' for second for the same key\".format(exp_value, actual_data.get(exp_key)))\n        for act_key, act_value in actual_data.items():\n            self.assertEquals(act_value, self.expected_data.get(act_key), \"Dictionaries have different values '{}' for first and '{}' for second for the same key\".format(act_value, self.expected_data.get(act_key)))\n\n    def testGenerateAndLoadJSONForInvalidFile(self):\n        \"\"\"\n        This test checks that valid exception will be raised if required file will not be found\n        \"\"\"\n        invalid_name = \"invalid_\" + self.original_name\n        print \"Processing file {}\".format(invalid_name)\n        with self.assertRaises(IOError) as io_exception:\n            json_processing.load_data_from_json_file(invalid_name)\n        \n        self.assertEqual(io_exception.exception.errno, 2)\n        self.assertEqual(io_exception.exception.strerror, 'No such file or directory')\n\nif __name__ == \"__main__\":\n    unittest.main(verbosity=2)\n",
  "line_no": 35,
  "line_no_percent": "45%"
}