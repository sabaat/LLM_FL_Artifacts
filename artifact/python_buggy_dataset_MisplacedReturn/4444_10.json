{
  "instruction": "Populate additional tables/views to facilitate differential protein expression analyses based on standardized SILAC ratios. The script takes a database (SQLite) obtained from the PIQMIe service. Note that there are two columns with canonical Z-score transformed raw/normalized SILAC protein ratios and modified Z-score transformed SILAC protein ratios suitable for heavy-tailed data (Iglewicz and Hoaglin, 1993). The script requires command-line arguments: '-n' to populate new db tables with (modified) Z-scores, '-d' to select one of the data sets or cell lines, '-s' to select one of the score types for filtering: Z*,M* - Z-score or modified Z-score; *r,*n - score based on raw or normalized SILAC protein ratios, '-c' to set the absolute score cutoff (e.g. 1.65, 1.96 or 2.58), and 'dbfile' to specify the sqlite3 database file. The script outputs the results onto a tab-delim file specified by '-o' or a default output filename.",
  "buggy_code": "import os\nimport sys\nimport argparse as argp\nimport math\nimport numpy as np\nimport scipy.stats as st\nimport sqlite3 as sqlt\nimport collections as cls\n\nratio_types = { # lookup to link column values to column names\n    'RATIO H/L': 'raw_ratio_HL',\n    'RATIO H/M': 'raw_ratio_HM',\n    'RATIO M/L': 'raw_ratio_ML',\n    'RATIO H/L NORMALIZED': 'norm_ratio_HL',\n    'RATIO H/M NORMALIZED': 'norm_ratio_HM',\n    'RATIO M/L NORMALIZED': 'norm_ratio_ML'\n}\n\nscore_types = { # lookup to link user input to table column\n    'Zr' : 'z_score_raw_ratio',\n    'Zn' : 'z_score_norm_ratio',\n    'Mr' : 'm_score_raw_ratio',\n    'Mn' : 'm_score_norm_ratio'\n}\n\nparser = argp.ArgumentParser(\n   description = 'Differential analysis of SILAC protein ratios based on standardized scores.')\n\nparser.add_argument(\n   '-n',\n   action = 'store_true',\n   dest = 'new_tabs',\n   help = 'populate new db tables with (modified) Z-scores')\n\nparser.add_argument(\n   '-d',\n   dest = 'dts',\n   required = True,\n   choices = ['VH10', 'U2OS', 'IB10'],\n   help = 'select one of the data sets or cell lines')\n\nparser.add_argument(\n   '-s',\n   required = True,\n   choices = score_types.keys(),\n   help = 'select one of the score types for filtering: Z*,M* - Z-score or modified Z-score; *r,*n - score based on raw or normalized SILAC protein ratios')\n\nparser.add_argument(\n   '-c',\n   required = True,\n   dest = 'cutoff',\n   type = float,\n   help = 'absolute score cutoff (e.g. 1.65, 1.96 or 2.58)')\n\nparser.add_argument(\n   '-o',\n   dest = 'outfile',\n   help = 'output file')\n\nparser.add_argument(\n   'dbfile',\n   help = 'sqlite3 database file')\n\nargs = parser.parse_args()\n\ndbfile = args.dbfile\noutfile = args.outfile\nnew_tabs = args.new_tabs\ndts = args.dts\nstype = args.s\ncutoff = args.cutoff\nscore_type = None\n\nif os.path.isfile(dbfile) is False:\n   parser.error(\"dbfile '%s' not found\" % dbfile)\n\nif stype and cutoff:\n   score_type = score_types[stype]\nelse:\n   parser.error('-s and -c args must be used together')\n\nif outfile is None:\n   outfile = os.path.join(os.path.dirname(dbfile), '%s_mzscore_%s_%.2f.tab' % (dts, stype, cutoff))\n\nif cutoff < 0:\n   parser.error('the absolute score cutoff must be a positive value')\n\nprint \"\"\"\ndbfile = %s\noutfile = %s\ndataset = %s\nre-score = %s\nscore type = %s\nscore cutoff = %.2f\n\"\"\" % (dbfile, outfile, dts, new_tabs, stype, cutoff)\n\ndef log(value, base):\n    try:\n        return math.log(value) / math.log(base)\n    except:\n        return None\n\ndef sqrt(value):\n    try:\n        return math.sqrt(value)\n    except:\n        return None\n\ndef pvalue(score): # convert Z- or M-score to two-tailed probability (P-value)\n    try:\n        return 2 * st.norm.cdf(-abs(score))\n    except:\n        return None\n\nclass Stdev: # sample standard deviation (aggregate function)\n    def __init__(self):\n        self.vec = []\n\n    def step(self, value):\n        self.vec.append(value)\n\n    def finalize(self):\n        return np.array(self.vec).std(ddof=1)\n\nclass Median: # median (aggregate function)\n    def __init__(self):\n        self.arr = []\n\n    def step(self, value):\n        self.arr.append(value)\n\n    def finalize(self):\n        return np.median(np.array(self.arr))\n\nclass Mad: # median absolute deviation (aggregate function)\n    def __init__(self):\n        return\n        self.arr = []\n\n    def step(self, value):\n        self.arr.append(value)\n\n    def finalize(self):\n        median = np.median(np.array(self.arr))\n        return np.median(np.abs(self.arr - median))\n\nsql_create_tables = \"\"\"\nDROP VIEW IF EXISTS V_PGROUP_RATIO;\nCREATE VIEW V_PGROUP_RATIO AS\n-- simplifies the selection of SILAC ratios/types\nSELECT\n    A.grp_id,\n    exp_name,\n    CAST(CASE %s\n    END AS TEXT) AS ratio_type,\n    CAST(quant_value AS NUMERIC) AS ratio_value\nFROM\n    PGROUP_QUANT A, V_PGROUP B\nWHERE\n    A.grp_id = B.grp_id\n    AND quant_type IN ('%s')\n    AND quant_value;\n\nDROP TABLE IF EXISTS PGROUP_LOG2RATIO_STAT;\nCREATE TABLE PGROUP_LOG2RATIO_STAT AS\n-- stores descriptive statistics on SILAC protein ratios for each experiment\nSELECT\n    exp_name,\n    ratio_type,\n    CAST(COUNT(ratio_value) AS INT) AS n,\n    CAST(MIN(LOG(ratio_value, 2)) AS NUMERIC) AS min,\n    CAST(MAX(LOG(ratio_value, 2)) AS NUMERIC) AS max,\n    CAST(AVG(LOG(ratio_value, 2)) AS NUMERIC) AS mean,\n    CAST(MEDIAN(LOG(ratio_value, 2)) AS NUMERIC) AS median,\n    CAST(STDEV(LOG(ratio_value, 2)) AS NUMERIC) AS sd,\n    CAST(MAD(LOG(ratio_value, 2)) AS NUMERIC) AS mad\nFROM\n    V_PGROUP_RATIO\nGROUP BY\n    exp_name, ratio_type;\nCREATE INDEX idx_PGROUP_LOG2RATIO_STAT_exp_name_ratio_type ON PGROUP_LOG2RATIO_STAT(exp_name, ratio_type);\n\nDROP VIEW IF EXISTS V_PGROUP_LOG2RATIO_STAT;\nCREATE VIEW V_PGROUP_LOG2RATIO_STAT AS\n-- shows rounded values of the statistics\nSELECT\n    exp_name,\n    ratio_type,\n    n,\n    ROUND(min, 4) AS min,\n    ROUND(max, 4) AS max,\n    ROUND(mean, 4) AS mean,\n    ROUND(median, 4) AS median,\n    ROUND(sd, 4) AS sd,\n    ROUND(mad, 4) AS mad\nFROM\n    PGROUP_LOG2RATIO_STAT;\n\nDROP TABLE IF EXISTS PGROUP_MZSCORE;\nCREATE TABLE PGROUP_MZSCORE AS\n-- stores (modified) Z-score transformed SILAC protein raw/norm ratios\nSELECT\n    grp_id,\n    A.exp_name AS exp_name,\n    CAST(A.ratio_type AS TEXT) AS ratio_type,\n    CAST((LOG(ratio_value, 2) - mean) / sd AS NUMERIC) AS z_score,\n    CAST(0.6745 * (LOG(ratio_value, 2) - median) / mad AS NUMERIC) AS m_score\nFROM\n    V_PGROUP_RATIO A, PGROUP_LOG2RATIO_STAT B\nWHERE\n    A.exp_name = B.exp_name\n    AND A.ratio_type = B.ratio_type;\nCREATE INDEX idx_PGROUP_MZSCORE_grp_id ON PGROUP_MZSCORE(grp_id);\nCREATE INDEX idx_PGROUP_MZSCORE_exp_name_ratio_type ON PGROUP_MZSCORE(exp_name, ratio_type);\n\"\"\" % (' '.join([ \"\\n\\tWHEN quant_type='%s' THEN '%s'\" % (k, v) for (k, v) in ratio_types.iteritems() ]),\n       \"','\".join(ratio_types.keys()))\n\nsql_sel_pgrps = \"\"\"\nSELECT\n    A.grp_id grp_id,\n    IFNULL(GROUP_CONCAT(DISTINCT gene), '-') genes,\n    {dts}_L0_M0_H1_{score_type}_HL '{stype}_H1L0', -- Z or M-score ON/OFF  (treat1)\n    {dts}_L1_M1_H0_{score_type}_LH '{stype}_L1H0', -- Z or M-score ON/OFF  (treat2)\n    {dts}_L0_M0_H1_{score_type}_HM '{stype}_H1M0', -- Z or M-score ON/OFF  (treat3)\n    {dts}_L1_M1_H0_{score_type}_MH '{stype}_M1H0', -- Z or M-score ON/OFF  (treat4)\n    {dts}_L0_M0_H1_{score_type}_LM '{stype}_L0M0', -- Z or M-score OFF/OFF (ctrl1)\n    {dts}_L1_M1_H0_{score_type}_LM '{stype}_L1M1', -- Z or M-score ON/ON   (ctrl2)\n    PVALUE({dts}_L0_M0_H1_{score_type}_HL) 'pval_H1L0', -- P-value ON/OFF  (treat1)\n    PVALUE({dts}_L1_M1_H0_{score_type}_LH) 'pval_L1H0', -- P-value ON/OFF  (treat2)\n    PVALUE({dts}_L0_M0_H1_{score_type}_HM) 'pval_H1M0', -- P-value ON/OFF  (treat3)\n    PVALUE({dts}_L1_M1_H0_{score_type}_MH) 'pval_M1H0', -- P-value ON/OFF  (treat4)\n    PVALUE({dts}_L0_M0_H1_{score_type}_LM) 'pval_L0M0', -- P-value OFF/OFF (ctrl1)\n    PVALUE({dts}_L1_M1_H0_{score_type}_LM) 'pval_L1M1'  -- P-value ON/ON   (ctrl2)\nFROM\n    V_PGROUP_MZSCORE A, PROT2GRP B, V_PROTEIN C\nWHERE\n    A.grp_id = B.grp_id\n    AND B.prot_acc = C.acc\n    AND (({dts}_L0_M0_H1_{score_type}_HL > {cutoff}\n    AND {dts}_L0_M0_H1_{score_type}_HM > {cutoff}\n    AND {dts}_L1_M1_H0_{score_type}_LH > {cutoff}\n    AND {dts}_L1_M1_H0_{score_type}_MH > {cutoff})\n    OR ({dts}_L0_M0_H1_{score_type}_LH > {cutoff}\n    AND {dts}_L0_M0_H1_{score_type}_MH > {cutoff}\n    AND {dts}_L1_M1_H0_{score_type}_HL > {cutoff}\n    AND {dts}_L1_M1_H0_{score_type}_HM > {cutoff}))\n    AND {dts}_L0_M0_H1_{score_type}_ML <= {cutoff}\n    AND {dts}_L0_M0_H1_{score_type}_LM <= {cutoff}\n    AND {dts}_L1_M1_H0_{score_type}_ML <= {cutoff}\n    AND {dts}_L1_M1_H0_{score_type}_LM <= {cutoff}\nGROUP BY A.grp_id;\n\"\"\".format(dts=dts, score_type=score_type, stype=stype, cutoff=cutoff)\n\nwith sqlt.connect(args.dbfile) as conn:\n   conn.row_factory = sqlt.Row # enable column access by name: row['colnm']\n   conn.create_function('log', 2, log)\n   conn.create_function('sqrt', 1, sqrt)\n   conn.create_function('pvalue', 1, pvalue)\n   conn.create_aggregate('stdev', 1, Stdev)\n   conn.create_aggregate('median', 1, Median)\n   conn.create_aggregate('mad', 1, Mad)\n   cur = conn.cursor()\n\n   if new_tabs is True: # populate tables/views only with -n option\n      cur.executescript(sql_create_tables)\n      cur.execute('SELECT DISTINCT exp_name FROM EXPERIMENT')\n      exp_names = [ str(r[0]) for r in cur.fetchall() ]\n      cur.execute(\"SELECT DISTINCT ratio_type FROM PGROUP_LOG2RATIO_STAT\")\n      ratio_types = [ str(r[0]) for r in cur.fetchall() ]\n      n = len(exp_names) * len(ratio_types)\n      i = 0\n      comma = ','\n\n      sql_create_view = \"\"\"\nDROP VIEW IF EXISTS V_PGROUP_MZSCORE;\nCREATE VIEW V_PGROUP_MZSCORE AS\nSELECT\n    grp_id,\n\"\"\"\n      for e in exp_names:\n         for r in ratio_types:\n            i += 1\n            rr = r[:-2] + r[-2:][::-1] # add inverse ratio (e.g., {raw|norm}_ratio_HL for *_ratio_LH)\n            if i == n: comma = ''\n            sql_create_view += \"\\tROUND(CAST(GROUP_CONCAT(CASE WHEN exp_name = '{exp}' AND ratio_type = '{ratio}' THEN z_score ELSE NULL END) AS NUMERIC), 4) AS '{exp}_z_score_{ratio}',\\n\".format(exp=e, ratio=r)\n            sql_create_view += \"\\tROUND(CAST(GROUP_CONCAT(CASE WHEN exp_name = '{exp}' AND ratio_type = '{ratio}' THEN -1 * z_score ELSE NULL END) AS NUMERIC), 4) AS '{exp}_z_score_{iratio}',\\n\".format(exp=e, ratio=r, iratio=rr)\n            sql_create_view += \"\\tROUND(CAST(GROUP_CONCAT(CASE WHEN exp_name = '{exp}' AND ratio_type = '{ratio}' THEN m_score ELSE NULL END) AS NUMERIC), 4) AS '{exp}_m_score_{ratio}',\\n\".format(exp=e, ratio=r)\n            sql_create_view += \"\\tROUND(CAST(GROUP_CONCAT(CASE WHEN exp_name = '{exp}' AND ratio_type = '{ratio}' THEN -1 * m_score ELSE NULL END) AS NUMERIC), 4) AS '{exp}_m_score_{iratio}'{comma}\\n\".format(exp=e, ratio=r, iratio=rr, comma=comma)\n      sql_create_view += \"FROM PGROUP_MZSCORE GROUP BY grp_id\"\n      cur.executescript(sql_create_view)\n   \n   if dts is not None:\n      sep = '\\t' # column separator\n      n_pgrps = 0 # count diff. reg. protein groups\n      with open(outfile, 'w+') as fout:\n         try:\n            for drow in [ cls.OrderedDict(xi) for xi in cur.execute(sql_sel_pgrps) ]:\n               if n_pgrps == 0:\n                  header = sep.join(drow.keys()) + os.linesep\n                  fout.write(header)\n\n               row = drow.values()\n               grp_id = str(drow['grp_id'])\n               genes = str(drow['genes'])\n               scores = [ str(round(float(x), 4)) for x in row[2:] ]\n               srow = grp_id + sep + genes + sep + sep.join(scores) + os.linesep\n               fout.write(srow)\n               n_pgrps += 1\n\n         except sqlt.OperationalError as e:\n            sys.stderr.write('Error: Selected data set not found: %s\\n' % e)\n            sys.exit(1)\n\n      if os.path.getsize(outfile) == 0:\n         print 'Nothing to write onto outfile.'\n         os.remove(outfile)\n      else:\n         print 'Ndiff =', n_pgrps\n",
  "line_no": 137,
  "line_no_percent": "43%"
}