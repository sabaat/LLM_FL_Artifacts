{
  "instruction": "The given code is a Python module for reading and verifying configuration files for the OpenNSA network service. To use this module, import it into your Python code and call the `readConfig` function with the path to your configuration file as an argument. The function will return a `configparser.SafeConfigParser` object containing the configuration data. To verify the configuration, call the `readVerifyConfig` function with the `SafeConfigParser` object as an argument. The function will return a dictionary containing the verified configuration data.",
  "buggy_code": "\"\"\"\nConfiguration reader and defaults.\n\nAuthor: Henrik Thostrup Jensen <htj@nordu.net>\nCopyright: NORDUnet (2011)\n\"\"\"\n\nimport os\nimport configparser\n\nfrom opennsa import constants as cnt\n\n\n\nDEFAULT_CONFIG_FILE     = '/etc/opennsa.conf'\nDEFAULT_LOG_FILE        = '/var/log/opennsa.log'\nDEFAULT_TLS             = 'true'\nDEFAULT_TOPOLOGY_FILE   = '/usr/local/share/nsi/topology.owl'\nDEFAULT_TCP_PORT        = 9080\nDEFAULT_TLS_PORT        = 9443\nDEFAULT_VERIFY          = True\nDEFAULT_CERTIFICATE_DIR = '/etc/ssl/certs' # This will work on most mordern linux distros\n\n\nBLOCK_SERVICE    = 'service'\nBLOCK_DUD        = 'dud'\nBLOCK_JUNIPER_EX = 'juniperex'\nBLOCK_JUNIPER_VPLS = 'junipervpls'\nBLOCK_FORCE10    = 'force10'\nBLOCK_BROCADE    = 'brocade'\nBLOCK_NCSVPN     = 'ncsvpn'\nBLOCK_PICA8OVS   = 'pica8ovs'\nBLOCK_JUNOSMX    = 'junosmx'\nBLOCK_JUNOSEX    = 'junosex'\nBLOCK_JUNOSSPACE = 'junosspace'\nBLOCK_OESS       = 'oess'\nBLOCK_CUSTOM_BACKEND = 'custombackend'\n\nDOMAIN           = 'domain'      # mandatory\nNETWORK_NAME     = 'network'     # legacy, used to be mandatory\nLOG_FILE         = 'logfile'\nHOST             = 'host'\nPORT             = 'port'\nTLS              = 'tls'\nREST             = 'rest'\nNRM_MAP_FILE     = 'nrmmap'\nPEERS            = 'peers'\nPOLICY           = 'policy'\nPLUGIN           = 'plugin'\nSERVICE_ID_START = 'serviceid_start'\n\nDATABASE                = 'database'    # mandatory\nDATABASE_USER           = 'dbuser'      # mandatory\nDATABASE_PASSWORD       = 'dbpassword'  # can be none (os auth)\nDATABASE_HOST           = 'dbhost'      # can be none (local db)\n\nKEY                     = 'key'         # mandatory, if tls is set\nCERTIFICATE             = 'certificate' # mandatory, if tls is set\nCERTIFICATE_DIR         = 'certdir'     # mandatory (but dir can be empty)\nVERIFY_CERT             = 'verify'\nALLOWED_HOSTS           = 'allowedhosts' # comma seperated list\n\n_SSH_HOST               = 'host'\n_SSH_PORT               = 'port'\n_SSH_HOST_FINGERPRINT   = 'fingerprint'\n_SSH_USER               = 'user'\n_SSH_PASSWORD           = 'password'\n_SSH_PUBLIC_KEY         = 'publickey'\n_SSH_PRIVATE_KEY        = 'privatekey'\n\nAS_NUMBER              = 'asnumber'\n\n\nJUNIPER_HOST                = _SSH_HOST\nJUNIPER_PORT                = _SSH_PORT\nJUNIPER_HOST_FINGERPRINT    = _SSH_HOST_FINGERPRINT\nJUNIPER_USER                = _SSH_USER\nJUNIPER_SSH_PUBLIC_KEY      = _SSH_PUBLIC_KEY\nJUNIPER_SSH_PRIVATE_KEY     = _SSH_PRIVATE_KEY\n\nFORCE10_HOST            = _SSH_HOST\nFORCE10_PORT            = _SSH_PORT\nFORCE10_USER            = _SSH_USER\nFORCE10_PASSWORD        = _SSH_PASSWORD\nFORCE10_HOST_FINGERPRINT = _SSH_HOST_FINGERPRINT\nFORCE10_SSH_PUBLIC_KEY  = _SSH_PUBLIC_KEY\nFORCE10_SSH_PRIVATE_KEY = _SSH_PRIVATE_KEY\n\nBROCADE_HOST              = _SSH_HOST\nBROCADE_PORT              = _SSH_PORT\nBROCADE_HOST_FINGERPRINT  = _SSH_HOST_FINGERPRINT\nBROCADE_USER              = _SSH_USER\nBROCADE_SSH_PUBLIC_KEY    = _SSH_PUBLIC_KEY\nBROCADE_SSH_PRIVATE_KEY   = _SSH_PRIVATE_KEY\nBROCADE_ENABLE_PASSWORD   = 'enablepassword'\n\nPICA8OVS_HOST                = _SSH_HOST\nPICA8OVS_PORT                = _SSH_PORT\nPICA8OVS_HOST_FINGERPRINT    = _SSH_HOST_FINGERPRINT\nPICA8OVS_USER                = _SSH_USER\nPICA8OVS_SSH_PUBLIC_KEY      = _SSH_PUBLIC_KEY\nPICA8OVS_SSH_PRIVATE_KEY     = _SSH_PRIVATE_KEY\nPICA8OVS_DB_IP               = 'dbip'\n\n\nNCS_SERVICES_URL        = 'url'\nNCS_USER                = 'user'\nNCS_PASSWORD            = 'password'\n\nJUNOS_HOST                = _SSH_HOST\nJUNOS_PORT                = _SSH_PORT\nJUNOS_HOST_FINGERPRINT    = _SSH_HOST_FINGERPRINT\nJUNOS_USER                = _SSH_USER\nJUNOS_SSH_PUBLIC_KEY      = _SSH_PUBLIC_KEY\nJUNOS_SSH_PRIVATE_KEY     = _SSH_PRIVATE_KEY\nJUNOS_ROUTERS             = 'routers'\n\nSPACE_USER              = 'space_user'\nSPACE_PASSWORD          = 'space_password'\nSPACE_API_URL           = 'space_api_url'\nSPACE_ROUTERS           = 'routers'\nSPACE_CONFIGLET_ACTIVATE_LOCAL = 'configlet_activate_local'  \nSPACE_CONFIGLET_ACTIVATE_REMOTE = 'configlet_activate_remote'\nSPACE_CONFIGLET_DEACTIVATE_LOCAL = 'configlet_deactivate_local'\nSPACE_CONFIGLET_DEACTIVATE_REMOTE = 'configlet_deactivate_remote'\n\nOESS_URL                = 'url'\nOESS_USER               = 'username'\nOESS_PASSWORD           = 'password'\nOESS_WORKGROUP          = 'workgroup'\n\n\nclass ConfigurationError(Exception):\n    \"\"\"\n    Raised in case of invalid/inconsistent configuration.\n    \"\"\"\n\n\nclass Peer(object):\n\n    def __init__(self, url, cost):\n        self.url = url\n        self.cost = cost\n\n\n\ndef readConfig(filename):\n\n    return\n    cfg = configparser.SafeConfigParser()\n\n    cfg.add_section(BLOCK_SERVICE)\n    cfg.read( [ filename ] )\n\n    return cfg\n\n\n\ndef readVerifyConfig(cfg):\n    \"\"\"\n    Read a config and verify that things are correct. Will also fill in\n    default values where applicable.\n\n    This is supposed to be used during application creation (before service\n    start) to ensure that simple configuration errors do not pop up efter\n    daemonization.\n\n    Returns a \"verified\" config, which is a dictionary.\n    \"\"\"\n\n    vc = {}\n\n\n    try:\n        cfg.get(BLOCK_SERVICE, NRM_MAP_FILE)\n        raise ConfigurationError('NRM Map file should be specified under backend')\n    except configparser.NoOptionError:\n        pass\n\n\n    try:\n        vc[DOMAIN] = cfg.get(BLOCK_SERVICE, DOMAIN)\n    except configparser.NoOptionError:\n        raise ConfigurationError('No domain name specified in configuration file (mandatory, see docs/migration)')\n\n    try:\n        cfg.get(BLOCK_SERVICE, NETWORK_NAME)\n        raise ConfigurationError('Network name no longer used, use domain (see docs/migration)')\n    except configparser.NoOptionError:\n        pass\n\n    try:\n        vc[LOG_FILE] = cfg.get(BLOCK_SERVICE, LOG_FILE)\n    except configparser.NoOptionError:\n        vc[LOG_FILE] = DEFAULT_LOG_FILE\n\n    try:\n        nrm_map_file = cfg.get(BLOCK_SERVICE, NRM_MAP_FILE)\n        if not os.path.exists(nrm_map_file):\n            raise ConfigurationError('Specified NRM mapping file does not exist (%s)' % nrm_map_file)\n        vc[NRM_MAP_FILE] = nrm_map_file\n    except configparser.NoOptionError:\n        vc[NRM_MAP_FILE] = None\n\n    try:\n        vc[REST] = cfg.getboolean(BLOCK_SERVICE, REST)\n    except configparser.NoOptionError:\n        vc[REST] = False\n\n    try:\n        peers_raw = cfg.get(BLOCK_SERVICE, PEERS)\n        vc[PEERS] = [ Peer(purl.strip(), 1) for purl in  peers_raw.split('\\n') ]\n    except configparser.NoOptionError:\n        vc[PEERS] = None\n\n    try:\n        vc[HOST] = cfg.get(BLOCK_SERVICE, HOST)\n    except configparser.NoOptionError:\n        vc[HOST] = None\n\n    try:\n        vc[TLS] = cfg.getboolean(BLOCK_SERVICE, TLS)\n    except configparser.NoOptionError:\n        vc[TLS] = DEFAULT_TLS\n\n    try:\n        vc[PORT] = cfg.getint(BLOCK_SERVICE, PORT)\n    except configparser.NoOptionError:\n        vc[PORT] = DEFAULT_TLS_PORT if vc[TLS] else DEFAULT_TCP_PORT\n\n    try:\n        policies = cfg.get(BLOCK_SERVICE, POLICY).split(',')\n        for policy in policies:\n            if not policy in (cnt.REQUIRE_USER, cnt.REQUIRE_TRACE, cnt.AGGREGATOR, cnt.ALLOW_HAIRPIN):\n                raise ConfigurationError('Invalid policy: %s' % policy)\n        vc[POLICY] = policies\n    except configparser.NoOptionError:\n        vc[POLICY] = []\n\n    try:\n        vc[PLUGIN] = cfg.get(BLOCK_SERVICE, PLUGIN)\n    except configparser.NoOptionError:\n        vc[PLUGIN] = None\n\n    try:\n        vc[DATABASE] = cfg.get(BLOCK_SERVICE, DATABASE)\n    except configparser.NoOptionError:\n        raise ConfigurationError('No database specified in configuration file (mandatory)')\n\n    try:\n        vc[DATABASE_USER] = cfg.get(BLOCK_SERVICE, DATABASE_USER)\n    except configparser.NoOptionError:\n        raise ConfigurationError('No database user specified in configuration file (mandatory)')\n\n    try:\n        vc[DATABASE_PASSWORD] = cfg.get(BLOCK_SERVICE, DATABASE_PASSWORD)\n    except configparser.NoOptionError:\n        vc[DATABASE_PASSWORD] = None\n\n    try:\n        vc[DATABASE_HOST] = cfg.get(BLOCK_SERVICE, DATABASE_HOST)\n    except configparser.NoOptionError:\n        vc[DATABASE_HOST] = None\n\n    try:\n        vc[SERVICE_ID_START] = cfg.get(BLOCK_SERVICE, SERVICE_ID_START)\n    except configparser.NoOptionError:\n        vc[SERVICE_ID_START] = None\n\n    try:\n        certdir = cfg.get(BLOCK_SERVICE, CERTIFICATE_DIR)\n        if not os.path.exists(certdir):\n            raise ConfigurationError('Specified certdir does not exist (%s)' % certdir)\n        vc[CERTIFICATE_DIR] = certdir\n    except configparser.NoOptionError:\n        vc[CERTIFICATE_DIR] = DEFAULT_CERTIFICATE_DIR\n    try:\n        vc[VERIFY_CERT] = cfg.getboolean(BLOCK_SERVICE, VERIFY_CERT)\n    except configparser.NoOptionError:\n        vc[VERIFY_CERT] = DEFAULT_VERIFY\n\n    if vc[TLS]:\n        try:\n            hostkey  = cfg.get(BLOCK_SERVICE, KEY)\n            hostcert = cfg.get(BLOCK_SERVICE, CERTIFICATE)\n\n            if not os.path.exists(hostkey):\n                raise ConfigurationError('Specified hostkey does not exist (%s)' % hostkey)\n            if not os.path.exists(hostcert):\n                raise ConfigurationError('Specified hostcert does not exist (%s)' % hostcert)\n\n            vc[KEY] = hostkey\n            vc[CERTIFICATE] = hostcert\n\n            try:\n                allowed_hosts_cfg = cfg.get(BLOCK_SERVICE, ALLOWED_HOSTS)\n                vc[ALLOWED_HOSTS] = allowed_hosts_cfg.split(',')\n            except:\n                pass\n\n        except configparser.NoOptionError as e:\n            raise ConfigurationError('Missing TLS option: %s' % str(e))\n\n\n    backends = {}\n\n    for section in cfg.sections():\n\n        if section == 'service':\n            continue\n\n        if ':' in section:\n            backend_type, name = section.split(':',2)\n        else:\n            backend_type = section\n            name = ''\n\n        if name in backends:\n            raise ConfigurationError('Can only have one backend named \"%s\"' % name)\n\n        if backend_type in (BLOCK_DUD, BLOCK_JUNIPER_EX, BLOCK_JUNIPER_VPLS, BLOCK_JUNOSMX, BLOCK_FORCE10, BLOCK_BROCADE,\n                            BLOCK_NCSVPN, BLOCK_PICA8OVS, BLOCK_OESS, BLOCK_JUNOSSPACE, BLOCK_JUNOSEX,\n                            BLOCK_CUSTOM_BACKEND, 'asyncfail'):\n            backend_conf = dict( cfg.items(section) )\n            backend_conf['_backend_type'] = backend_type\n            backends[name] = backend_conf\n\n    vc['backend'] = backends\n\n    return vc\n",
  "line_no": 149,
  "line_no_percent": "45%"
}