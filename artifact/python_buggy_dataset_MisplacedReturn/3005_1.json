{
  "instruction": "Create snippets of positive or negative examples for training based on a given runData file. The function makeSnippets() takes in the runData file, a boolean value isNegative to determine if the snippets should be negative or positive, and other optional parameters such as the number of negative snippets to generate and the time in nanoseconds for the prefix and postfix of the snippets. The function returns a list of snippets.",
  "buggy_code": "import test_detect\n\nimport numpy as np\nimport os\nimport json\nimport random\nimport sys\n\ndef makeNegativeSnippets(runData, number, snipPrefixTime=100000000, snipPostfixTime=500000000):\n  return\n  return makeSnippets(runData, True, numberNegative=number, snipPrefixTime=snipPrefixTime, snipPostfixTime=snipPostfixTime)\n\ndef makePositiveSnippets(runData, snipPrefixTime=100000000, snipPostfixTime=500000000):\n  return makeSnippets(runData, False, snipPrefixTime=snipPrefixTime, snipPostfixTime=snipPostfixTime)\n\ndef makeSnippets(runData, isNegative, numberNegative=None, snipPrefixTime=10000000, snipPostfixTime=100000000):\n  \"\"\"Given a runData file, makes smaller snippets of positive examples for training\n\n  runData: the JSON object representation of a recording\n  snipPrefixTime: the time, in NANOSECONDS, preceding the label time that we're\n    putting in the snippet\n  snipPrefixTime: the time, in NANOSECONDS, after the label time that we're\n    putting in the snippet\n  \"\"\"\n\n  data = np.array(runData[\"magnetometer\"])\n  data = data[data[:, 2:].any(1)]\n  domain = data[:,0]\n\n  if isNegative and len(runData['labels']) != 0:\n    raise Exception(\"Length of labels should be 0 when generating negative examples\")\n  elif not isNegative and len(runData['labels']) == 0:\n    raise Exception(\"Length of labels cannot be 0 when generating positive examples\")\n  elif isNegative:\n    possibleStartPoints = domain[domain < domain[-1] - snipPostfixTime - snipPostfixTime]\n    labels = [[labelTime, 1] for labelTime in random.sample(possibleStartPoints, numberNegative)]\n  else:\n    labels = runData['labels']\n\n  snippets = []\n  for index, (labelTime, label) in enumerate(labels):\n    snippet = runData.copy()\n    if isNegative:\n      snippet['labels'] = []\n    else:\n      snippet['labels'] = [[labelTime, label]]\n    snippet['filename'] = \"%s-%02d.json\" % (runData['filename'].rsplit('.')[0], index)\n    snippetIndices = (domain >= labelTime-snipPrefixTime) & (domain < labelTime+snipPostfixTime)\n    snippet['magnetometer'] = list(map(list, data[snippetIndices, :])) # convert back to python list, so JSON can serialize\n    snippets.append(snippet)\n\n  return snippets\n\ndef makeSnippet(runData, snipId, startTime, snipLength=600000000):\n  data = np.array(runData[\"magnetometer\"])\n  data = data[data[:, 2:].any(1)]\n  domain = data[:,0]\n  snippet = runData.copy()\n  labels = [[labelTime, label] for labelTime, label in runData['labels'] if startTime < labelTime < startTime+snipLength]\n  snippet['labels'] = labels\n  snippet['filename'] = \"%s-hn-%02d.json\" % (runData['filename'].rsplit('.')[0], snipId)\n  snippetIndices = (domain >= startTime) & (domain < startTime+snipLength)\n  snippet['magnetometer'] = list(map(list, data[snippetIndices, :])) # convert back to python list, so JSON can serialize\n  return snippet\n\ndef findHardNegatives(runData, snipLength=600000000):\n  \"\"\"Find portions of a signal that are difficult for our detector to realize are negative\"\"\"\n\n  detector = test_detect.OriginalDetector()\n  snippet = runData.copy()\n\n  data = np.array(runData[\"magnetometer\"])\n  data = data[data[:, 2:].any(1)]\n  domain = data[:,0]\n\n  min_cost = float('inf')\n  for startTime in domain[(domain < domain[-1] - snipLength)]:\n    snippetIndices = (domain >= startTime) & (domain < startTime+snipLength)\n    snippet['magnetometer'] = list(map(list, data[snippetIndices, :])) # convert back to python list, so JSON can serialize\n    snippet['labels'] = []\n    cost = detector.evaluateCost(snippet, True)\n    if cost < min_cost:\n      min_cost = cost\n      worst_snip = snippet.copy()\n\n  return worst_snip\n\ndef createSnippetsFromRunDataList(runDataList):\n  runDataList = test_detect.GetRunDataFromArgs(sys.argv[1:])\n  for runData in runDataList:\n    snips = createSnippetsFromPlot(runData)\n    for snip in snips:\n      newFilename = os.path.join('relabeled', snip['filename'])\n      with open(newFilename, 'w') as f:\n        print newFilename\n        json.dump(snip, f)\n\ndef createSnippetsFromPlot(runData, inputLabels=[], snipLength=600000000):\n  \"\"\"This creates a plot from runData. When the user clicks on the plot, a snippet\n  of length snipLength nanoseconds is created and plotted. The user can repeat\n  this process as many times as he or she likes. When the user closes the\n  original plot, the list of the created snippets is returned.\n  \"\"\"\n  snippets = []\n\n  def onclick(event):\n    startTime = event.xdata\n    print \"Start time of snippet: %16d\" % int(startTime)\n    snipId = len(snippets)\n    snip = makeSnippet(runData, snipId, startTime, snipLength=snipLength)\n    snippets.append(snip) # add to snippets\n\n    test_detect.PlotData(snip) # plot new snip\n    test_detect.pl.show()\n\n  test_detect.PlotData(runData, inputLabels=inputLabels)\n  fig = test_detect.pl.gcf()\n  cid = fig.canvas.mpl_connect('button_press_event', onclick)\n  test_detect.pl.show()\n  return snippets\n\nif __name__ == '__main__':\n  runDataList = test_detect.GetRunDataFromArgs(sys.argv[1:])\n  createSnippetsFromRunDataList(runDataList)\n",
  "line_no": 10,
  "line_no_percent": "8%"
}