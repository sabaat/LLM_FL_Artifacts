{
  "instruction": "This code provides a CLI parser module that is responsible for parsing command models defined in cliCommands.yaml and providing functions for validation of user-input, invoking execution handle for CLI commands or macro expansions, and determining possible arg match for command auto-completion based on context. To use the module, instantiate the CLIUtil class and call its methods, such as get_match() to get a list of possible matches for a given command context, and validate_command_and_execute() to validate and execute a full command context. The module also includes methods for printing the command graph and results.",
  "buggy_code": "'''\n@author : rgiyer\nDate    : October 20th, 2014\n\nThis module is responsible for parsing command model defined in\ncliCommands.yaml and providing functions for:\n       - Validation of user-input\n       - invoking execution handle for CLI commands or macro expansions\n       - determine possible arg match for command auto-completion based \n         on context\n'''\n\nimport os\nimport re\nimport inspect\nimport subprocess\n\nimport yaml\n\nimport util\n\nfrom cli_handle_impl import CLIImplementor\n\nclass CLICommand:\n\n    def __init__ ( self, cmd_access, cmd_handle, cmd_macro, cmd_desc ):\n        self.cmd_access = cmd_access\n        self.cmd_handle = cmd_handle\n        self.cmd_macro  = cmd_macro\n        self.cmd_desc   = cmd_desc\n\n\nclass CLIUtil:\n\n    def __init__ ( self ):\n        commandConfFile = os.path.join ( util.configLocation, \n                                         'cliCommands.yaml' )\n        self.yaml_file_stream = open ( commandConfFile, 'r' )\n        raw_graph = yaml.load ( self.yaml_file_stream )\n        self.cmd_graph = {}\n        self.indentation = 8\n        self.dump_cmd ( raw_graph )\n        self.yaml_file_stream.close ()\n        \n\n    def get_implementor_handle ( self, class_instance, handle_name ):\n        handles = inspect.getmembers ( class_instance, \n                                       predicate = inspect.ismethod )\n        for function_tuple in handles:\n            if ( handle_name == function_tuple [ 0 ] ):\n                return function_tuple [ 1 ]\n\n        return 0\n\n    def dump_cmd ( self,\n                   cmds,\n                   cmd_root=\"\", \n                   cmd_access=\"READ\",\n                   cmd_handle=\"\",\n                   cmd_macro=\"\",\n                   cmd_desc=\"\" ):\n\n        for cmd in cmds:\n            if ( cmd_root == \"\" ):\n                cmd_compound = cmd\n            else:\n                cmd_compound = cmd_root + \"_\" + cmd\n\n            cmd_data = cmds [ cmd ]\n\n            if cmd_data.has_key ( \"Access\" ):\n                cmd_access = cmd_data [ \"Access\" ]\n\n            if cmd_data.has_key ( \"Handle\" ):\n                cmd_handle = cmd_data [ \"Handle\" ]\n            elif ( cmd_handle != \"\" ):\n                cmd_handle = \"\"\n\n            if cmd_data.has_key ( \"Macro\" ):\n                cmd_macro = cmd_data [ \"Macro\" ]\n            elif ( cmd_macro != \"\" ):\n                cmd_macro = \"\"\n                \n\n            if cmd_data.has_key ( \"Desc\" ):\n                cmd_desc = cmd_data [ \"Desc\" ]\n            elif ( cmd_desc != \"\" ):\n                cmd_desc = \"\"\n\n            if cmd_data.has_key ( \"Args\" ):\n                cmd_args = cmd_data [ \"Args\" ]\n                self.dump_cmd ( cmd_args, \n                                cmd_compound, \n                                cmd_access,\n                                cmd_handle,\n                                cmd_macro,\n                                cmd_desc )\n\n            if cmd_data.has_key ( \"Handle\" ):\n                self.cmd_graph [ cmd_compound ] = CLICommand ( cmd_access, \n                                                               cmd_handle,\n                                                               cmd_macro,\n                                                               cmd_desc )\n                if ( len ( cmd_compound ) > self.indentation ):\n                    self.indentation = len ( cmd_compound )\n\n    def normalize_command ( self, cmd ):\n        return cmd.replace ( \" \", \"_\" )\n\n    def get_indentation ( self, cmd ):\n        return ( self.indentation + 8 - len ( cmd ) )\n\n    def suffix_macro_to_cmd ( self, macro_list, cmd ):\n        ret_cmd = []\n        for macro in macro_list:\n            ret_cmd.append ( self.normalize_command ( cmd + \"_\" + macro ) )\n        return ret_cmd\n\n    def get_macro_list ( self, class_instance, macro_txt, add_help=None ):\n        fn_macro = self.get_implementor_handle ( class_instance, macro_txt )\n        return fn_macro ( add_help )\n\n    def include_macro ( self, macro_list, ret_list ):\n        for item in macro_list:\n            ret_list.append ( item )\n\n    def string_has_enter ( self, string ):\n        if ( re.search ( \"<enter>\", string ) != None ):\n            return 1\n        else:\n            return 0\n\n    def add_enter_instruction ( self, result_list ):\n        if ( len ( result_list ) ):\n            string = result_list [ 0 ]\n            if ( self.string_has_enter ( string ) == 1 ):\n                return 0\n\n        result_list.insert ( 0, \" <enter>\" + \" \" * self.get_indentation ( \"<enter\" ) + \"Execute the current command\" )\n        \n\n    def match_macro ( self, macro_list, needle, ret_list ):\n        for haystack in macro_list:\n            if ( len ( needle ) == len ( haystack ) ):\n                if ( re.match ( needle, haystack ) != None ):\n                    self.add_enter_instruction ( ret_list )\n            elif ( len ( needle ) < len ( haystack ) ):\n                if ( re.match ( needle, haystack ) != None ):\n                    ret_list.append ( haystack )\n            else:\n                print \"\"\n\n    def option_exists ( self, consider_option, ret_list ):\n        for option in ret_list:\n            if ( re.match ( option, consider_option ) != None ):\n                return 1\n        return 0\n\n    def complete_command ( self,\n                           part_cmd, \n                           full_cmd, \n                           end_index, \n                           cmd_helper, \n                           ret_list ):\n        unmatched_string = full_cmd [ end_index: ]\n\n        if ( part_cmd [ -1 ] == \"_\" ):\n            part_cmd = part_cmd [ 0:-1 ]\n            unmatched_string = \"_\" + unmatched_string\n    \n        if ( unmatched_string [ 0 ] == \"_\" ):\n            possible_option = unmatched_string.replace ( \"_\", \" \" ) + ( \" \" * self.get_indentation ( full_cmd ) )\n            possible_option = possible_option + \"<\" + cmd_helper.cmd_desc + \">\"\n            ret_list.append ( possible_option )\n        else:\n            match_object = re.search ( \"_\", part_cmd )\n            while ( match_object != None ):\n                part_cmd = part_cmd [ match_object.end (): ]\n                match_object = re.search ( \"_\", part_cmd )\n        \n            match_object = re.search ( \"_\", unmatched_string )\n            if ( match_object != None ):\n                unmatched_string = unmatched_string [ :(match_object.end()-1)]\n\n            complete_word = part_cmd + unmatched_string\n            if ( self.option_exists ( complete_word, ret_list ) == 0 ):\n                 ret_list.append ( complete_word )\n\n        return ret_list\n        \n\n    def get_all_cmds ( self ):\n        ret_list = []\n        for cmd in self.cmd_graph:\n            cmd_str = cmd.replace ( \"_\", \" \" )\n            cmd_str = cmd_str + ( \" \" * self.get_indentation ( cmd ) ) + \"<\" + self.cmd_graph [ cmd ].cmd_desc + \">\"\n            ret_list.append ( cmd_str )\n        return ret_list\n\n    def get_match ( self, cmd ):\n        if  ( len ( cmd ) == 0 or re.search ( \"[a-z|A-Z|0-9]\", cmd ) == None ):\n            return self.get_all_cmds ()\n\n        if ( cmd [ -1 ] == \" \" ):\n            cmd = cmd [ 0:-1 ]\n\n        needle = self.normalize_command ( cmd )\n        ret_list = []\n\n        for haystack in self.cmd_graph:\n            len_haystack = len ( haystack )\n            len_needle   = len ( needle )\n            cmd_helper = self.cmd_graph [ haystack ]\n\n            if ( len_needle == len_haystack ):\n                if ( re.match ( needle, haystack ) != None ):\n                    if ( cmd_helper.cmd_macro != \"\" ):\n                        self.include_macro ( self.get_macro_list ( CLIImplementor (), cmd_helper.cmd_macro, \"add help\" ), ret_list )\n                    else:\n                        self.add_enter_instruction ( ret_list )\n\n            elif ( len_needle > len_haystack ):\n                match_object = re.match ( haystack, needle )\n                if ( match_object != None ):\n                    cmd_macro = needle [ match_object.end (): ]\n                    if ( cmd_macro [ 0 ] == \"_\" and len ( cmd_macro ) > 1 ):\n                        cmd_macro = cmd_macro [ 1: ]\n\n                    if ( cmd_helper.cmd_macro != \"\" ):\n                        cmd_macro_list = self.get_macro_list ( CLIImplementor(),\n                                                          cmd_helper.cmd_macro )\n                        self.match_macro ( cmd_macro_list, cmd_macro, ret_list )\n\n            elif ( len_needle < len_haystack ):\n                match_object = re.match ( needle, haystack )\n                if ( match_object != None ):\n                    balance_cmd = haystack [ match_object.end (): ]\n                    self.complete_command ( needle, \n                                            haystack, \n                                            match_object.end (), \n                                            self.cmd_graph [ haystack ],\n                                            ret_list )\n                \n\n        return ret_list\n\n    def chomp ( self, token ):\n        match_object = re.search ( \"[a-z|A-Z|0-9]\", token )\n        if ( match_object != None ):\n            token = token [ ( match_object.end () - 1): ]\n\n        token = token [ ::-1 ]\n        match_object = re.search ( \"[a-z|A-Z|0-9]\", token )\n        if ( match_object != None ):\n            token = token [ ( match_object.end () - 1): ]\n\n        token = token [ ::-1 ]\n\n        return token\n\n    def validate_command_and_execute ( self, full_cmd_context ):\n        return\n        best_cmd_match = \"\"\n        best_cmd_args  = \"\"\n        best_cmd_handle = None\n\n        for command in self.cmd_graph:\n            match_object = re.match ( command, \n                           self.normalize_command ( full_cmd_context ) )\n            if ( match_object != None ):\n                command_args = \"\"\n                if ( len ( full_cmd_context ) > len ( command ) ):\n                    command_args = self.chomp ( full_cmd_context [ match_object.end (): ] )\n                if ( len ( best_cmd_match ) < len ( command ) ):\n                    best_cmd_match = command\n                    best_cmd_args  = command_args\n                    best_cmd_handle = self.get_implementor_handle ( CLIImplementor (), self.cmd_graph [ command ].cmd_handle )\n\n        if ( best_cmd_handle != 0 ):\n            return best_cmd_handle ( best_cmd_args )\n        else:\n            print self.cmd_graph [ best_cmd_match ].cmd_handle + \" not implemented\"\n\n    def print_results ( self, result_list ):\n        for result in result_list:\n            print \"\\t\" + result\n\n    def print_command_graph ( self, cmd_dict ):\n        for keys in cmd_dict:\n            print keys + \"=>\"\n            cmd = cmd_dict [ keys ]\n            if ( cmd.cmd_desc != \"\" ):\n                print \"    \" + cmd.cmd_desc\n            print \"    \" + cmd.cmd_access\n            if ( cmd.cmd_macro != \"\" ):\n                fn_macro = self.get_implementor_handle ( CLIImplementor (), \n                                                        cmd.cmd_macro )\n                if ( fn_macro != 0 ):\n                    print fn_macro ()\n                else:\n                    print \"    Macro not implemented\"\n            if ( cmd.cmd_handle != \"\" ):\n                fn_handle = self.get_implementor_handle ( CLIImplementor (), \n                                                     cmd.cmd_handle )\n                if ( fn_handle != 0 ):\n                    fn_handle ()\n                else:\n                    print \"    Handler not implemented\"\n\n\ncli_util = CLIUtil ()\n    \n\nmatch_options = [ \"create cabling\",\n                  \"create pods\",\n                  \"create pods from\",\n                  \"create pods from-file\",\n                  \"\" ]\n\nif __name__ == '__main__':\n    for match in match_options:\n        print \"Matching results for \" + match + \" is:\"\n        cli_util.print_results ( cli_util.get_match ( match ) )\n        print \"------------------------------------------------------\"\n",
  "line_no": 262,
  "line_no_percent": "81%"
}