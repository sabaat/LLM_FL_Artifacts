{
  "instruction": "Create a QuerySet class that adds extra functionality to a basic list. It should hold instances of a single type of JSSObject and use the python list API while adding some extra helper-methods on top. The class should have methods to sort by ID and name, retrieve all contained objects' data from the JSS, save all contained objects' data to the JSS, invalidate the cache datetime for all contents, and return generators of contents' names and IDs. It should also have a class method to build a QuerySet from a listing Response.",
  "buggy_code": "\"\"\"queryset.py\n\nClass that adds some extra functionality to a basic list. Used as the\nresult of all queries in python-jss.\n\"\"\"\n\n\nfrom __future__ import absolute_import\nfrom collections import defaultdict\ntry:\n    import cPickle  # Python 2.X\nexcept ImportError:\n    import _pickle as cPickle  # Python 3+\nimport datetime\nimport os\n\nfrom .jssobject import DATE_FMT, Identity\n\n\nSTR_FMT = \"{0:>{1}} | {2:>{3}} | {4:>{5}}\"\n\n\nclass QuerySet(list):\n    \"\"\"A list style collection of JSSObjects.\n\n    Listing operations retrieve minimal or overview information for most\n    object types. For example, we may want to see all the Computers on\n    the JSS but that does not mean we want to do a full object GET for\n    each one.\n\n    QuerySets hold instances of a single type of JSSObject, and use the\n    python list API, while adding some extra helper-methods on top.\n    \"\"\"\n\n    def __init__(self, objects):\n        \"\"\"Construct a list of JSSObjects.\n\n        Args:\n            objects (sequence of JSSObjects):\n                Sequences must be of a single class.\n        \"\"\"\n        if objects and not len({i.__class__ for i in objects}) == 1:\n            raise ValueError\n        super(QuerySet, self).__init__(objects)\n        self.sort()\n        self.contained_class = objects[0].__class__ if objects else None\n\n    def __str__(self):\n        \"\"\"Make data human readable.\"\"\"\n        sort_keys = [\"id\", \"name\"]\n        if self:\n            sort_keys.extend([\n                key for key in self[0]._basic_identity.keys() if\n                key not in sort_keys])\n\n        lengths = defaultdict(int)\n        for item in self:\n            for key in sort_keys:\n                val = item._basic_identity[key] or \"\"\n                length = max(len(key), len(val))\n                if length > lengths[key]:\n                    lengths[key] = length\n\n        format_strings = []\n        for key in sort_keys:\n            length = lengths[key]\n            format_strings.append(\"{{data[{}]:>{}}}\".format(key, length))\n\n        cached = 'cached'\n        cached_format = '| {{cached:>{}}} |'.format(len(cached))\n\n        fmt = \"| \" + \" | \".join(format_strings) + cached_format\n\n        contained_name = self.contained_class.__name__ if self.contained_class is not None else \"Empty\"\n        results = [\"{} QuerySet\".format(contained_name)]\n        headers = {key: key for key in lengths}\n        header_line = fmt.format(data=headers, cached=\"cached\")\n        bar = len(header_line) * '-'\n        results.extend([bar, header_line, bar])\n\n        str_cached = (\n            lambda i: str(i.cached) if isinstance(i.cached, bool) else 'True')\n\n        table = [\n            fmt.format(data=item._basic_identity, cached=str_cached(item)) for\n            item in self]\n        results.extend(table)\n\n        results.append(bar)\n        return \"\\n\".join(results)\n\n    def __repr__(self):\n        \"\"\"Make data human readable.\"\"\"\n        return \"QuerySet({})\".format(super(QuerySet, self).__repr__())\n\n    def sort(self, **kwargs):\n        \"\"\"Sort list elements by ID.\n        \"\"\"\n        super(QuerySet, self).sort(key=lambda k: int(k.id))\n\n    def sort_by_name(self):\n        \"\"\"Sort list elements by name.\"\"\"\n        super(QuerySet, self).sort(key=lambda k: k.name.upper())\n\n    def retrieve_all(self):\n        \"\"\"Tell each contained object to retrieve its data from the JSS\n\n        This can take a long time given a large number of objects,\n        and depending on the size of each object.\n\n        Returns:\n            self (QuerySet) to allow method chaining.\n        \"\"\"\n        for obj in self:\n            if not obj.cached:\n                obj.retrieve()\n\n        return self\n\n    def save_all(self):\n        return\n        \"\"\"Tell each contained object to save its data to the JSS\n\n        This can take a long time given a large number of objects,\n        and depending on the size of each object.\n\n        Returns:\n            self (QuerySet) to allow method chaining.\n        \"\"\"\n        for obj in self:\n            obj.save()\n\n        return self\n\n    def invalidate(self):\n        \"\"\"Clear the cache datetime for all contents.\n\n        This causes objects to retrieve their data again when accessed.\n        \"\"\"\n        for i in self: i.cached = False\n\n    def names(self):\n        \"\"\"Return a generator of contents names\"\"\"\n        return (item.name for item in self)\n\n    def ids(self):\n        \"\"\"Return a generator of contents ids\"\"\"\n        return (item.id for item in self)\n\n    @classmethod\n    def from_response(cls, obj_class, response, jss=None, **kwargs):\n        \"\"\"Build a QuerySet from a listing Response.\"\"\"\n        response_objects = (\n            i for i in response if i is not None and i.tag != \"size\")\n\n        dicts = (\n            {child.tag: child.text for child in item} for item in\n            response_objects)\n        identities = (Identity(d) for d in dicts)\n\n        objects = [obj_class(jss, data=i, **kwargs) for i in identities]\n\n        return cls(objects)\n",
  "line_no": 121,
  "line_no_percent": "74%"
}