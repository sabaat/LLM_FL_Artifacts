{
  "instruction": "Create a Python script that sets up a communication class and an execution handler to receive and execute instructions from an OCaml process. The script should include methods to convert integers to 8-byte signed integers, convert Python objects to BSON format, and resolve arguments passed to methods. The script should also handle exceptions and send return values back to the OCaml process. Finally, the script should accept command line arguments for the working directory, read pipe path, and write pipe path.",
  "buggy_code": "from time import time\nfrom struct import pack, unpack\nimport bson, sys, os, codecs\nfrom random import randint\nfrom traceback import print_exc\n\ndef int_to_int64_bytes(i):\n\treturn pack('>q', i)\n\ndef py_to_bson(val):\n\tif type(val) is int:\n\t\treturn bson.int64.Int64(val)\n\tif sys.version_info.major == 2 and type(val) is str:\n\t\treturn bson.binary.Binary(val)\n\treturn val\n\ndef exit_lymp():\n\tsys.stdout.close()\n\texit(0)\n\nclass PipeReaderWriter:\n\n\tdef __init__(self, read_pipe_name, write_pipe_name):\n\t\tself.get_pipes(read_pipe_name, write_pipe_name)\n\n\tdef get_pipes(self, read_pipe_name, write_pipe_name):\n\t\treturn\n\t\tself.write_pipe = open(write_pipe_name, 'wb', 0)\n\t\tself.read_pipe = open(read_pipe_name, 'rb', 0)\n\n\tdef send_bytes(self, byts):\n\t\tself.write_pipe.write(pack('>q', len(byts)))\n\t\tself.write_pipe.write(byts)\n\n\tdef get_bytes(self):\n\t\ttry:\n\t\t\tnb_bytes = unpack('>q', self.read_pipe.read(8))[0]\n\t\texcept:\n\t\t\texit_lymp()\n\t\tbyts = b'' if sys.version_info.major == 3 else \"\"\n\t\twhile len(byts) < nb_bytes:\n\t\t\tbyts += self.read_pipe.read(nb_bytes)\n\t\treturn byts\n\nclass ExecutionHandler:\n\n\tto_ret_types = {\n\t\tint: \"i\",\n\t\ttuple: \"t\",\n\t\tlist: \"l\",\n\t\tstr: \"s\",\n\t\tfloat: \"f\",\n\t\ttype(None): \"n\",\n\t\tbool: \"b\",\n\t\tbytes: \"B\"\n\t}\n\tif sys.version_info.major == 2:\n\t\tto_ret_types[unicode] = \"s\"\n\t\tto_ret_types[str] = \"B\"\n\n\tdef __init__(self, reader_writer):\n\t\tself.reader_writer = reader_writer\n\t\tself.modules = {}\n\t\tself.objs = {}\n\t\tself.ref_nb = 0\n\n\tdef loop(self):\n\t\twhile True:\n\t\t\tcommand_bytes = self.reader_writer.get_bytes()\n\t\t\tif command_bytes == b'done':\n\t\t\t\texit_lymp()\n\t\t\tinstruction = bson.BSON.decode(bson.BSON(command_bytes))\n\t\t\ttry:\n\t\t\t\tret = self.execute_instruction(instruction)\n\t\t\t\tsys.stdout.flush()\n\t\t\t\tself.send_ret(ret, ret_ref=(\"R\" in instruction))\n\t\t\texcept BaseException as e:\n\t\t\t\tprint_exc()\n\t\t\t\tsys.stdout.flush()\n\t\t\t\tself.send_ret(\"\", exception=True)\n\n\tdef ret_to_msg(self, ret, ret_ref):\n\t\tmsg = {}\n\t\tif ret_ref or (type(ret) not in self.to_ret_types):\n\t\t\tself.ref_nb += 1\n\t\t\tself.objs[self.ref_nb] = ret\n\t\t\tmsg[\"t\"] = \"r\"\n\t\t\tmsg[\"v\"] = bson.code.Code(str(self.ref_nb))\n\t\telse:\n\t\t\tmsg[\"t\"] = self.to_ret_types[type(ret)]\n\t\t\tif type(ret) is tuple:\n\t\t\t\tret = list(ret)\n\t\t\tif type(ret) is list:\n\t\t\t\tmsg[\"v\"] = []\n\t\t\t\tfor elt in ret:\n\t\t\t\t\tmsg[\"v\"].append(self.ret_to_msg(elt, False))\n\t\t\telse:\n\t\t\t\tmsg[\"v\"] = py_to_bson(ret)\n\t\treturn msg\n\n\tdef send_ret(self, ret, exception=False, ret_ref=False):\n\t\tif exception:\n\t\t\tmsg = {}\n\t\t\tmsg[\"t\"] = \"e\"\n\t\t\tmsg[\"v\"] = \"\"\n\t\telse:\n\t\t\tmsg = self.ret_to_msg(ret, ret_ref)\n\t\tmsg = bytes(bson.BSON.encode(msg))\n\t\tself.reader_writer.send_bytes(msg)\n\n\tdef resolve_args(self, args):\n\t\tnamed = {}\n\t\ti = 0\n\t\tfor arg in args:\n\t\t\tif type(arg) is list and len(arg) == 2 and type(arg[0]) is bson.code.Code and str(arg[0])[0] == \"!\":\n\t\t\t\tnamed[str(arg[0])[1:]] = self.resolve_args([arg[1]])[0][0]\n\t\t\t\tdel args[i]\n\t\t\t\tcontinue\n\t\t\tif type(arg) is bson.binary.Binary:\n\t\t\t\targs[i] = bytes(arg)\n\t\t\tif type(arg) is bson.code.Code:\n\t\t\t\targs[i] = self.objs[int(arg)]\n\t\t\tif type(arg) is bson.int64.Int64:\n\t\t\t\targs[i] = int(arg)\n\t\t\tif sys.version_info.major == 2 and type(arg) is str:\n\t\t\t\targs[i] = args[i].decode('utf-8')\n\t\t\tif sys.version_info.major == 2 and type(arg) is bson.binary.Binary:\n\t\t\t\targs[i] = str(arg)\n\t\t\tif type(arg) is list:\n\t\t\t\targs[i] = self.resolve_args(arg)[0]\n\t\t\tif type(arg) is dict:\n\t\t\t\targs[i] = tuple(self.resolve_args(arg[\"v\"])[0])\n\t\t\ti += 1\n\t\treturn args, named\n\n\tdef execute_instruction(self, instruction):\n\t\tif \"r\" in instruction:\n\t\t\tif \"d\" in instruction and instruction[\"r\"] not in self.objs:\n\t\t\t\treturn None\n\t\t\tmodule = self.objs[instruction[\"r\"]]\n\t\t\tif \"d\" in instruction:\n\t\t\t\tdel self.objs[instruction[\"r\"]]\n\t\t\t\treturn None\n\t\t\tif \"g\" in instruction:\n\t\t\t\treturn module\n\t\telse:\n\t\t\tif sys.version_info.major == 2 and instruction[\"m\"] == \"builtins\":\n\t\t\t\tinstruction[\"m\"] = \"__builtin__\"\n\t\t\tif instruction[\"m\"] not in self.modules:\n\t\t\t\t__import__(instruction[\"m\"])\n\t\t\t\tself.modules[instruction[\"m\"]] = sys.modules[instruction[\"m\"]]\n\t\t\tmodule = self.modules[instruction[\"m\"]]\n\t\tif \"s\" in instruction:\n\t\t\targs, named = self.resolve_args(instruction[\"a\"])\n\t\t\targ = args[0]\n\t\t\tsetattr(module, instruction[\"f\"], arg)\n\t\t\treturn None\n\t\tfunc_or_attr = getattr(module, instruction[\"f\"])\n\t\tif \"t\" in instruction:\n\t\t\treturn func_or_attr\n\t\targs = instruction[\"a\"]\n\t\targs, named = self.resolve_args(args)\n\t\tret = func_or_attr(*args, **named)\n\t\treturn ret\n\nworking_directory = sys.argv[1]\nwrite_pipe_path = sys.argv[2]\nread_pipe_path = sys.argv[3]\nos.chdir(working_directory)\nsys.path.insert(0, working_directory)\nsys.stdout = codecs.open('python_log', 'w', encoding='utf-8')\nsys.stderr = sys.stdout\ncommunication = PipeReaderWriter(read_pipe_path, write_pipe_path)\nhandler = ExecutionHandler(communication)\nhandler.loop()\n",
  "line_no": 27,
  "line_no_percent": "15%"
}