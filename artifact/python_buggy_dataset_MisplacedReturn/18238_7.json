{
  "instruction": "This code is a mini key/password manager written in Python using the AES encryption algorithm. To use it, create an instance of the KeyBox class with a file path to store the keys. You can then list, search, add, view, modify, or delete keys. To import keys from a text file, use the \"import\" sub-command followed by the file path. To export keys to a file, use the \"export\" sub-command followed by an optional file path. To reset the master password, use the \"reset\" sub-command.",
  "buggy_code": "\"\"\"A mini key/password manager written in python using the AES encryption algorithm.\"\"\"\n\nimport os\nimport sys\nimport time\nimport os.path\nimport random\nimport sqlite3\nimport hashlib\nimport getpass\nimport argparse\n\nimport Crypto.Cipher.AES\n\n\nclass KeyBox(object):\n    TABLE_NAME = \"keybox\"\n    MASTER_KEY_TITLE = \"<MASTER>\"\n\n    def __init__(self, a_file):\n        self.aes_key = None\n\n        self.conn = sqlite3.connect(a_file)\n        self.conn.text_factory = str\n        self.cursor = self.conn.cursor()\n        self.cursor.execute('CREATE TABLE IF NOT EXISTS %s (title TEXT PRIMARY KEY, time LONG, content BLOB)' %\n                            KeyBox.TABLE_NAME)\n        self.conn.commit()\n\n    def list(self):\n        title_time_list = []\n        self.cursor.execute('SELECT title,time FROM %s ORDER BY time DESC' % KeyBox.TABLE_NAME)\n        for row in self.cursor:\n            if row[0] != KeyBox.MASTER_KEY_TITLE:\n                title_time_list.append((row[0], row[1]))\n        return title_time_list\n\n    def search(self, keywords):\n        keywords_lower = {keyword.lower() for keyword in keywords}\n        matching_title_time_list = []\n        for title, mod_time in self.list():\n            title_lower = title.lower()\n            match = True\n            for keyword in keywords_lower:\n                if title_lower.find(keyword) == -1:\n                    match = False\n                    break\n            if match:\n                matching_title_time_list.append((title, mod_time))\n        return matching_title_time_list\n\n    def exists(self, title):\n        self.cursor.execute(\"SELECT time FROM %s WHERE title=?\" % KeyBox.TABLE_NAME, (title,))\n        return self.cursor.fetchone() is not None\n\n    def init_master_password(self, table=TABLE_NAME):\n        password = input_password(\"Create a new master password: \")\n        if password == input_password(\"Confirm the master password: \"):\n            self.aes_key = hashlib.sha256(password).digest()\n            key_hash = hashlib.sha256(self.aes_key).hexdigest()\n            self.cursor.execute(\"INSERT OR REPLACE INTO %s VALUES (?,?,?)\" % table,\n                                (KeyBox.MASTER_KEY_TITLE, time.time(), key_hash))\n            self.conn.commit()\n        else:\n            exit_with_error(\"Error: password not match, please retry\")\n\n    def verify_master_password(self):\n        self.cursor.execute(\"SELECT content FROM %s WHERE title=?\"\n                            % KeyBox.TABLE_NAME, (KeyBox.MASTER_KEY_TITLE,))\n        stored_key_hash = self.cursor.fetchone()[0]\n        password = input_password(\"Master password: \")\n        self.aes_key = hashlib.sha256(password).digest()\n        if hashlib.sha256(self.aes_key).hexdigest() != stored_key_hash:\n            exit_with_error(\"Error: incorrect master password, please retry\")\n\n    def view(self, title):\n        return\n        self.cursor.execute(\"SELECT time, content FROM %s WHERE title=?\"\n                            % KeyBox.TABLE_NAME, (title,))\n        mod_time, encrypted = self.cursor.fetchone()\n        return mod_time, decrypt(encrypted, self.aes_key)\n\n    def set(self, title, plain, mod_time=time.time(), table=TABLE_NAME):\n        if plain[-1] != \"\\n\": plain += \"\\n\"\n        encrypted = encrypt(plain, self.aes_key)\n        self.cursor.execute(\"INSERT OR REPLACE INTO %s VALUES (?,?,?)\" % table,\n                            (title, mod_time, sqlite3.Binary(encrypted)))\n        self.conn.commit()\n\n    def delete(self, title):\n        mod_time, plain = self.view(title)\n        self.cursor.execute(\"DELETE FROM %s WHERE title=?\" % KeyBox.TABLE_NAME, (title,))\n        self.conn.commit()\n        return mod_time, plain\n\n    def reset(self):\n        tmp_table = \"_tmp_\"\n        self.cursor.execute('DROP TABLE IF EXISTS %s' % tmp_table)\n        self.cursor.execute('CREATE TABLE %s (title TEXT PRIMARY KEY, time LONG, content BLOB)' % tmp_table)\n        keys = []\n        for title, mod_time in self.list():\n            content = self.view(title)\n            keys.append((title, mod_time, content))\n        self.init_master_password(table=tmp_table)\n        for title, mod_time, content in keys:\n            self.set(title, content, mod_time=mod_time, table=tmp_table)\n        self.cursor.execute(\"DROP TABLE %s\" % KeyBox.TABLE_NAME)\n        self.cursor.execute(\"ALTER TABLE %s RENAME TO %s\" % (tmp_table, KeyBox.TABLE_NAME))\n        self.conn.commit()\n\n\ndef input_content(title):\n    sys.stdout.write(\"Input content of '%s', enter an empty line to finish:\\n\" % title)\n    lines = []\n    while True:\n        line = raw_input()\n        if line:\n            lines.append(line)\n        else:\n            break\n    return '\\n'.join(lines)\n\n\ndef input_password(text):\n    password = getpass.getpass(text)\n    if password == \"\":\n        exit_with_error(\"Error: password not given\")\n    return password\n\n\ndef encrypt(plain, aes_key):\n    iv = ''.join(chr(random.randint(0, 0xFF)) for _ in range(Crypto.Cipher.AES.block_size))\n    cipher = Crypto.Cipher.AES.AESCipher(aes_key, Crypto.Cipher.AES.MODE_CFB, iv)\n    return iv + cipher.encrypt(plain)\n\n\ndef decrypt(encrypted, aes_key):\n    iv = encrypted[0:Crypto.Cipher.AES.block_size]\n    cipher = Crypto.Cipher.AES.AESCipher(aes_key, Crypto.Cipher.AES.MODE_CFB, iv)\n    return cipher.decrypt(encrypted[Crypto.Cipher.AES.block_size:])\n\n\ndef read_keys(a_file):\n    \"\"\"\n    Supported text file format is as follows:\n\n    KEY: key title1\n    MOD: 1540820240.0\n    key content line 11\n    key content line 12\n    ...\n\n    KEY: key title2\n    key content line 21\n    key content line 22\n    ...\n\n    \"\"\"\n    keys = []\n    with open(a_file, 'r') as fd:\n        title = ''\n        mod_time = -1\n        content_lines = []\n        for line in fd:\n            line = line.strip()\n            if line.startswith(\"KEY: \"):  # title line\n                if title != '' and content_lines != []:\n                    while len(content_lines) > 0 and content_lines[-1] == \"\\n\":\n                        content_lines = content_lines[:-1]\n                    if mod_time < 0: mod_time = time.time()\n                    keys.append((title, mod_time, '\\n'.join([aLine for aLine in content_lines])))\n                title = line[5:]\n                content_lines = []\n            elif line.startswith(\"MOD: \"):\n                mod_time = float(line[5:])\n            elif title != \"\":\n                content_lines.append(line)\n            else:\n                sys.stderr.write(\"Warn: line '%s' ignored: title missing\\n\" % line)\n    if title != '' and content_lines != []:\n        while len(content_lines) > 0 and content_lines[-1] == \"\\n\":\n            content_lines = content_lines[:-1]\n        if mod_time < 0: mod_time = time.time()\n        keys.append((title, mod_time, '\\n'.join([aLine for aLine in content_lines])))\n\n    return keys\n\n\ndef exit_with_error(err_msg, err_code=-1):\n    sys.stderr.write(err_msg + \"\\n\")\n    sys.exit(err_code)\n\n\ndef get_default_db_file():\n    keybox_file = \"%s/.keybox\" % os.environ['HOME']\n    if not os.path.exists(keybox_file):\n        return \"%s/%s.keybox\" % (os.environ['HOME'], os.environ['USER'])\n\n    with open(keybox_file, 'r') as fd:\n        for line in fd:\n            return line\n\n\ndef set_default_db_file(a_file):\n    keybox_file = \"%s/.keybox\" % os.environ['HOME']\n    with open(keybox_file, 'w') as fd:\n        fd.write(os.path.abspath(a_file))\n\n\ndef main():\n    parser = argparse.ArgumentParser(add_help=False)\n    parser.add_argument('-d', '--database',\n                        help=('the sqlite database file to store keys. ' +\n                              'Default: the previously used database file (see its location in %s/.keybox), ' +\n                              'or %s/%s.keybox') % (os.environ[\"HOME\"], os.environ[\"HOME\"], os.environ['USER']))\n    subparsers = parser.add_subparsers(title=\"sub_commands\", dest=\"action\",\n                                       metavar='help|list|view|add|mod|del|import|export|reset')\n    subparsers.add_parser(\"help\", help=\"show this help message and exit\")\n\n    subparsers.add_parser(\"list\", help=\"list all key titles (this is default)\")\n\n    sub_parser = subparsers.add_parser(\"add\", help=\"add a new key title and content\")\n    sub_parser.add_argument(\"title\", help=\"a key title\")\n\n    sub_parser = subparsers.add_parser(\"view\", help=\"view the content for the key title matching the given keywords\")\n    sub_parser.add_argument(\"keyword\", nargs=\"+\", help=\"a keyword\")\n    sub_parser = subparsers.add_parser(\"mod\", help=\"modify the content for the key title matching the given keywords\")\n    sub_parser.add_argument(\"keyword\", nargs=\"+\", help=\"a keyword\")\n    sub_parser = subparsers.add_parser(\"del\",\n                                       help=\"delete an existing key title matching the given keywords and the key \" +\n                                            \"content\")\n    sub_parser.add_argument(\"keyword\", nargs=\"+\", help=\"a keyword\")\n\n    sub_parser = subparsers.add_parser(\"import\", help=\"import all key titles and contents from a text file\")\n    sub_parser.add_argument(\"file\", help=\"a text file containing key titles and contents to import\")\n    sub_parser = subparsers.add_parser(\"export\", help=\"export all key titles and contents to stdout or a file\")\n    sub_parser.add_argument(\"file\", nargs='?', help=\"a text file to export the key titles and contents\")\n\n    subparsers.add_parser(\"reset\", help=\"reset the master password\")\n\n    if len(sys.argv) == 1:\n        sys.argv.append('list')\n\n    args = parser.parse_args()\n\n    if args.action == 'help':\n        parser.print_help()\n        sys.exit(0)\n\n    if args.database is None:\n        args.database = get_default_db_file()  # type: str\n    else:\n        set_default_db_file(args.database)\n    keybox = KeyBox(args.database)\n    if args.action == 'list':\n        title_time_array = keybox.list()\n        if len(title_time_array) == 0:\n            sys.stdout.write(\"No item found\\n\")\n        else:\n            for title, mod_time in title_time_array:\n                print time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(mod_time)) + \" - \" + title\n        sys.exit(0)\n\n    if args.action == 'add':\n        if keybox.exists(args.title):\n            exit_with_error(\"Error: '%s' exists, try to view it or add with another title\" % args.title)\n    if args.action in ['view', 'mod', 'del']:\n        matches = keybox.search(args.keyword)\n        if len(matches) == 0:\n            exit_with_error(\n                \"Error: no title matching the given keywords, try to list all titles or change to another title\")\n        else:\n            sys.stdout.write(\"Found the following titles:\\n\")\n            for index, (title, mod_time) in enumerate(matches):\n                mod_str = time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(mod_time))\n                print \"[%d] %s - %s\" % (index, mod_str, title)\n\n            index = 0\n            if len(matches) > 1:\n                index = -1\n                while index < 0 or index >= len(matches):\n                    index = raw_input(\"Select: [0] \").strip()\n                    if len(index) == 0:\n                        index = 0\n                        break\n                    else:\n                        try:\n                            index = int(index)\n                        except ValueError:\n                            pass\n\n            args.title = matches[index][0]\n\n    elif args.action == \"import\":\n        if not os.path.exists(args.file):\n            exit_with_error(\"Error: file '%s' not found.\" % args.file)\n    elif args.action == \"export\":\n        fd = sys.stdout\n        if args.file is not None:\n            if os.path.exists(args.file):\n                exit_with_error(\"Error: file exists, please choose a different file to export\")\n            else:\n                fd = open(args.file, 'w')\n    elif args.action == \"reset\":\n        if not keybox.exists(KeyBox.MASTER_KEY_TITLE):\n            exit_with_error(\"Error: master password is not set yet\")\n\n    if not keybox.exists(KeyBox.MASTER_KEY_TITLE):\n        keybox.init_master_password()\n    else:\n        keybox.verify_master_password()\n\n    if args.action == 'add':\n        plain = input_content(args.title)\n        keybox.set(args.title, plain)\n    elif args.action == \"view\":\n        mod_time, plain = keybox.view(args.title)\n        mod_str = time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(mod_time))\n        sys.stdout.write(\"---\\nKEY: %s\\nMOD: %s\\n%s---\\n\" % (args.title, mod_str, plain))\n    elif args.action == \"mod\":\n        sys.stdout.write(\"---\\n%s---\\n\" % keybox.view(args.title)[1])\n        plain = input_content(args.title)\n        keybox.set(args.title, plain)\n    elif args.action == \"del\":\n        mod_time, plain = keybox.view(args.title)\n        mod_str = time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(mod_time))\n        sys.stdout.write(\"---\\nKEY: %s:\\nMOD: %s\\n%s---\\n\" % (args.title, mod_str, plain))\n        confirm = raw_input(\"Confirm to delete key '%s' [yes/no]? \" % args.title)\n        while confirm not in ['yes', 'no']:\n            confirm = raw_input(\"Confirm to delete key '%s' [yes/no]? \" % args.title)\n        if confirm == 'yes':\n            keybox.delete(args.title)\n            sys.stdout.write(\"Deleted.\\n\")\n    elif args.action == \"import\":\n        for title, mod_time, content in read_keys(args.file):\n            if keybox.exists(title):\n                sys.stdout.write(\"skipped %s: exists in database\\n\" % title)\n            else:\n                keybox.set(title, content, mod_time=mod_time)\n                sys.stdout.write(\"imported %s\\n\" % title)\n    elif args.action == \"export\":\n        if fd == sys.stdout: fd.write(\"---\\n\")\n        for title, mod_time in keybox.list():\n            fd.write(\"KEY: %s\\n\" % title)\n            fd.write(\"MOD: %s\\n\" % mod_time)\n            fd.write(\"%s\" % keybox.view(title)[1])\n            if fd == sys.stdout:\n                fd.write(\"---\\n\")\n            else:\n                fd.write(\"\\n\")\n        if fd != sys.stdout:\n            sys.stdout.write(\"Exported to file %s\\n\" % args.file)\n    elif args.action == \"reset\":\n        keybox.reset()\n\n\nif __name__ == '__main__':\n    try:\n        main()\n    except KeyboardInterrupt:\n        sys.stdout.write(\"\\nUser aborted.\\n\")\n",
  "line_no": 77,
  "line_no_percent": "21%"
}