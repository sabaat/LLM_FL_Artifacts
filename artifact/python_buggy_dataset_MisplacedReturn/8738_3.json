{
  "instruction": "Create a class called DiskAccessControl that controls access to the disk files. The class should have an __init__ method that takes in the following parameters: invertedIndexFileName (string), fileLen (int), onMemInd (dictionary), nameDict (dictionary), and mods (dictionary). The class should have a method called getIndexLine that takes in a word (string) and returns a list containing the index data of the word requested. If the word is not in the index, it should write an empty list to the index file at the word's future position. The class should also have a method called pushIntoIndexFile that takes in fileIndexedName (string), word (string), and wordIndexTouple (tuple) and pushes the inverted list of a term into the index. The class should have a method called merge that takes in outerModifications (dictionary) and pushes the provided modifications into the instance's modifications list. The class should have a method called dumpMemory that dumps the on-memory metafiles and writes the modifications to the index.",
  "buggy_code": "'''\nJos\u00e9 F. R. Fonseca\nSee Attached License file\n\nControls the access to the disk. Defines the class DIskAccessControl,\nan object to control the disk files. Multithread-writes the files\n'''\n\nimport ast\nimport os\nimport time\nfrom linecache import getline\nfrom threading import Thread\n\n'''\nONLY WRITES TO THE FILE WHEN THE CACHE OF LINES TO WRITE OVERCOMES\nTHIS MUCH BYTES, or if it is the last batch of files to be written.\n'''\nFILEACCESS_THRASHOLD = 1024*1024/32\n\n'''\nCLASSES\n'''\nclass DiskAccessControl():  # @IgnorePep8\n    '''\n    Control the access to the disk, being the middleware to read and write the\n    index files\n    '''\n    def __init__(self, invertedIndexFileName, fileLen=None,\n                 onMemInd=None, nameDict=None, mods=None):\n        '''\n        Instantiates the class as the only reference to the index files\n        :param invertedIndexFileName: string, name of the index file\n        :param fileLen: int, original number of lines of the index file, when\n        known\n        :param onMemInd: dictionary, on-memory index that translates terms\n        into file positions\n        :param nameDict: dictionary, on-memory index that translates the name\n        of each file indexed into a hash\n        into a hash\n        :param mods: dictionary, side-loaded modifications to be put into the\n        index manually.\n        '''\n        self.GENERATED_INVERTED_INDEX = invertedIndexFileName\n\n        if fileLen is None:\n            lineNum = 0\n            with open(self.GENERATED_INVERTED_INDEX, \"r\") as indFile:\n                for lineNum, dummy in enumerate(indFile):\n                    pass\n                self.fileLength = lineNum + 1\n        else:\n            self.fileLength = fileLen\n\n        if onMemInd is None:\n            print \"FILLING MEMORY INDEX WITH LAST SESSION'S!\"\n            with open(\"metaIndex-\"+self.GENERATED_INVERTED_INDEX, \"r\") as metaindex:  # @IgnorePep8\n                data = metaindex.read()\n                self.onMemoryIndex = ast.literal_eval(data)\n        else:\n            self.onMemoryIndex = onMemInd\n\n        if nameDict is None:\n            print \"FILLING NAMES DICTIONARY WITH LAST SESSION'S!\"\n            with open(\"namesDict-\"+self.GENERATED_INVERTED_INDEX, \"r\") as namesDict:  # @IgnorePep8\n                data = namesDict.read()\n                self.namesDictionary = ast.literal_eval(data)\n        else:\n            self.namesDictionary = nameDict\n\n        if mods is None:\n            self.modifications = {}\n        else:\n            self.modifications = mods\n\n    '''\n    METHODS ###############################################\n    '''\n\n    def getIndexLine(self, word):\n        '''\n        GETS a line of the index file, containing the inverted list of the word\n        provided. If inexistent, returns an empty list\n        :return a list containing the index data of the word requested.\n        It may be: the inverted list on the index, the modifications done\n        to such list in memory, or an empty list for a new term to be indexed\n        :param word: string to retrieve the index data of it, a term\n        '''\n        if word in self.onMemoryIndex.keys():\n            wrd = self.onMemoryIndex[word]\n            if wrd not in self.modifications.keys():\n                try:\n                    return ast.literal_eval(getline(self.GENERATED_INVERTED_INDEX, int(wrd)+1).split(\":::\")[1])  # @IgnorePep8\n                except:\n                    print wrd, \"(|||)\", getline(self.GENERATED_INVERTED_INDEX, int(wrd)+1)  # @IgnorePep8\n            else:\n                return self.modifications[wrd]\n        else:\n            with open(self.GENERATED_INVERTED_INDEX, \"a\") as indFile:\n                self.onMemoryIndex[word] = str(len(self.onMemoryIndex.keys()))  # @IgnorePep8\n                indFile.write(self.onMemoryIndex[word]+\":::\"+\"[]\"+\"\\n\")\n            self.fileLength += 1\n            return []\n\n    def pushIntoIndexFile(self, fileIndexedName, word, wordIndexTouple):\n        return\n        '''\n        Pushes the preshly produced inverted list of a term into the index\n        :param fileIndexedName: string, name of the file just indexed\n        :param word: string, term to be pushed into the index\n        :param wordIndexTouple: touple, containing the number of elements\n        in the positions list, and a (integer) positions list of occurences of\n        the term in the file indexed\n        '''\n        indexLine = self.getIndexLine(word)\n        if fileIndexedName in self.namesDictionary.keys():\n            hashName = self.namesDictionary[fileIndexedName]\n        else:\n            self.namesDictionary[fileIndexedName] = hashName = str(len(self.namesDictionary.keys()))  # @IgnorePep8\n        try:\n            indexLine.append((hashName, wordIndexTouple[0], (list(set(wordIndexTouple[1]))), ))  # @IgnorePep8\n            self.modifications[self.onMemoryIndex[word]] = indexLine\n        except IndexError:\n            print \"Got an IndexError!\"+str((word, self.onMemoryIndex[word], indexLine, ))  # @IgnorePep8\n\n    def merge(self, outerModifications):\n        '''\n        Pushes provided modifications (made by another thread, for example,\n        into this instance's modifications list\n        :param outerModifications: dictionary, mapping terms to inverted lists,\n        are modifications to the index file imported from another instance\n        '''\n        for outKey in outerModifications.keys():\n            if outKey in self.modifications.keys():\n                self.modifications[outKey].extend(outerModifications[outKey])\n                self.modifications[outKey] = sorted(self.modifications[outKey],\n                                                    key=lambda mod: int(mod[0]))  # @IgnorePep8\n            else:\n                self.modifications[outKey] = outerModifications[outKey]\n\n    def dumpMetafiles(self):\n        '''\n        Dumps the on-memory metafiles, the dictionaries mapping terms to file\n        positions (hashes) and file names to hashes, to disk files.\n        '''\n        with open(\"metaIndex-\"+self.GENERATED_INVERTED_INDEX, \"w\") as metaindex:  # @IgnorePep8\n            metaindex.write(str(self.onMemoryIndex))\n        with open(\"namesDict-\"+self.GENERATED_INVERTED_INDEX, \"w\") as namesDict:  # @IgnorePep8\n            namesDict.write(str(self.namesDictionary))\n\n    def dumpMemory(self):\n        '''\n        Dumps the metafiles and writes the modifications to the index. It is,\n        by far, the most time-costly operation on the entire program, what was\n        to be expected, since it involves heavy file writting and reading.\n        '''\n        metafileWriter = Thread(target=self.dumpMetafiles)\n        metafileWriter.start()\n        printString = \"\"\n        modKeys = sorted([k for k in self.modifications.keys()])\n        with open(self.GENERATED_INVERTED_INDEX, \"r\") as oldIndexFile:  # @IgnorePep8\n            with open(\"TEMP_\"+self.GENERATED_INVERTED_INDEX, \"w+\") as newIndexFile:  # @IgnorePep8\n                for line in oldIndexFile:\n                    lineNum = line.split(\":::\")[0]\n                    if lineNum in modKeys:  # @IgnorePep8\n                        printString += lineNum+\":::\"+str(self.modifications[lineNum])+\"\\n\"  # @IgnorePep8\n                    else:\n                        printString += line\n                    if len(printString) >= FILEACCESS_THRASHOLD:\n                        newIndexFile.write(printString)\n                        printString = \"\"\n        os.rename(self.GENERATED_INVERTED_INDEX, \"Backup_\"+str(time.time())+\"_\"+self.GENERATED_INVERTED_INDEX)  # @IgnorePep8\n        os.rename(\"TEMP_\"+self.GENERATED_INVERTED_INDEX, self.GENERATED_INVERTED_INDEX)  # @IgnorePep8\n        metafileWriter.join()\n",
  "line_no": 106,
  "line_no_percent": "61%"
}