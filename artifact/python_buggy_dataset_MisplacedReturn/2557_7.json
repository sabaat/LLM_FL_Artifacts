{
  "instruction": "This code is a Python script for a music player. To use it, you need to run it in a Python environment. The script will look for MP3 files in the ~/Music directory and play them in random order. To control the player, use the following keys in the console: space (play/pause), left/right arrow (seek back/forward by 10 seconds), return (next song), and q (quit).",
  "buggy_code": "import sys, os, random, fnmatch\n\nsys.path = [os.path.abspath((os.path.dirname(__file__) or \".\") + \"/..\")] + sys.path\n\nimport musicplayer\nprint \"Module:\", musicplayer.__file__\n\nmusicplayer.setFfmpegLogLevel(20)\n\ntry:\n\timport better_exchook\n\tbetter_exchook.install()\nexcept ImportError: pass # doesnt matter\n\ntry:\n\timport faulthandler\n\tfaulthandler.enable(all_threads=True)\nexcept ImportError:\n\tprint \"note: module faulthandler not available\"\n\t\nclass Song:\n\tdef __init__(self, fn):\n\t\tself.url = fn\n\t\tself.f = open(fn)\n\t\t\n\tdef __eq__(self, other):\n\t\treturn self.url == other.url\n\t\n\tdef readPacket(self, bufSize):\n\t\ts = self.f.read(bufSize)\n\t\treturn s\n\n\tdef seekRaw(self, offset, whence):\n\t\tr = self.f.seek(offset, whence)\n\t\treturn self.f.tell()\n\nfiles = []\ndef getFiles(path):\n\tfor f in sorted(os.listdir(path), key=lambda k: random.random()):\n\t\tf = os.path.join(path, f)\n\t\tif os.path.isdir(f): getFiles(f) # recurse\n\t\tif len(files) > 1000: break # break if we have enough\n\t\tif fnmatch.fnmatch(f, '*.mp3'): files.append(f)\ngetFiles(os.path.expanduser(\"~/Music\"))\nrandom.shuffle(files) # shuffle some more\nfiles = sys.argv[1:] + files\nassert files, \"give me some files or fill-up ~/Music\"\n\ni = 0\n\ndef songs():\n\tglobal i, files\n\twhile True:\n\t\tyield Song(files[i])\n\t\ti += 1\n\t\tif i >= len(files): i = 0\n\ndef peekSongs(n):\n\treturn\n\tnexti = i + 1\n\tif nexti >= len(files): nexti = 0\n\treturn map(Song, (files[nexti:] + files[:nexti])[:n])\n\nplayer = musicplayer.createPlayer()\nplayer.outSamplerate = 48000\nplayer.queue = songs()\nplayer.peekQueue = peekSongs\nplayer.playing = True\n\ndef formatTime(t):\n\tif t is None: return \"?\"\n\tmins = long(t // 60)\n\tt -= mins * 60\n\thours = mins // 60\n\tmins -= hours * 60\n\tif hours: return \"%02i:%02i:%02.0f\" % (hours,mins,t)\n\treturn \"%02i:%02.0f\" % (mins,t)\n\nimport termios\n\ndef prepareStdin():\n\tfd = sys.stdin.fileno()\n\t\n\tif os.isatty(fd):\t\t\n\t\told = termios.tcgetattr(fd)\n\t\tnew = termios.tcgetattr(fd)\n\t\tnew[3] = new[3] & ~termios.ICANON & ~termios.ECHO\n\t\tnew[6][termios.VMIN] = 0\n\t\tnew[6][termios.VTIME] = 1\n\t\t\n\t\ttermios.tcsetattr(fd, termios.TCSANOW, new)\n\t\ttermios.tcsendbreak(fd, 0)\n\n\t\timport atexit\n\t\tatexit.register(lambda: termios.tcsetattr(fd, termios.TCSANOW, old))\t\n\n\t\tprint \"Console control:\"\n\t\tprint \"  <space>:        play / pause\"\n\t\tprint \"  <left>/<right>: seek back/forward by 10 secs\"\n\t\tprint \"  <return>:       next song\"\n\t\tprint \"  <q>:            quit\"\n\ndef getchar():\n\tfd = sys.stdin.fileno()\n\tch = os.read(fd, 7)\n\treturn ch\n\nprepareStdin()\n\nwhile True:\n\tsys.stdout.write(\"\\r\\033[K\") # clear line\n\tif player.playing: sys.stdout.write(\"playing, \")\n\telse: sys.stdout.write(\"paused, \")\n\tcurSong = player.curSong\n\tif curSong:\n\t\turl = os.path.basename(curSong.url)\n\t\tif len(url) > 40: url = url[:37] + \"...\"\n\t\tsys.stdout.write(\n\t\t\turl + \" : \" +\n\t\t\tformatTime(player.curSongPos) + \" / \" +\n\t\t\tformatTime(player.curSongLen))\n\telse:\n\t\tsys.stdout.write(\"no song\")\n\t\n\tch = getchar()\n\tif ch == \"\\x1b[D\": # left\n\t\tplayer.seekRel(-10)\n\telif ch == \"\\x1b[C\": #right\n\t\tplayer.seekRel(10)\n\telif ch == \"\\x1b[A\": #up\n\t\tpass\n\telif ch == \"\\x1b[B\": #down\n\t\tpass\n\telif ch == \"\\n\": # return\n\t\tplayer.nextSong()\n\telif ch == \" \":\n\t\tplayer.playing = not player.playing\n\telif ch == \"q\":\n\t\tprint\n\t\tsys.exit(0)\n\tsys.stdout.flush()\n",
  "line_no": 59,
  "line_no_percent": "42%"
}