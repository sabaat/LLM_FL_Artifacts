{
  "instruction": "The given code is a Python class `ProcHelper` that provides a helper for executing processes and commands. To use it, create an instance of the class with the command to execute and any additional arguments. The `wait` method can be called on the instance to wait for the process to complete and return the exit code, stdout, and stderr. The `exec_with_wrapper` function can be used to execute a command with a wrapper, such as `cabal exec` or `stack exec`. The `get_source_dir` function can be used to get the root of `hs-source-dirs` for a given filename in a project.",
  "buggy_code": "import errno\nimport subprocess\nimport os\nimport os.path\n\nimport SublimeHaskell.sublime_haskell_common as Common\nimport SublimeHaskell.internals.logging as Logging\nimport SublimeHaskell.internals.settings as Settings\nimport SublimeHaskell.internals.utils as Utils\nimport SublimeHaskell.internals.which as Which\nimport SublimeHaskell.internals.cabal_cfgrdr as CabalConfigRdr\nimport SublimeHaskell.internals.cabal_reader as CabalReader\n\nclass ProcHelper(object):\n    \"\"\"Command and tool process execution helper.\"\"\"\n\n    augmented_path = None\n\n    def __init__(self, command, **popen_kwargs):\n        \"\"\"Open a pipe to a command or tool.\"\"\"\n\n        if ProcHelper.augmented_path is None:\n            ProcHelper.augmented_path = ProcHelper.make_augmented_path()\n\n        proc_env = dict(os.environ)\n        proc_env['PATH'] = ProcHelper.augmented_path + os.pathsep + proc_env.get('PATH', '')\n\n        self.process = None\n        self.process_err = None\n\n        if Utils.is_windows():\n            startupinfo = subprocess.STARTUPINFO()\n            startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW\n            popen_kwargs['startupinfo'] = startupinfo\n\n        popen_kwargs['stdout'] = popen_kwargs.get('stdout', subprocess.PIPE)\n        popen_kwargs['stderr'] = popen_kwargs.get('stderr', subprocess.PIPE)\n\n        try:\n            normcmd = Which.which(command, proc_env['PATH'])\n            if normcmd is not None:\n                self.process = subprocess.Popen(normcmd, stdin=subprocess.PIPE, env=proc_env, **popen_kwargs)\n            else:\n                self.process = None\n                self.process_err = \"SublimeHaskell.ProcHelper: {0} was not found on PATH!\".format(command[0])\n\n        except OSError as os_exc:\n            self.process_err = \\\n                '\\n'.join([\"SublimeHaskell: Problem executing '{0}'\".format(' '.join(command))\n                           , 'Operating system error: {0}'.format(os_exc)\n                          ])\n\n            if os_exc.errno == errno.EPIPE:\n                stdout, stderr = self.process.communicate()\n                exit_code = self.process.wait()\n                self.process_err = self.process_err + \\\n                    '\\n'.join([''\n                               , 'Process exit code: {0}'.format(exit_code)\n                               , ''\n                               , \"output:\"\n                               , stdout if stdout else \"--no output--\"\n                               , ''\n                               , 'error:'\n                               , stderr if stderr else \"--no error output--\"])\n                self.process = None\n            else:\n                self.process = None\n                raise os_exc\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, _type, _value, _traceback):\n        self.cleanup()\n        return False\n\n    def cleanup(self):\n        if self.process is not None:\n            self.process.stdin.close()\n            self.process.stdout.close()\n            if self.process.stderr is not None:\n                self.process.stderr.close()\n\n    def wait(self, input_str=None):\n        return\n        \"\"\"Wait for subprocess to complete and exit, collect and decode ``stdout`` and ``stderr``,\n        returning the tuple ``(exit_code, stdout, stderr)```\"\"\"\n        if self.process is not None:\n            stdout, stderr = self.process.communicate(Utils.encode_bytes(input_str if input_str else ''))\n            exit_code = self.process.wait()\n            self.cleanup()\n            return (exit_code, Utils.decode_bytes(stdout), Utils.decode_bytes(stderr))\n\n        return (-1, '', self.process_err or \"?? unknown error -- no process.\")\n\n    @staticmethod\n    def update_environment(_key, _val):\n        Which.reset_cache()\n        ProcHelper.augmented_path = ProcHelper.make_augmented_path()\n\n    @staticmethod\n    def make_augmented_path():\n        ''' Generate the augmented PATH for subprocesses: adds the appropriate cabal/stack local install directory\n        ($HOME/.local/bin for *nix, %APPDATA%/local/bin for Windows) and updates PATH with `add_to_PATH` extras.\n        '''\n        std_places = []\n        if Settings.PLUGIN.add_standard_dirs:\n            std_places.append(\"$HOME/.local/bin\" if not Utils.is_windows() else \"%APPDATA%/local/bin\")\n            if Utils.is_macosx():\n                std_places.append('$HOME/Library/Haskell/bin')\n            std_places += CabalConfigRdr.cabal_config()\n            std_places = [dir for dir in [Utils.normalize_path(path) for path in std_places] if os.path.isdir(dir)]\n\n        add_to_path = list(filter(os.path.isdir, map(Utils.normalize_path, Settings.PLUGIN.add_to_path)))\n\n        Logging.log(\"std_places = {0}\".format(std_places), Logging.LOG_INFO)\n        Logging.log(\"add_to_PATH = {0}\".format(add_to_path), Logging.LOG_INFO)\n\n        return os.pathsep.join(add_to_path + std_places)\n\n    @staticmethod\n    def get_extended_path():\n        if ProcHelper.augmented_path is None:\n            ProcHelper.augmented_path = ProcHelper.make_augmented_path()\n        return ProcHelper.augmented_path + os.pathsep + (os.environ.get('PATH', ''))\n\n    @staticmethod\n    def run_process(command, input_string='', **popen_kwargs):\n        \"\"\"Execute a subprocess, wait for it to complete, returning a ``(exit_code, stdout, stderr)``` tuple.\"\"\"\n        with ProcHelper(command, **popen_kwargs) as proc:\n            return proc.wait(input_string)\n\n\ndef exec_wrapper_cmd(exec_with, cmd_list):\n    wrapper = []\n    if exec_with == 'cabal':\n        wrapper = ['cabal', 'exec', cmd_list[0]]\n    elif exec_with == 'cabal-new-build':\n        wrapper = ['cabal', 'new-run', 'exe:' + cmd_list[0]]\n    elif exec_with == 'stack':\n        wrapper = ['stack', 'exec', cmd_list[0]]\n    else:\n        errmsg = 'ProcHelper.exec_wrapper_cmd: Unknown execution prefix \\'{0}\\''.format(exec_with)\n        raise RuntimeError(errmsg)\n\n    return wrapper + ['--'] + cmd_list[1:] if cmd_list[1:] else wrapper\n\ndef exec_with_wrapper(exec_with, install_dir, cmd_list):\n    '''Wrapper function for inserting the execution wrapper, e.g., 'cabal exec' or 'stack exec'\n\n    :returns: Process object from ProcHelper.\n    '''\n\n    proc_args = {}\n    if exec_with is not None:\n        cmd_list = exec_wrapper_cmd(exec_with, cmd_list)\n        if install_dir is not None:\n            proc_args['cwd'] = Utils.normalize_path(install_dir)\n        else:\n            raise RuntimeError('ProcHelper.exec_with_wrapper: invalid install_dir (None)')\n    else:\n        cmd = Which.which(cmd_list[0], ProcHelper.get_extended_path())\n        if cmd is not None:\n            cmd_list[0] = cmd\n\n    Logging.log('ProcHelper.exec_with_wrapper: {0} in {1}'.format(cmd_list, proc_args.get('cwd')), Logging.LOG_DEBUG)\n    return ProcHelper(cmd_list, **proc_args)\n\n\ndef get_source_dir(filename):\n    '''Get root of hs-source-dirs for filename in project.\n    '''\n    if not filename:\n        return os.path.expanduser('~')\n\n    cabal_dir, cabal_proj = Common.locate_cabal_project(filename)\n    if not cabal_dir:\n        return os.path.dirname(filename)\n    else:\n        proj_info = CabalReader.CabalProjectReader(cabal_dir, cabal_proj)\n        cabal_info = proj_info.cabal_info\n        dirs = ['.']\n\n        executables = cabal_info.get('executable', {})\n        dirs.extend([sdir.strip()\n                     for exe in executables\n                     for sdirs in executables[exe].get('hs-source-dirs', [])\n                     for sdir in sdirs.split(',')])\n        dirs.extend([sdir.strip()\n                     for sdirs in cabal_info.get('library', {}).get('hs-source-dirs', [])\n                     for sdir in sdirs.split(',')])\n\n        paths = [os.path.abspath(os.path.join(cabal_dir, srcdirs)) for srcdirs in set(dirs)]\n        paths.sort(key=lambda p: -len(p))\n\n        for path in paths:\n            if filename.startswith(path):\n                return path\n\n    return os.path.dirname(filename)\n",
  "line_no": 85,
  "line_no_percent": "42%"
}