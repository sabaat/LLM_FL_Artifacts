{
  "instruction": "Compare tasmin, tas, tasmax in a timeseries of GeoTiff files. The code includes functions to rasterize, sort files, and calculate the mean of the full domain. The code is set up to compare downscaled climate data to old climate data for the historical period. The output is a plot of the mean temperature or precipitation for the specified time period. The output is saved as a PNG file.",
  "buggy_code": "def transform_from_latlon( lat, lon ):\n\t''' simple way to make an affine transform from lats and lons coords '''\n\tfrom affine import Affine\n\tlat = np.asarray( lat )\n\tlon = np.asarray(lon)\n\ttrans = Affine.translation(lon[0], lat[0])\n\tscale = Affine.scale(lon[1] - lon[0], lat[1] - lat[0])\n\treturn trans * scale\ndef rasterize( shapes, coords, latitude='latitude', longitude='longitude', fill=None, **kwargs ):\n\t'''\n\tRasterize a list of (geometry, fill_value) tuples onto the given\n\txarray coordinates. This only works for 1d latitude and longitude\n\tarrays.\n\t'''\n\tfrom rasterio import features\n\tif fill == None:\n\t\tfill = np.nan\n\ttransform = transform_from_latlon( coords[ latitude ], coords[ longitude ] )\n\tout_shape = ( len( coords[ latitude ] ), len( coords[ longitude ] ) )\n\traster = features.rasterize(shapes, out_shape=out_shape,\n\t\t\t\t\t\t\t\tfill=fill, transform=transform,\n\t\t\t\t\t\t\t\tdtype=float, **kwargs)\n\tspatial_coords = {latitude: coords[latitude], longitude: coords[longitude]}\n\treturn xr.DataArray(raster, coords=spatial_coords, dims=(latitude, longitude))\n\ndef sort_files( files, split_on='_', elem_month=-2, elem_year=-1 ):\n\treturn\n\t'''\n\tsort a list of files properly using the month and year parsed\n\tfrom the filename.  This is useful with SNAP data since the standard\n\tis to name files like '<prefix>_MM_YYYY.tif'.  If sorted using base\n\tPythons sort/sorted functions, things will be sorted by the first char\n\tof the month, which makes thing go 1, 11, ... which sucks for timeseries\n\tthis sorts it properly following SNAP standards as the default settings.\n\n\tARGUMENTS:\n\t----------\n\tfiles = [list] list of `str` pathnames to be sorted by month and year. usually from glob.glob.\n\tsplit_on = [str] `str` character to split the filename on.  default:'_', SNAP standard.\n\telem_month = [int] slice element from resultant split filename list.  Follows Python slicing syntax.\n\t\tdefault:-2. For SNAP standard.\n\telem_year = [int] slice element from resultant split filename list.  Follows Python slicing syntax.\n\t\tdefault:-1. For SNAP standard.\n\n\tRETURNS:\n\t--------\n\tsorted `list` by month and year ascending. \n\n\t'''\n\timport pandas as pd\n\tmonths = [ int(os.path.basename( fn ).split('.')[0].split( split_on )[elem_month]) for fn in files ]\n\tyears = [ int(os.path.basename( fn ).split('.')[0].split( split_on )[elem_year]) for fn in files ]\n\tdf = pd.DataFrame( {'fn':files, 'month':months, 'year':years} )\n\tdf_sorted = df.sort_values( ['year', 'month' ] )\n\treturn df_sorted.fn.tolist()\ndef only_years( files, begin=1901, end=2100, split_on='_', elem_year=-1 ):\n\t'''\n\treturn new list of filenames where they are truncated to begin:end\n\n\tARGUMENTS:\n\t----------\n\tfiles = [list] list of `str` pathnames to be sorted by month and year. usually from glob.glob.\n\tbegin = [int] four digit integer year of the begin time default:1901\n\tend = [int] four digit integer year of the end time default:2100\n\tsplit_on = [str] `str` character to split the filename on.  default:'_', SNAP standard.\n\telem_year = [int] slice element from resultant split filename list.  Follows Python slicing syntax.\n\t\tdefault:-1. For SNAP standard.\n\n\tRETURNS:\n\t--------\n\tsliced `list` to begin and end year.\n\t'''\n\timport pandas as pd\n\tyears = [ int(os.path.basename( fn ).split('.')[0].split( split_on )[elem_year]) for fn in files ]\n\tdf = pd.DataFrame( { 'fn':files, 'year':years } )\n\tdf_slice = df[ (df.year >= begin ) & (df.year <= end ) ]\n\treturn df_slice.fn.tolist()\ndef masked_mean( fn, bounds=None ):\n\t''' get mean of the full domain since the data are already clipped \n\tmostly used for processing lots of files in parallel.'''\n\timport numpy as np\n\timport rasterio\n\t\t\n\twith rasterio.open( fn ) as rst:\n\t\tif bounds:\n\t\t\twindow = rst.window( *bounds )\n\t\telse:\n\t\t\twindow = rst.window( *rst.bounds )\n\t\tmask = (rst.read_masks( 1 ) == 0)\n\t\tarr = np.ma.masked_array( rst.read( 1, window=window ), mask=mask )\n\treturn np.mean( arr )\n\nif __name__ == '__main__':\n\timport os, glob\n\timport geopandas as gpd\n\timport numpy as np\n\timport xarray as xr\n\timport matplotlib\n\tmatplotlib.use( 'agg' )\n\tfrom matplotlib import pyplot as plt\n\tfrom pathos.mp_map import mp_map\n\timport pandas as pd\n\timport geopandas as gpd\n\t\n\tbase_dir = '/workspace/Shared/Tech_Projects/EPSCoR_Southcentral/project_data'\n\tos.chdir( base_dir )\n\tscenarios = ['historical']\n\tshp_fn = '/workspace/Shared/Tech_Projects/EPSCoR_Southcentral/project_data/SCTC_studyarea/Kenai_StudyArea.shp'\n\tshp = gpd.read_file( shp_fn )\n\tbounds = shp.bounds\n\n\tmodels = ['ts323']\n\tvariables_list = [['pr']]# ['tasmax', 'tas', 'tasmin']]#,\n\tbegin_end_groups = [[1916, 1916],[1950, 1960],[1995, 2000]]\n\n\tfor scenario in scenarios:\n\t\tfor variables in variables_list:\n\t\t\tfor m in models:\n\t\t\t\tfor begin, end in begin_end_groups: # not fully wired-up yet\n\t\t\t\t\tif m == 'ts323':\n\t\t\t\t\t\told_dir = '/Data/Base_Data/Climate/AK_CAN_2km/historical/CRU/CRU_TS32'\n\n\t\t\t\t\telse:\n\t\t\t\t\t\tif scenario == 'historical':\n\t\t\t\t\t\t\told_dir = '/Data/Base_Data/Climate/AK_CAN_2km/historical/AR5_CMIP5_models'\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\told_dir = '/Data/Base_Data/Climate/AK_CAN_2km/projected/AR5_CMIP5_models'\n\n\t\t\t\t\tfigsize = (16,9)\n\t\t\t\t\tout = {}\n\t\t\t\t\tfor v in variables:\n\t\t\t\t\t\tpath = os.path.join( base_dir,'downscaled', m, scenario, v )\n\t\t\t\t\t\tprint( path )\n\t\t\t\t\t\tfiles = glob.glob( os.path.join( path, '*.tif' ) )\n\t\t\t\t\t\tfiles = sort_files( only_years( files, begin=begin, end=end, split_on='_', elem_year=-1 ) )\n\t\t\t\t\t\tout[ v ] = mp_map( masked_mean, files, nproc=4 )\n\t\t\t\t\t\tif v == 'tas' or v == 'pr':\n\t\t\t\t\t\t\tif m == 'ts323':\n\t\t\t\t\t\t\t\tpath = os.path.join( old_dir, v )\n\t\t\t\t\t\t\t\tprint( path )\n\t\t\t\t\t\t\telse:\t\n\t\t\t\t\t\t\t\tpath = os.path.join( old_dir, scenario, m, v )\n\n\t\t\t\t\t\t\tfiles = glob.glob( os.path.join( path, '*.tif' ) )\n\t\t\t\t\t\t\tfiles = sort_files( only_years( files, begin=begin, end=end, split_on='_', elem_year=-1 ) )\n\t\t\t\t\t\t\tout[ v+'_old' ] = mp_map( masked_mean, files, nproc=4 )\n\n\t\t\t\t\t\t\tpath = os.path.join( base_dir,'downscaled_pr_nofix', m, scenario, v )\n\t\t\t\t\t\t\tprint( path )\n\t\t\t\t\t\t\tfiles = glob.glob( os.path.join( path, '*.tif' ) )\n\t\t\t\t\t\t\tfiles = sort_files( only_years( files, begin=begin, end=end, split_on='_', elem_year=-1 ) )\n\t\t\t\t\t\t\tout[ v+'_nofix' ] = mp_map( masked_mean, files, nproc=4 )\n\t\t\t\t\t\t\t\n\t\t\t\t\tplot_df = pd.DataFrame( out )\n\t\t\t\t\tplot_df.index = pd.date_range( start=str(begin), end=str(end+1), freq='M' )\n\t\t\t\t\t\n\t\t\t\t\tif 'tas' in variables:\n\t\t\t\t\t\tcol_list = ['tasmax', 'tas_old', 'tas', 'tasmin']\n\t\t\t\t\telif 'pr' in variables:\n\t\t\t\t\t\tcol_list = ['pr', 'pr_old', 'pr_nofix']\n\t\t\t\t\t\n\t\t\t\t\tplot_df = plot_df[ col_list ] # get em in the order for plotting\n\n\t\t\t\t\tif v == 'pr':\n\t\t\t\t\t\tplot_df = plot_df.round()[['pr','pr_old']]\n\n\t\t\t\t\tif begin == end:\n\t\t\t\t\t\ttitle = 'EPSCoR SC AOI Temp Metrics {} {} {}'.format( m, scenario, begin )\n\t\t\t\t\telse:\n\t\t\t\t\t\ttitle = 'EPSCoR SC AOI Temp Metrics {} {} {} - {}'.format( m, scenario, begin, end )\n\n\t\t\t\t\tif 'tas' in variables:\n\t\t\t\t\t\tcolors = ['red', 'black', 'blue', 'red' ]\n\t\t\t\t\telse:\n\t\t\t\t\t\tcolors = [ 'blue', 'black', 'darkred' ]\n\n\t\t\t\t\tax = plot_df.plot( kind='line', title=title, figsize=figsize, color=colors )\n\n\t\t\t\t\toutput_dir = os.path.join( base_dir, 'compare_downscaling_versions_PR_no_fix' )\n\t\t\t\t\tif not os.path.exists( output_dir ):\n\t\t\t\t\t\tos.makedirs( output_dir )\n\n\t\t\t\t\tout_metric_fn = 'temps'\n\t\t\t\t\tif 'pr' in variables:\n\t\t\t\t\t\tout_metric_fn = 'prec'\n\n\t\t\t\t\tif begin == end:\n\t\t\t\t\t\toutput_filename = os.path.join( output_dir,'mean_{}_epscor_sc_{}_{}_{}.png'.format( out_metric_fn, m, scenario, begin ) )\n\t\t\t\t\telse:\n\t\t\t\t\t\toutput_filename = os.path.join( output_dir,'mean_{}_epscor_sc_{}_{}_{}_{}.png'.format( out_metric_fn, m, scenario, begin, end ) )\n\t\t\t\t\tplt.savefig( output_filename, dpi=400 )\n\t\t\t\t\tplt.close()\n",
  "line_no": 27,
  "line_no_percent": "14%"
}