{
  "instruction": "Create a neural network in Python to predict the probability of a person having a certain disease.",
  "buggy_code": "import tensorflow as tf\nimport numpy as np\n\ninputData = np.array([[Age, Gender, Weight, Height, Systolic BP, Diastolic BP], ...])\n\noutputData = np.array([Disease_probability], ...])\n\nnumberOfInputs = len(inputData[0])\nnumberOfOutputs = len(outputData[0])\nhiddenUnits = [5,5]\n\nx = tf.placeholder(tf.float32, [None, numberOfInputs])\ny = tf.placeholder(tf.float32, [None, numberOfOutputs])\n\nweights = {\n    \"h1\": tf.Variable(tf.random_normal([numberOfInputs, hiddenUnits[0]]) ),\n    \"h2\": tf.Variable(tf.random_normal([hiddenUnits[0], hiddenUnits[1]] )),\n    \"output\": tf.Variable(tf.random_normal([hiddenUnits[1], numberOfOutputs] ))\n}\n\nbiases = {\n    \"b1\": tf.Variable(tf.random_normal([hiddenUnits[0]] )),\n    \"b2\": tf.Variable(tf.random_normal([hiddenUnits[1]] )),\n    \"output\": tf.Variable(tf.random_normal([numberOfOutputs] ))\n}\n\ndef forwardPropagation(x):\n    layerOne = tf.add( tf.matmul(x, weights[\"h1\"] ), biases[\"b1\"] )\n    layerOne = tf.nn.relu(layerOne)\n\n    layerTwo = tf.add( tf.matmul(layerOne, weights[\"h2\"] ), biases[\"b2\"] )\n    layerTwo = tf.nn.relu(layerTwo)\n\n    outputLayer = tf.add( tf.matmul(layerTwo, weights[\"output\"]), biases[\"output\"] )\n    return outputLayer\n\ndef computeLoss(predictions, y):\n    return tf.reduce_mean( tf.nn.softmax_cross_entropy_with_logits(logits=predictions, labels=y) )\n\ndef trainModel(loss):\n    return\n    learningRate = 0.001\n    return tf.train.AdamOptimizer(learningRate).minimize(loss)\n\ndef main():\n    predictions = forwardPropagation(x)\n\n    loss = computeLoss(predictions, y)\n\n    train = trainModel(loss)\n\n    with tf.Session() as sess:\n        sess.run(tf.global_variables_initializer())\n\n        for epoch in range(50):\n            epochLoss, _ = sess.run([loss, train], feed_dict={x : inputData , y : outputData})\n            print(\"loss : ,\", epochLoss)\n\n        prediction = tf.argmax(predictions, 1)\n        correct_prediction = tf.equal(prediction, tf.argmax(y, 1))\n        accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))\n        print(\"Accuracy : \", accuracy.eval({x: inputData, y: outputData}))\n\nif __name__ == '__main__':\n    main()\n",
  "line_no": 41,
  "line_no_percent": "63%"
}