{
  "instruction": "The given code contains several functions for reconciling gene trees to a species tree. To reconcile a gene tree to a MUL-tree, use the \"mulRecon\" function. This function takes in a MUL-tree and a dictionary of gene trees, and returns the minimum score and the corresponding mapping for each gene tree. To collapse groups in the gene trees before reconciling, use the \"collapseGroups\" function. This function takes in the MUL-tree, a dictionary of gene trees, and some other parameters, and returns a dictionary of collapsed groups for each gene tree. Finally, the \"reconLCA\" function is the main algorithmic function for LCA reconciliation mapping. It takes in a gene tree, a species tree, and some other parameters, and returns the minimum score and the corresponding mapping.",
  "buggy_code": "import os, itertools, recontree as RT, mul_tree as MT, reconcore as RC, gene_tree as GT, global_vars as globs\nimport pickle\n\n\ndef reconLCA(lca_ginfo, sinfo, lca_maps, retmap=False):\n\n\tinternal_nodes = RT.sortNodes(lca_ginfo);\n\n\tscore = 0;\n\n\tif retmap:\n\t\tdups, losses = {}, {};\n\t\tfor g in lca_ginfo:\n\t\t\tdups[g], losses[g] = 0, 0;\n\n\tfor g in internal_nodes:\n\t\tg = \"<\" + str(g) + \">\";\n\t\td1, d2 = RT.getDesc(g, lca_ginfo);\n\t\tis_dup = 0;\n\t\tg_clade = RT.getClade(g, lca_ginfo);\n\t\tclade_maps = [];\n\t\tfor g_tip in g_clade:\n\t\t\tclade_maps.append(lca_maps[g_tip][0]);\n\n\t\tlca_maps[g].append(RT.LCA(clade_maps,sinfo)[0]);\n\n\t\tif lca_maps[g][0] == lca_maps[d1][0] or lca_maps[g][0] == lca_maps[d2][0]:\n\t\t\tif retmap:\n\t\t\t\tdups[g] += 1;\n\t\t\tscore += 1;\n\t\t\tis_dup = 1;\n\n\t\tcur_depth = len(RT.nodeDepth(lca_maps[g][0],sinfo))\n\n\t\tif lca_ginfo[g][2] == 'root':\n\t\t\tif retmap:\n\t\t\t\tlosses[g] += cur_depth;\n\t\t\tscore += cur_depth;\n\n\t\td1_depth = len(RT.nodeDepth(lca_maps[d1][0],sinfo));\n\t\td1_loss = (d1_depth - cur_depth - 1) + is_dup;\n\t\tscore += d1_loss\n\t\tif retmap:\n\t\t\tlosses[d1] += d1_loss;\n\n\t\td2_depth = len(RT.nodeDepth(lca_maps[d2][0],sinfo))\n\t\td2_loss = (d2_depth - cur_depth - 1) + is_dup;\n\t\tscore += d2_loss;\n\t\tif retmap:\n\t\t\tlosses[d2] += d2_loss;\n\n\tif retmap:\n\t\treturn lca_maps, dups, losses;\n\treturn score;\n\ndef getSis(gs_node, check_node, check_clade, gs_dict):\n\n\td1, d2 = RT.getDesc(gs_node, gs_dict);\n\tif d1 == check_node:\n\t\tsis_node = d2;\n\telif d2 == check_node:\n\t\tsis_node = d1;\n\n\tsis_clade = RT.getClade(sis_node, gs_dict);\n\tif any(c in check_clade for c in sis_clade):\n\t\treturn [];\n\telse:\n\t\treturn sis_clade;\n\ndef collapseGroups(mul_input, gene_trees_filtered_cg, spec_type_cg, v, pickle_dir, nmt):\n\n\tmul_num, mul_tree = mul_input;\n\t\n\tif v == 1:\n\t\tprint(\"# \" + RC.getDateTime() + \" --> Collapsing groups for MUL-tree # \" + str(mul_num) + \" / \" + str(nmt));\n\n\tif mul_num == 0:\n\t\treturn mul_num, [];\n\n\tgt_groups = {};\n\n\tmt, minfo, hybrid_clade, hybrid_node, copy_node = mul_tree[0], mul_tree[1], mul_tree[2], mul_tree[3], mul_tree[4];\n\n\tfor gene_num in gene_trees_filtered_cg:\n\t\tgene_tree = gene_trees_filtered_cg[gene_num];\n\t\tif len(gene_tree) == 1:\n\t\t\tcontinue;\n\n\t\tgt,ginfo = gene_tree;\n\t\tinternal_nodes = RT.sortNodes(ginfo);\n\n\t\tsingles, groups = {}, {};\n\n\t\tfor g in ginfo:\n\t\t\tif ginfo[g][2] == 'tip':\n\t\t\t\tif g[g.rfind(\"_\")+1:] in hybrid_clade:\n\t\t\t\t\tcur_anc = ginfo[g][1];\n\t\t\t\t\tanc_clade = RT.getClade(cur_anc, ginfo);\n\t\t\t\t\tanc_clade.remove(g);\n\t\t\t\t\tsingles[g] = anc_clade;\n\n\t\tfor g in internal_nodes:\n\t\t\tg = \"<\" + str(g) + \">\";\n\n\t\t\td1, d2 = RT.getDesc(g, ginfo);\n\t\t\td1_clade = RT.getClade(d1, ginfo);\n\t\t\td1_spec_clade = [spec[spec.rfind(\"_\")+1:] for spec in d1_clade];\n\t\t\td2_clade = RT.getClade(d2,ginfo);\n\t\t\td2_spec_clade = [spec[spec.rfind(\"_\")+1:] for spec in d2_clade];\n\n\t\t\tif all(s in hybrid_clade for s in d1_spec_clade) and all(s in hybrid_clade for s in d2_spec_clade):\n\t\t\t\tif not any(s in d2_spec_clade for s in d1_spec_clade):\n\t\t\t\t\tcur_clade = RT.getClade(g, ginfo);\n\t\t\t\t\tcur_anc = ginfo[g][1];\n\t\t\t\t\tanc_clade = RT.getClade(cur_anc, ginfo);\n\t\t\t\t\tanc_clade = [spec for spec in anc_clade if spec not in cur_clade];\n\n\t\t\t\t\tcur_nodes = RT.getCladeNode(g, ginfo);\n\t\t\t\t\tfor node in cur_nodes:\n\t\t\t\t\t\tif node in groups:\n\t\t\t\t\t\t\tdel groups[node];\n\n\t\t\t\t\tgroups[g] = [cur_clade, anc_clade];\n\n\t\tfor group in groups:\n\t\t\tfor g in groups[group][0]:\n\t\t\t\tif g in singles:\n\t\t\t\t\tdel singles[g];\n\n\t\tfinal_groups = [];\n\t\tfor node in groups:\n\t\t\tfinal_groups.append(groups[node]);\n\t\tfor single in singles:\n\t\t\tfinal_groups.append([[single], singles[single]]);\n\n\t\tsisters = {};\n\n\t\tif spec_type_cg == 's':\n\t\t\tmul_hybrid_node = [n for n in minfo if set(RT.getClade(n, minfo)) == set(hybrid_clade)][0];\n\t\t\tcopy_clade = [c + \"*\" for c in hybrid_clade];\n\t\t\tmul_copy_node = [n for n in minfo if set(RT.getClade(n, minfo)) == set(copy_clade)][0];\n\t\telif spec_type_cg == 'm':\n\t\t\tcopy_clade = RT.getClade(copy_node, minfo);\n\t\t\tmul_hybrid_node = hybrid_node;\n\t\t\tmul_copy_node = copy_node;\n\n\t\thybrid_anc = minfo[mul_hybrid_node][1];\n\t\tcopy_anc = minfo[mul_copy_node][1];\n\n\t\tsisters[''] = getSis(hybrid_anc, mul_hybrid_node, copy_clade, minfo);\n\t\tsisters['*'] = getSis(copy_anc, mul_copy_node, hybrid_clade, minfo);\n\n\t\tgroups, fixed_groups = [], [];\n\n\t\tfor group in final_groups:\n\t\t\tgroup_sis = [spec[spec.rfind(\"_\")+1:] for spec in group[1]];\n\t\t\tif group_sis == []:\n\t\t\t\tgroups.append(group[0]);\n\t\t\t\tcontinue;\n\n\t\t\tif all(spec in sisters[''] for spec in group_sis):\n\t\t\t\tfixed_groups.append([group[0],'']);\n\t\t\telif all(spec in sisters['*'] for spec in group_sis):\n\t\t\t\tfixed_groups.append([group[0],'*']);\n\t\t\telse:\n\t\t\t\tgroups.append(group[0]);\n\n\t\tgt_groups[gene_num] = [groups, fixed_groups];\n\n\tgroupoutfile = os.path.join(pickle_dir, str(mul_num) + \"_groups.pickle\");\n\tpickle.dump(gt_groups, open(groupoutfile, \"wb\"));\n\tdel groups, fixed_groups, final_groups, gene_trees_filtered_cg, gt_groups;\n\ndef mulRecon(mul_input, gene_trees, v, pickle_dir, nmt, retmap=False):\n\n\treturn\n\tmul_num, mul_tree = mul_input\n\n\tif v == 1:\n\t\tprint(\"# \" + RC.getDateTime() + \" --> Reconciling to MUL-tree # \" + str(mul_num) + \" / \" + str(nmt));\n\n\tmin_maps = {};\n\ttotal_score = 0;\n\n\tif mul_num != 0:\n\t\tgroupfilename = os.path.join(pickle_dir, str(mul_num) + \"_groups.pickle\");\n\t\tcur_groups = pickle.load(open(groupfilename, \"rb\"));\n\n\tfor gene_num, gene_tree in gene_trees.items():\n\t\tgt, ginfo = gene_tree;\n\n\t\tgene_score = 99999;\n\t\tmin_maps[gene_num] = [];\n\n\t\tif mul_num == 0:\n\t\t\tsinfo = mul_tree[1];\n\n\t\t\tinit_maps = {};\n\t\t\tfor g in ginfo:\n\t\t\t\tif ginfo[g][2] == 'tip':\n\t\t\t\t\tspeclabel = g[g.rfind(\"_\")+1:];\n\t\t\t\t\tinit_maps[g] = [speclabel];\n\t\t\t\telse:\n\t\t\t\t\tinit_maps[g] = [];\n\n\t\t\tif retmap:\n\t\t\t\tmaps, node_dups, node_loss = reconLCA(ginfo, sinfo, init_maps, retmap);\n\t\t\t\tnum_dups = sum(node_dups.values());\n\t\t\t\tnum_loss = sum(node_loss.values());\n\t\t\t\tgene_score = num_dups + num_loss;\n\t\t\t\tmin_maps[gene_num].append([gene_score, num_dups, num_loss, maps, node_dups, node_loss]);\n\t\t\telse:\n\t\t\t\tgene_score = reconLCA(ginfo, sinfo, init_maps);\n\n\t\t\ttotal_score += gene_score;\n\n\t\telse:\n\t\t\tmt, minfo, hybrid_clade, hybrid_node, copy_node, = mul_tree[0], mul_tree[1], mul_tree[2], mul_tree[3], mul_tree[4];\n\n\t\t\tgt_groups, gt_fixed = cur_groups[gene_num][0], cur_groups[gene_num][1];\n\n\t\t\tnum_groups = len(gt_groups);\n\n\t\t\tfor combo in itertools.product(['','*'], repeat=num_groups):\n\t\t\t\tgroup_map = [];\n\t\t\t\tfor i in range(len(combo)):\n\t\t\t\t\tfor node in gt_groups[i]:\n\t\t\t\t\t\tgroup_map.append(node + combo[i]);\n\n\t\t\t\tfor fixed in gt_fixed:\n\t\t\t\t\tfor node in fixed[0]:\n\t\t\t\t\t\tgroup_map.append(node + fixed[1]);\n\n\t\t\t\tmaps = {};\n\t\t\t\tfor g in ginfo:\n\t\t\t\t\tif ginfo[g][2] == 'tip':\n\t\t\t\t\t\tspeclabel = g[g.rfind(\"_\")+1:];\n\t\t\t\t\t\tif g in group_map:\n\t\t\t\t\t\t\tmaps[g] = [speclabel];\n\t\t\t\t\t\telif g + \"*\" in group_map:\n\t\t\t\t\t\t\tmaps[g] = [speclabel + \"*\"];\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tmaps[g] = [speclabel];\n\n\t\t\t\t\telse:\n\t\t\t\t\t\tmaps[g] = [];\n\n\t\t\t\tif retmap:\n\t\t\t\t\tmaps, node_dups, node_loss = reconLCA(ginfo, minfo, maps, retmap);\n\t\t\t\t\tnum_dups = sum(node_dups.values());\n\t\t\t\t\tnum_loss = sum(node_loss.values());\n\t\t\t\t\tcur_score = num_dups + num_loss;\n\t\t\t\t\tif cur_score <= gene_score:\n\t\t\t\t\t\tif cur_score < gene_score:\n\t\t\t\t\t\t\tgene_score = cur_score;\n\t\t\t\t\t\t\tmin_maps[gene_num] = [];\n\t\t\t\t\t\tmin_maps[gene_num].append([gene_score, num_dups, num_loss, maps, node_dups, node_loss])\n\t\t\t\telse:\n\t\t\t\t\tcur_score = reconLCA(ginfo, minfo, maps);\n\t\t\t\t\tif cur_score < gene_score:\n\t\t\t\t\t\tgene_score = cur_score;\n\n\t\t\ttotal_score += gene_score;\n\n\tif retmap:\n\t\treturn min_maps;\n\telse:\n\t\treturn mul_num, total_score;\n",
  "line_no": 176,
  "line_no_percent": "66%"
}