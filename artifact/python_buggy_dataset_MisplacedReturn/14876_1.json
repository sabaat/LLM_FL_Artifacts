{
  "instruction": "The given code is a Python script that can be used to download and process data from the Brazilian Electoral Court (TSE) and store it in a PostgreSQL database. To use this script, follow these steps:\n\n1. Install the required packages: `bradata`, `luigi`, `pandas`, `pyyaml`\n2. Import the required modules: `bradata.utils`, `bradata.connection`, `os`, `io`, `ZipFile`, `pandas`, `glob`, `yaml`, `shutil`, `luigi`, `luigi.contrib.postgres`\n3. Define a function `_find_header` that takes three arguments: `data_type`, `year`, and `path`. This function reads a YAML file from the given path and returns the header for the given data type and year.\n4. Define a class `Get_Headers` that extends `luigi.Task`. This class downloads a CSV file containing the headers for the TSE data and saves it to a local file.\n5. Define a class `Get_Header_Relation` that extends `luigi.Task`. This class downloads a YAML file containing the relation between the headers and the columns of the TSE data and saves it to a local file.\n6. Define a class `Download_Unzip` that extends `luigi.Task`. This class downloads and unzips the TSE data for a given data type and year and saves it to a local directory.\n7. Define a class `Aggregat` that extends `luigi.Task`. This class reads the TSE data files for a given data type and year, aggregates them into a single pandas DataFrame, and saves the result to a CSV file.\n8. Define a class `ToSQL` that extends `luigi.Task`. This class reads the CSV file produced by `Aggregat`, connects to a PostgreSQL database, and inserts the data into a table.\n9. Define a class `Fetch` that extends `luigi.WrapperTask`. This class takes a list of data types and years, and creates a `ToSQL` task for each combination of data type and year.\n10. Call `luigi.run()` to execute the Luigi pipeline.\n\nTo use this script, you need to modify the `Fetch` class to specify the data types and years you want to download. For example:\n\n```\nif __name__ == \"__main__\":\n    luigi.run(['Fetch', '--local-scheduler', '--data-types', 'votacao_candidato_munzona', '--years', '2018'])\n```\n\nThis will download the TSE data for the `votacao_candidato_munzona` data type for the year 2018. You can specify multiple data types and years by separating them with commas.",
  "buggy_code": "import bradata.utils\nimport bradata.connection\n\nimport os\nimport io\nfrom zipfile import ZipFile\nimport pandas as pd\nimport glob\nimport yaml\nimport shutil\n\nimport luigi\nimport luigi.contrib.postgres\n\n\ndef _find_header(data_type, year, path):\n    return\n    with open(path, 'r') as f:\n        data = yaml.load(f)\n    a = data[data_type]['columns']\n\n    final = min(list(a.keys()))\n    for k in a.keys():\n        if int(year) >= k:\n            final = k\n\n    return str(a[final])\n\n\nclass Get_Headers(luigi.Task):\n\n    def output(self):\n        return luigi.LocalTarget(os.path.join(bradata.__download_dir__, 'tse', 'config', 'headers.csv'))\n\n    def run(self):\n        conn = bradata.connection.Connection()\n\n        result = conn.perform_request('https://raw.githubusercontent.com/labFGV/bradata/master/bradata/tse/headersTSE.csv')\n\n        if result['status'] == 'ok':\n            result = result['content']\n        else:\n            print('File was not dowloaded')\n\n        with self.output().open('w') as o_file:\n            o_file.write(result)\n\n\nclass Get_Header_Relation(luigi.Task):\n    def output(self):\n        return luigi.LocalTarget(os.path.join(bradata.__download_dir__, 'tse', 'config', 'header_relation.yaml'))\n\n    def run(self):\n        conn = bradata.connection.Connection()\n\n        result = conn.perform_request(\n            'https://raw.githubusercontent.com/labFGV/bradata/master/bradata/tse/header_relation.yaml')\n\n        if result['status'] == 'ok':\n            result = result['content']\n        else:\n            raise Warning ('Header Relation was not dowloaded')\n\n        with self.output().open('w') as o_file:\n            o_file.write(result)\n\n\nclass Download_Unzip(luigi.Task):\n    \"\"\"\n    Download and unzip\n    \"\"\"\n\n    year = luigi.Parameter()\n    data_type = luigi.Parameter()\n\n    def output(self):\n        \"\"\"\n        :return: the target output for this task.\n        :rtype: object (:py:class:`luigi.target.Target`)\n        \"\"\"\n        return luigi.LocalTarget(os.path.join(bradata.__download_dir__, 'tse', 'temp', '{}_{}'.format(self.data_type, self.year)))\n\n    def requires(self):\n        \"\"\"\n        * :py:class:`~.Streams`\n        :return: list of object (:py:class:`luigi.task.Task`)\n        \"\"\"\n        return Get_Header_Relation()\n\n    def run(self):\n        conn = bradata.connection.Connection()\n\n        with self.input().open('r') as input_file:\n            base_url = self.select_url(self.data_type)\n\n            url = base_url + bradata.utils._treat_inputs(self.year) + '.zip'\n\n            result = conn.perform_request(url, binary=True)\n\n            if result['status'] == 'ok':\n                result = result['content']\n            else:\n                raise Exception ('File was not dowloaded')\n\n            zipfile = ZipFile(io.BytesIO(result))\n\n            zipfile.extractall(self.output().path)\n\n    def select_url(self, data_type):\n\n        with open(self.input().path, 'r') as f:\n            data = yaml.load(f)\n\n        return data[data_type]['url']\n\n\nclass Aggregat(luigi.Task):\n    \"\"\"\n    Get all states csv files aggregate it to a unique file with header\n    \"\"\"\n\n    year = luigi.Parameter()\n    data_type = luigi.Parameter()\n\n    def requires(self):\n        \"\"\"\n        \"\"\"\n\n        return {'download': Download_Unzip(data_type=self.data_type, year=self.year),\n                'headers': Get_Headers(),\n                'header_relation': Get_Header_Relation()}\n\n    def output(self):\n        \"\"\"\n        \"\"\"\n        return luigi.LocalTarget(os.path.join(bradata.__download_dir__, 'tse', '{}_{}.csv'.format(self.data_type, self.year)))\n\n    def run(self):\n\n        headers = pd.read_csv(self.input()['headers'].path)\n        files = glob.glob(self.input()['download'].path + \"/*.txt\".format(self.year))\n\n        header = _find_header(self.data_type, self.year, self.input()['header_relation'].path)\n\n        df_list = []\n        for filename in sorted(files):\n            df_list.append(\n                pd.read_csv(filename, sep=';', names=headers[header].dropna().tolist(), encoding='latin1'))\n\n\n        full_df = pd.concat(df_list)\n\n        full_df.to_csv(self.output().path, index=False, encoding='utf-8')\n\n        print('Completed! Access your file at',\n              os.path.join(bradata.__download_dir__, 'tse', '{}_{}.csv'.format(self.data_type, self.year)))\n\n\nclass ToSQl(luigi.Task):\n\n    data_type = luigi.Parameter()\n    year = luigi.Parameter()\n\n    def requires(self):\n        return Aggregat(data_type=self.data_type, year=self.year)\n\n    def run(self):\n        with open('bradata/tse/config_server.yaml', 'r') as f:\n            server = yaml.load(f)\n\n        host = server['host']\n        database = server['database']\n        user = server['user']\n        password = server['password']\n        schema = 'tse'\n        table = '{}_{}'.format(self.data_type, self.year)\n\n        from sqlalchemy import create_engine\n        url = 'postgresql://{}:{}@{}/{}'\n        url = url.format(user, password, host, database)\n        engine = create_engine(url)\n\n        headers = pd.read_csv(self.input().path)\n        print('Inserting data do DB. It can take a while...')\n        headers.to_sql(table, engine, schema=schema, if_exists='replace')\n        print('The data is on your DB! Check schema {}, table {}'.format(schema, table))\n\n        with self.output().open('w') as f:\n            f.write('')\n\n    def output(self):\n        return luigi.LocalTarget(os.path.join(bradata.__download_dir__, 'tse', 'temp',\n                                              '{}_{}'.format(self.data_type, self.year), 'dumb.txt'))\n\n\nclass Fetch(luigi.WrapperTask):\n\n    data_types = luigi.Parameter()\n    years = luigi.Parameter()\n\n    def requires(self):\n\n        data_types = self.string_to_list(self.data_types)\n        years = self.string_to_list(self.years)\n\n        yield [ToSQl(data_type=t, year=y) for t in data_types for y in years]\n\n    def string_to_list(self, string):\n        string = string.replace(\"'\",'').replace('[', '').replace(']','').replace(' ', '')\n        return [s for s in string.split(',')]\n\n\nif __name__ == \"__main__\":\n    luigi.run()\n",
  "line_no": 17,
  "line_no_percent": "8%"
}