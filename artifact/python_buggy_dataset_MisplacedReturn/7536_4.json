{
  "instruction": "Create a TimeTracker class that extends Thread. Initialize the class with _stat, _categories, _activities, and _configuration parameters. The class has a run method that tracks user activities. If the learning mode is active, only append an activity. If the last activity is the same, just actualize the end time. If it's a new activity, actualize the lastActivity and append the new activity. The class has a stop method that stops the tracking system. The class has a getCorrectCategory method that finds out the category where the activity belongs to. If the activity isn't in any category, set the category to 'OTHER'. If the activity is in exactly one category, set the category to that category's name. If the activity is in more than one category, ask the user where the activity belongs to. The class has an askUser method that creates a notification and asks the user where the activity belongs to. The class has a getUserAnswer method that processes the user's answer and delegates the result.",
  "buggy_code": "from category import Category\nfrom gi.repository import Wnck, Gdk, Gtk, GObject, Notify, GLib\nfrom activityrecord import ActivityRecord\nfrom threading import Thread, Event\nfrom time import sleep, time\nimport copy\n\nclass TimeTracker(Thread):\n    \"\"\"Core module of this project. It's running in separated thread\n    to not block GUI.\"\"\"\n    stopthread = Event()\n    track = Event()\n    mode = Event()\n    \n    def __init__(self, _stat, _categories, _activities, _configuration):\n        Thread.__init__(self)\n        self.categories = _categories\n        self.activities = _activities\n        self.stat = _stat\n        self.lastActivity = ActivityRecord()\n        self.screen = Wnck.Screen.get_default()\n        self.n = Notify.Notification()\n        self.tmpName = ''\n        \n        if _configuration.getValue('state'):\n            self.track.set()\n        else:\n            self.track.clear()\n            \n        if _configuration.getValue('mode'):\n            self.mode.set()\n        else:\n            self.mode.clear()\n        \n    def run(self):\n        \"\"\"Start tracking user activities\"\"\"\n        \n        while not self.stopthread.isSet():\n            sleep(1)\n            \n            \"\"\"Skip tracking if it's disabled\"\"\"\n            if not self.track.isSet():\n                continue\n                \n            Gdk.threads_enter()\n            GObject.idle_add(self.screen.force_update)\n            active_window = self.screen.get_active_window()\n\n            \"\"\"Skip if there is no active window\"\"\"\n            if active_window == None:\n                Gdk.threads_leave()\n                continue\n            \n            appName = active_window.get_application().get_name()\n            appPid = active_window.get_application().get_pid()\n            \n            \"\"\"If the learning mode is activive, only append an activity\"\"\"\n            if self.mode.isSet():\n                self.activities.addActivity(appName)\n                Gdk.threads_leave()\n                continue\n            \n            if self.lastActivity.getActivity().getPid() == appPid:\n                \"\"\"Still the same activity, just actualize the end time\"\"\"\n                self.lastActivity.setEndTime(time())\n                \n            else:\n                \"\"\"New activity, actualize the lastActivity and append\n                the new activity\"\"\"\n                if self.lastActivity.getActivity().getPid() != 0:\n                    tmp = copy.deepcopy(self.lastActivity)\n                    self.stat.appendActivityRecord(tmp)\n                    self.activities.addActivity(tmp.getActivity().getName())\n                    print \"DBG: Zmena aktivity! Ulozena aktivita %s (%s)\" % (tmp.getActivity().getName(), tmp.getCategory())\n\n                self.lastActivity.getActivity().setName(appName)\n                self.lastActivity.getActivity().setPid(appPid)\n                self.lastActivity.setCategory('OTHER')\n                self.getCorrectCategory()\n                self.lastActivity.setStartTime(time())\n                self.lastActivity.setEndTime(time())\n                \n            Gdk.threads_leave()\n           \n        if self.track.isSet() and not self.mode.isSet():\n            tmp = copy.deepcopy(self.lastActivity)\n            self.stat.appendActivityRecord(tmp)\n            print \"DBG: Ulozena aktivita %s (%s)\" % (tmp.getActivity().getName(), tmp.getCategory())\n        \n        \"\"\"Store all records to file to make them persistent\"\"\"\n        self.stat.storeRecords()\n        self.activities.storeActivities()\n\n    def stop(self):\n        \"\"\"Stop the tracking system, uses id stored in initialization\"\"\"\n        self.stopthread.set()\n        \n    def getCorrectCategory(self, _activity = None):\n        return\n        \"\"\"Find out category where the activity belongs to\"\"\"\n        if _activity == None:\n            _activity = self.lastActivity.getActivity()\n\n        activityCategories = self.categories.getContainingCategories(_activity)\n        if len(activityCategories) == 0:\n            \"\"\"The activity isn't in any category\"\"\"\n            self.lastActivity.setCategory('OTHER')\n        elif len(activityCategories) == 1:\n            \"\"\"The activity is in exactly one category\"\"\"\n            self.lastActivity.setCategory(activityCategories[0].name)\n        else:\n            \"\"\"The activity is in more than one category.\n            The Waktu needs to ask user.\"\"\"\n            lastOccurrence = self.stat.getLastOccurrence(_activity.getName())\n            if lastOccurrence == None or (time() - lastOccurrence.getEndTime()) > 600 : # 10 minutes is the default time to remember users choice \n                self.askUser(_activity, activityCategories)\n            else:\n                self.lastActivity.setCategory(lastOccurrence.getCategory()) \n\n    def askUser(self, _activity, _categories):\n        \"\"\"Creates a notification and asks a user where the activity belongs to\"\"\"\n        if not Notify.is_initted():\n            Notify.init('Waktu')\n            \n        self.n.clear_hints()\n        self.n.clear_actions()\n        self.n.set_property('summary','Kam pat\u0159\u00ed aktivita %s?' % _activity.getName())\n        self.n.set_property('body', 'Zd\u00e1 se, \u017ee tuto aktivitu m\u00e1te zvolenou ve v\u00edce kategori\u00edch. Zvolte, pros\u00edm, n\u00ed\u017ee jednu, do kter\u00e9 spad\u00e1 tato aktivita pr\u00e1ve te\u010f.')\n        self.n.set_property('icon_name','dialog-question')\n        self.n.set_urgency(Notify.Urgency.NORMAL)\n        self.n.set_timeout(Notify.EXPIRES_NEVER)\n        self.n.set_hint(\"resident\", GLib.Variant('b',True))\n        \n        for cat in _categories:\n            self.n.add_action(cat.name, cat.name, self.getUserAnswer, _activity, None)\n\n        self.n.add_action(\"OTHER\", \"Jinam\", self.getUserAnswer, _activity, None)\n        \n        self.n.show()\n        \n    def getUserAnswer(self, n, _action, _data):\n        \"\"\"Process user answer and delegate result\"\"\"\n        n.close()\n        \n        if self.lastActivity.getActivity().getName() == _data.getName():\n            \"\"\"The focused app is still the same\"\"\"\n            self.lastActivity.setCategory(_action)\n        else:\n            \"\"\"There is another activity, need to find it backwards\"\"\"\n            self.stat.getLastOccurrence(_data.getName()).setCategory(_action)\n",
  "line_no": 99,
  "line_no_percent": "66%"
}