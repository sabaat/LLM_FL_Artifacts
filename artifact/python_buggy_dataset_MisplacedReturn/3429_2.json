{
  "instruction": "Create a Python script that captures video from a camera, detects objects in the video, and sends data to a serial port. The script should import the OpenCV, serial, and struct modules, and use the datetime module to log data. It should define a function to decrease angular resolution, and another function to allow the user to click on the video to set the center for transformation. The script should then open a serial port, set the capture properties for the camera, create images for processing, set the range of colors to detect, and enter a loop to capture frames from the camera. Within the loop, the script should perform various image processing operations, including thresholding, erosion, and dilation, and then scan the top row of the thresholded image to find the number of contiguous segments and their location. The script should then pack the data into a struct and write it to the serial port, and log any data received from the serial port. Finally, the script should display the video and wait for a key press to exit.",
  "buggy_code": "import cv, serial, struct\nfrom datetime import datetime\n\ncyril = serial.Serial('/dev/ttyAMA0', 9600) #open first serial port and give it a good name\nprint \"Opened \"+cyril.portstr+\" for serial access\"\ncenterX = 175 #160\ncenterY = 140 #120\n\ncropped = None\nimg = None\n\ndef derez(x):\n  if( x < 90 ):\n    return (-90-x)/2\n  else:\n    return (270-x)/2\n\ndef on_mouse(event, x, y, flags, param):\n  return\n  if event==cv.CV_EVENT_LBUTTONDOWN:\n    print x, \", \", y, \": \", img[y,x]\n\n\nif __name__ == '__main__':\n  datalog = open(\"data.log\", \"w+\")\n  datalog.write(\"\\n~~~=== Rambler Data Log Opened, \" + str(datetime.now()) + \" ===~~~\\n\")\n\n  capture = cv.CaptureFromCAM(0)\n  cv.SetCaptureProperty(capture, cv.CV_CAP_PROP_FRAME_WIDTH, 320)\n  cv.SetCaptureProperty(capture, cv.CV_CAP_PROP_FRAME_HEIGHT, 240)\n\n  polar = cv.CreateImage((360, 360), 8, 3)\n  cropped = cv.CreateImage((360, 40), 8, 3)\n  img = cv.CreateImage((320, 240), 8, 3)\n  \n  cones = cv.CreateImage((360, 40), 8, 1)\n\n  cv.NamedWindow('cam')\n  cv.NamedWindow('unwrapped')\n  cv.NamedWindow('target')\n  \n  cv.SetMouseCallback('cam', on_mouse)\n  on_mouse(cv.CV_EVENT_LBUTTONDOWN, centerX, centerY, None, None)\n\n  lower = cv.Scalar(40,  90, 170) # (B, G, R)\n  upper = cv.Scalar(80, 180, 255)\n\n\n  M = 69\n\n  while True:\n    img = cv.QueryFrame(capture)\n    cv.LogPolar(img, polar, (centerX, centerY), M+1, cv.CV_INTER_NN) #possible speedup - get subrect src\n    cv.Transpose(cv.GetSubRect(polar,(280,0,40,360)), cropped)\n    cv.Flip(cropped) #just for viewing (possible speedup)\n\n    cv.InRangeS(cropped, lower, upper, cones)\n    \n    cv.Erode(cones, cones) # just once might be too much\n\n    k = cv.CreateStructuringElementEx(3, 43, 1, 1, cv.CV_SHAPE_RECT) # create a 3x43 rectangular dilation element k\n    cv.Dilate(cones, cones, k, 2) \n\n    s = 0 # size of contiguous segment\n    ss = 0 #number of contiguous segments\n    bearingToLandmarks = []\n    for i in xrange(360-2):\n        c = cones[0, i] #current\n        n = cones[0, i+1] #next\n        if (c == 0 and n == 255) or \\\n           (c == 255 and n == 255): # this condition marks beginning or middle of contiguous segment\n            s = s + 1\n        elif (c == 255 and n == 0): # end of contiguous segment\n            ss = ss + 1\n            bearingToLandmarks.append((i-s/2, s))\n            s = 0\n        if (i == 360-2-1 and s != 0): #TODO: double check this offset\n            if (cones[0,0] == 255):\n                bearingToLandmarks[0] = ((bearingToLandmarks[0][0]-s/2)%360, bearingToLandmarks[0][1]+s) #TODO: recalculate center more accurately\n            else:\n                bearingToLandmarks.append((c-s/2, s))\n    print bearingToLandmarks, len(bearingToLandmarks)\n\n    if len(bearingToLandmarks) > 0:\n        output = struct.pack('c','\\xfa') \\\n            + struct.pack('B', 0) \\\n            + struct.pack('b', derez(bearingToLandmarks[0][0]) ) \\\n            + struct.pack('B', 0) \n        cyril.write(output)\n\n    if (cyril.inWaiting() > 0):\n      logdata = cyril.read(cyril.inWaiting())\n      a = 0\n      b = 0\n      for c in logdata:\n        if c == '\\n':\n          datalog.write(str(datetime.now().time())+\",\"+logdata[a:b]+\"\\n\")\n          a = b + 1\n        b = b + 1\n    \n    cv.ShowImage('cam', img)\n    cv.ShowImage('target', cones)\n    cv.ShowImage('unwrapped', cropped)\n\n    key = cv.WaitKey(10) # THIS REQUIRES AT LEAST ONE WINDOW \n    if key > 0:\n        break\n        \n  cv.DestroyAllWindows()\n  cyril.close()\n  datalog.write(\"\\n~~~=== Rambler Data Log Closed, \" + str(datetime.now()) + \" ===~~~\\n\")\n  datalog.close()\n",
  "line_no": 19,
  "line_no_percent": "17%"
}