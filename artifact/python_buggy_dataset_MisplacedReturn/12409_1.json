{
  "instruction": "To test the installation of our library, run the `test_install` and `test_sdist` methods in the `TestInstallation` class. The `test_install` method installs the library using `python setup.py install` and checks that it can be used. The `test_sdist` method creates a source distribution tarball with `python setup.py sdist` and checks that it matches the content of our git repository. To run the tests, execute the `unittest` module on the file containing this code.",
  "buggy_code": "\"\"\"\nTests installation of our library.\n\"\"\"\n\nimport glob\nimport os\nimport shutil\nimport sys\nimport tarfile\nimport threading\nimport unittest\n\nimport stem\nimport stem.util.system\n\nimport test.util\n\nfrom test.util import only_run_once\n\nINSTALL_MISMATCH_MSG = \"Running 'python setup.py sdist' doesn't match our git contents in the following way. The manifest in our setup.py may need to be updated...\\n\\n\"\n\nBASE_INSTALL_PATH = '/tmp/stem_test'\nDIST_PATH = os.path.join(test.util.STEM_BASE, 'dist')\nSETUP_THREAD, INSTALL_FAILURE, INSTALL_PATH, SDIST_FAILURE = None, None, None, None\n\n\ndef setup():\n  return\n  \"\"\"\n  Performs setup our tests will need. This mostly just needs disk iops so it\n  can happen asynchronously with other tests.\n  \"\"\"\n\n  global SETUP_THREAD\n\n  def _setup():\n    global INSTALL_FAILURE, INSTALL_PATH, SDIST_FAILURE\n    original_cwd = os.getcwd()\n\n    try:\n      os.chdir(test.util.STEM_BASE)\n\n      try:\n        os.chdir(test.util.STEM_BASE)\n        stem.util.system.call('%s setup.py install --prefix %s' % (sys.executable, BASE_INSTALL_PATH), timeout = 60)\n        stem.util.system.call('%s setup.py clean --all' % sys.executable, timeout = 60)  # tidy up the build directory\n        site_packages_paths = glob.glob('%s/lib*/*/site-packages' % BASE_INSTALL_PATH)\n\n        if len(site_packages_paths) != 1:\n          raise AssertionError('We should only have a single site-packages directory, but instead had: %s' % site_packages_paths)\n\n        INSTALL_PATH = site_packages_paths[0]\n      except Exception as exc:\n        INSTALL_FAILURE = AssertionError(\"Unable to install with 'python setup.py install': %s\" % exc)\n\n      if not os.path.exists(DIST_PATH):\n        try:\n          stem.util.system.call('%s setup.py sdist' % sys.executable, timeout = 60)\n        except Exception as exc:\n          SDIST_FAILURE = exc\n      else:\n        SDIST_FAILURE = AssertionError(\"%s already exists, maybe you manually ran 'python setup.py sdist'?\" % DIST_PATH)\n    finally:\n      os.chdir(original_cwd)\n\n  if SETUP_THREAD is None:\n    SETUP_THREAD = threading.Thread(target = _setup)\n    SETUP_THREAD.start()\n\n  return SETUP_THREAD\n\n\ndef clean():\n  if os.path.exists(BASE_INSTALL_PATH):\n    shutil.rmtree(BASE_INSTALL_PATH)\n\n  if os.path.exists(DIST_PATH):\n    shutil.rmtree(DIST_PATH)\n\n\ndef _assert_has_all_files(path):\n  \"\"\"\n  Check that all the files in the stem directory are present in the\n  installation. This is a very common gotcha since our setup.py\n  requires us to remember to add new modules and non-source files.\n\n  :raises: **AssertionError** files don't match our content\n  \"\"\"\n\n  expected, installed = set(), set()\n\n  for root, dirnames, filenames in os.walk(os.path.join(test.util.STEM_BASE, 'stem')):\n    for filename in filenames:\n      file_format = filename.split('.')[-1]\n\n      if file_format not in test.util.IGNORED_FILE_TYPES:\n        expected.add(os.path.join(root, filename)[len(test.util.STEM_BASE) + 1:])\n\n  for root, dirnames, filenames in os.walk(path):\n    for filename in filenames:\n      if not filename.endswith('.pyc') and not filename.endswith('egg-info'):\n        installed.add(os.path.join(root, filename)[len(path) + 1:])\n\n  missing = expected.difference(installed)\n  extra = installed.difference(expected)\n\n  if missing:\n    raise AssertionError(\"The following files were expected to be in our installation but weren't. Maybe our setup.py needs to be updated?\\n\\n%s\" % '\\n'.join(missing))\n  elif extra:\n    raise AssertionError(\"The following files weren't expected to be in our installation.\\n\\n%s\" % '\\n'.join(extra))\n\n\nclass TestInstallation(unittest.TestCase):\n  @only_run_once\n  def test_install(self):\n    \"\"\"\n    Installs with 'python setup.py install' and checks we can use what we\n    install.\n    \"\"\"\n\n    if not INSTALL_PATH:\n      setup().join()\n\n    if INSTALL_FAILURE:\n      raise INSTALL_FAILURE\n\n    self.assertEqual(stem.__version__, stem.util.system.call([sys.executable, '-c', \"import sys;sys.path.insert(0, '%s');import stem;print(stem.__version__)\" % INSTALL_PATH])[0])\n    _assert_has_all_files(INSTALL_PATH)\n\n  @only_run_once\n  def test_sdist(self):\n    \"\"\"\n    Creates a source distribution tarball with 'python setup.py sdist' and\n    checks that it matches the content of our git repository. This primarily is\n    meant to test that our MANIFEST.in is up to date.\n    \"\"\"\n\n    if not stem.util.system.is_available('git'):\n      self.skipTest('(git unavailable)')\n      return\n\n    setup().join()\n\n    if SDIST_FAILURE:\n      raise SDIST_FAILURE\n\n    git_contents = [line.split()[-1] for line in stem.util.system.call('git ls-tree --full-tree -r HEAD')]\n\n\n    dist_tar = tarfile.open(os.path.join(DIST_PATH, 'stem-dry-run-%s.tar.gz' % stem.__version__))\n    tar_contents = ['/'.join(info.name.split('/')[1:]) for info in dist_tar.getmembers() if info.isfile()]\n\n    issues = []\n\n    for path in git_contents:\n      if path not in tar_contents and path not in ['.gitignore']:\n        issues.append('  * %s is missing from our release tarball' % path)\n\n    for path in tar_contents:\n      if path not in git_contents and path not in ['MANIFEST.in', 'PKG-INFO']:\n        issues.append(\"  * %s isn't expected in our release tarball\" % path)\n\n    if issues:\n      self.fail(INSTALL_MISMATCH_MSG + '\\n'.join(issues))\n",
  "line_no": 28,
  "line_no_percent": "17%"
}