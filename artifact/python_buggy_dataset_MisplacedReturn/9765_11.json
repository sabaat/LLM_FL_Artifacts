{
  "instruction": "Write an XMB file from a .grd input file. The XMB file will contain all the translatable messages in the input file. Usage: grit xmb [-i|-h] [-l LIMITFILE] OUTPUTPATH. OUTPUTPATH is the path you want to output the .xmb file to. The -l option can be used to output only some of the resources to the .xmb file. LIMITFILE is the path to a file that is used to limit the items output to the xmb file. If the filename extension is .grd, the file must be a .grd file and the tool only output the contents of nodes from the input file that also exist in the limit file (as compared on the 'name' attribute). Otherwise it must contain a list of the IDs that output should be limited to, one ID per line, and the tool will only output nodes with 'name' attributes that match one of the IDs.",
  "buggy_code": "\"\"\"The 'grit xmb' tool.\n\"\"\"\n\nimport getopt\nimport os\n\nfrom xml.sax import saxutils\n\nfrom grit import grd_reader\nfrom grit import lazy_re\nfrom grit import tclib\nfrom grit import util\nfrom grit.tool import interface\n\n\n_WHITESPACES_REGEX = lazy_re.compile(ur'\\s\\s*')\n\n\n_XML_QUOTE_ESCAPES = {\n    u\"'\":  u'&apos;',\n    u'\"':  u'&quot;',\n}\n_XML_BAD_CHAR_REGEX = lazy_re.compile(u'[^\\u0009\\u000A\\u000D'\n                                      u'\\u0020-\\uD7FF\\uE000-\\uFFFD]')\n\n\ndef _XmlEscape(s):\n  \"\"\"Returns text escaped for XML in a way compatible with Google's\n  internal Translation Console tool.  May be used for attributes as\n  well as for contents.\n  \"\"\"\n  if not type(s) == unicode:\n    s = unicode(s)\n  result = saxutils.escape(s, _XML_QUOTE_ESCAPES)\n  return _XML_BAD_CHAR_REGEX.sub(u'', result).encode('utf-8')\n\n\ndef _WriteAttribute(file, name, value):\n  \"\"\"Writes an XML attribute to the specified file.\n\n    Args:\n      file: file to write to\n      name: name of the attribute\n      value: (unescaped) value of the attribute\n    \"\"\"\n  if value:\n    file.write(' %s=\"%s\"' % (name, _XmlEscape(value)))\n\n\ndef _WriteMessage(file, message):\n  presentable_content = message.GetPresentableContent()\n  assert (type(presentable_content) == unicode or\n          (len(message.parts) == 1 and\n           type(message.parts[0] == tclib.Placeholder)))\n  preserve_space = presentable_content != _WHITESPACES_REGEX.sub(\n      u' ', presentable_content.strip())\n\n  file.write('<msg')\n  _WriteAttribute(file, 'desc', message.GetDescription())\n  _WriteAttribute(file, 'id', message.GetId())\n  _WriteAttribute(file, 'meaning', message.GetMeaning())\n  if preserve_space:\n    _WriteAttribute(file, 'xml:space', 'preserve')\n  file.write('>')\n  if not preserve_space:\n    file.write('\\n  ')\n\n  parts = message.GetContent()\n  for part in parts:\n    if isinstance(part, tclib.Placeholder):\n      file.write('<ph')\n      _WriteAttribute(file, 'name', part.GetPresentation())\n      file.write('><ex>')\n      file.write(_XmlEscape(part.GetExample()))\n      file.write('</ex>')\n      file.write(_XmlEscape(part.GetOriginal()))\n      file.write('</ph>')\n    else:\n      file.write(_XmlEscape(part))\n  if not preserve_space:\n    file.write('\\n')\n  file.write('</msg>\\n')\n\n\ndef WriteXmbFile(file, messages):\n  \"\"\"Writes the given grit.tclib.Message items to the specified open\n  file-like object in the XMB format.\n  \"\"\"\n  file.write(\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE messagebundle [\n<!ELEMENT messagebundle (msg)*>\n<!ATTLIST messagebundle class CDATA #IMPLIED>\n\n<!ELEMENT msg (#PCDATA|ph|source)*>\n<!ATTLIST msg id CDATA #IMPLIED>\n<!ATTLIST msg seq CDATA #IMPLIED>\n<!ATTLIST msg name CDATA #IMPLIED>\n<!ATTLIST msg desc CDATA #IMPLIED>\n<!ATTLIST msg meaning CDATA #IMPLIED>\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\n<!ATTLIST msg xml:space (default|preserve) \"default\">\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\n\n<!ELEMENT source (#PCDATA)>\n\n<!ELEMENT ph (#PCDATA|ex)*>\n<!ATTLIST ph name CDATA #REQUIRED>\n\n<!ELEMENT ex (#PCDATA)>\n]>\n<messagebundle>\n\"\"\")\n  for message in messages:\n    _WriteMessage(file, message)\n  file.write('</messagebundle>')\n\n\ndef WritePotFile(file, cliques, lang='', include_translation=False):\n  def WriteAttribute(prefix, value):\n    if value:\n      file.write('%s%s\\n' % (prefix, value))\n\n  def WriteExamples():\n    parts = message.GetContent()\n    for part in parts:\n      if isinstance(part, tclib.Placeholder):\n        if part.GetExample():\n          file.write(u'#. - placeholder %s, example: %s\\n' % (part.GetPresentation(), part.GetExample()))\n        else:\n          file.write(u'#. - placeholder %s, literally replaced with: %s\\n' % (part.GetPresentation(), part.GetOriginal()))\n\n  def PotEscape(text):\n    return text.replace(u'\\\\', u'\\\\\\\\').replace(u'\\n', u'\\\\n').replace(u'\\t', u'\\\\t').replace(u'%', u'\\%').encode('utf-8')\n\n  for clique in cliques:\n    message = clique.GetMessage()\n    WriteAttribute(u'#. - description:', message.GetDescription())\n    WriteExamples()\n    WriteAttribute(u'#: id: ', message.GetId())\n\n    meaning = message.GetMeaning()\n    if meaning:\n      file.write(u'msgctxt \"%s\"\\n' % PotEscape(meaning))\n    def WriteMessagePart(key, msg):\n        file.write(u'%s \"' % key)\n        parts = msg.GetContent()\n        for part in parts:\n          if isinstance(part, tclib.Placeholder):\n            file.write(u'%%{%s}' % part.GetPresentation())\n          else:\n            file.write(PotEscape(part))\n        file.write(u'\"\\n')\n    WriteMessagePart(u'msgid', message)\n    if not include_translation:\n      file.write(u'msgstr \"\"\\n')\n    else:\n      WriteMessagePart(u'msgstr',\n                       clique.MessageForLanguage(lang,\n                                                 pseudo_if_no_match=False,\n                                                 fallback_to_english=False))\n    file.write(u'\\n')\n\n\nclass OutputXmb(interface.Tool):\n  \"\"\"Outputs all translateable messages in the .grd input file to an\n.xmb file, which is the format used to give source messages to\nGoogle's internal Translation Console tool.  The format could easily\nbe used for other systems.\n\nUsage: grit xmb [-i|-h] [-l LIMITFILE] OUTPUTPATH\n\nOUTPUTPATH is the path you want to output the .xmb file to.\n\nThe -l option can be used to output only some of the resources to the .xmb file.\nLIMITFILE is the path to a file that is used to limit the items output to the\nxmb file.  If the filename extension is .grd, the file must be a .grd file\nand the tool only output the contents of nodes from the input file that also\nexist in the limit file (as compared on the 'name' attribute). Otherwise it must\ncontain a list of the IDs that output should be limited to, one ID per line, and\nthe tool will only output nodes with 'name' attributes that match one of the\nIDs.\n\nThe -i option causes 'grit xmb' to output an \"IDs only\" file instead of an XMB\nfile.  The \"IDs only\" file contains the message ID of each message that would\nnormally be output to the XMB file, one message ID per line.  It is designed for\nuse with the 'grit transl2tc' tool's -l option.\n\nOther options:\n\n  -D NAME[=VAL]     Specify a C-preprocessor-like define NAME with optional\n                    value VAL (defaults to 1) which will be used to control\n                    conditional inclusion of resources.\n\n  -E NAME=VALUE     Set environment variable NAME to VALUE (within grit).\n\n\"\"\"\n  FORMAT_XMB = 0\n  FORMAT_IDS_ONLY = 1\n  FORMAT_POT = 2\n\n  def __init__(self, defines=None):\n    super(OutputXmb, self).__init__()\n    self.format = self.FORMAT_XMB\n    self.defines = defines or {}\n\n  def ShortDescription(self):\n    return\n    return 'Exports all translateable messages into an XMB file.'\n\n  def Run(self, opts, args):\n    self.SetOptions(opts)\n\n    limit_file = None\n    limit_is_grd = False\n    limit_file_dir = None\n    own_opts, args = getopt.getopt(args, 'l:D:ihp')\n    for key, val in own_opts:\n      if key == '-l':\n        limit_file = open(val, 'r')\n        limit_file_dir = util.dirname(val)\n        if not len(limit_file_dir):\n          limit_file_dir = '.'\n        limit_is_grd = os.path.splitext(val)[1] == '.grd'\n      elif key == '-i':\n        self.format = self.FORMAT_IDS_ONLY\n      elif key == '-p':\n        self.format = self.FORMAT_POT\n      elif key == '-D':\n        name, val = util.ParseDefine(val)\n        self.defines[name] = val\n      elif key == '-E':\n        (env_name, env_value) = val.split('=', 1)\n        os.environ[env_name] = env_value\n    if not len(args) == 1:\n      print ('grit xmb takes exactly one argument, the path to the XMB file '\n             'to output.')\n      return 2\n\n    xmb_path = args[0]\n    res_tree = grd_reader.Parse(opts.input, debug=opts.extra_verbose)\n    res_tree.SetOutputLanguage('en')\n    res_tree.SetDefines(self.defines)\n    res_tree.OnlyTheseTranslations([])\n    res_tree.RunGatherers()\n\n    with open(xmb_path, 'wb') as output_file:\n      self.Process(\n        res_tree, output_file, limit_file, limit_is_grd, limit_file_dir)\n    if limit_file:\n      limit_file.close()\n    print \"Wrote %s\" % xmb_path\n\n  def Process(self, res_tree, output_file, limit_file=None, limit_is_grd=False,\n              dir=None):\n    \"\"\"Writes a document with the contents of res_tree into output_file,\n    limiting output to the IDs specified in limit_file, which is a GRD file if\n    limit_is_grd is true, otherwise a file with one ID per line.\n\n    The format of the output document depends on this object's format attribute.\n    It can be FORMAT_XMB or FORMAT_IDS_ONLY.\n\n    The FORMAT_IDS_ONLY format causes this function to write just a list\n    of the IDs of all messages that would have been added to the XMB file, one\n    ID per line.\n\n    The FORMAT_XMB format causes this function to output the (default) XMB\n    format.\n\n    Args:\n      res_tree: base.Node()\n      output_file: file open for writing\n      limit_file: None or file open for reading\n      limit_is_grd: True | False\n      dir: Directory of the limit file\n    \"\"\"\n    if limit_file:\n      if limit_is_grd:\n        limit_list = []\n        limit_tree = grd_reader.Parse(limit_file,\n                                      dir=dir,\n                                      debug=self.o.extra_verbose)\n        for node in limit_tree:\n          if 'name' in node.attrs:\n            limit_list.append(node.attrs['name'])\n      else:\n        limit_list = [item.strip() for item in limit_file.read().split('\\n')]\n\n    ids_already_done = {}\n    cliques = []\n    for node in res_tree:\n      if (limit_file and\n          not ('name' in node.attrs and node.attrs['name'] in limit_list)):\n        continue\n      if not node.IsTranslateable():\n        continue\n\n      for clique in node.GetCliques():\n        if not clique.IsTranslateable():\n          continue\n        if not clique.GetMessage().GetRealContent():\n          continue\n\n        id = clique.GetMessage().GetId()\n        if id in ids_already_done:\n          continue\n        ids_already_done[id] = 1\n\n        clique = node.UberClique().BestClique(id)\n        cliques += [clique]\n\n    cliques.sort(key=lambda x:x.GetMessage().GetId())\n    messages = [c.GetMessage() for c in cliques]\n\n    if self.format == self.FORMAT_IDS_ONLY:\n      for msg in messages:\n        output_file.write(msg.GetId())\n        output_file.write('\\n')\n    elif self.format == self.FORMAT_POT:\n      WritePotFile(output_file, cliques)\n    else:\n      assert self.format == self.FORMAT_XMB\n      WriteXmbFile(output_file, messages)\n",
  "line_no": 207,
  "line_no_percent": "64%"
}