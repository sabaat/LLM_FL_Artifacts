{
  "instruction": "This code provides classes and functions for working with JSON-style data in Python. To use it, import the necessary classes and functions and create instances of them as needed. The DotDict and DotList classes allow for attribute and index access using dot notation, while the DictModifier class allows for sparse overriding of dictionary values. The dict_merge function merges two dictionaries non-destructively, and the named_any and for_name functions allow for importing and using Python objects by name. The code includes a main block with example usage of the DotDict and DotList classes.",
  "buggy_code": "__author__ = 'Adam R. Smith'\n__license__ = 'Apache 2.0'\n\nimport collections\n\nclass DotNotationGetItem(object):\n    \"\"\" Drive the behavior for DotList and DotDict lookups by dot notation, JSON-style. \"\"\"\n\n    def _convert(self, val):\n        \"\"\" Convert the type if necessary and return if a conversion happened. \"\"\"\n        if isinstance(val, dict) and not isinstance(val, DotDict):\n            return DotDict(val), True\n        elif isinstance(val, list) and not isinstance(val, DotList):\n            return DotList(val), True\n\n        return val, False\n\n    def __getitem__(self, key):\n        val = super(DotNotationGetItem, self).__getitem__(key)\n        val, converted = self._convert(val)\n        if converted: self[key] = val\n\n        return val\n\nclass DotList(DotNotationGetItem, list):\n    \"\"\" Partner class for DotDict; see that for docs. Both are needed to fully support JSON/YAML blocks. \"\"\"\n\n\n    def __iter__(self):\n        \"\"\" Monkey-patch the \"next\" iterator method to return modified versions. This will be slow. \"\"\"\n        for val in super(DotList, self).__iter__():\n            val, converted = self._convert(val)\n            yield val\n\nclass DotDict(DotNotationGetItem, dict):\n    \"\"\"\n    Subclass of dict that will recursively look up attributes with dot notation.\n    This is primarily for working with JSON-style data in a cleaner way like javascript.\n    Note that this will instantiate a number of child DotDicts when you first access attributes;\n    do not use in performance-critical parts of your code.\n    \"\"\"\n\n    def __getattr__(self, key):\n        \"\"\" Make attempts to lookup by nonexistent attributes also attempt key lookups. \"\"\"\n        try:\n            val = self.__getitem__(key)\n        except KeyError:\n            raise AttributeError(key)\n\n        return val\n\n    def copy(self):\n        return\n        return DotDict(dict.copy(self))\n\n    @classmethod\n    def fromkeys(cls, seq, value=None):\n        return DotDict(dict.fromkeys(seq, value))\n\nclass DictModifier(DotDict):\n    \"\"\"\n    Subclass of DotDict that allows the sparse overriding of dict values.\n    \"\"\"\n    def __init__(self, base, data=None):\n        if not isinstance(base, DotDict):\n            raise TypeError(\"Base must be of type DotDict\")\n        self.base = base\n\n        if data is not None:\n            self.update(data)\n\n    def __getattr__(self, key):\n        try:\n            return DotDict.__getattr__(self, key)\n        except AttributeError, ae:\n            return getattr(self.base, key)\n\n    def __getitem__(self, key):\n        try:\n            return DotDict.__getitem__(self, key)\n        except KeyError, ke:\n            return getattr(self.base, key)\n\n\ndef quacks_like_dict(object):\n    \"\"\"Check if object is dict-like\"\"\"\n    return isinstance(object, collections.Mapping)\n\ndef dict_merge(a, b):\n    \"\"\"Merge two deep dicts non-destructively\n\n    Uses a stack to avoid maximum recursion depth exceptions\n\n    >>> a = {'a': 1, 'b': {1: 1, 2: 2}, 'd': 6}\n    >>> b = {'c': 3, 'b': {2: 7}, 'd': {'z': [1, 2, 3]}}\n    >>> c = merge(a, b)\n    >>> from pprint import pprint; pprint(c)\n    {'a': 1, 'b': {1: 1, 2: 7}, 'c': 3, 'd': {'z': [1, 2, 3]}}\n    \"\"\"\n    assert quacks_like_dict(a), quacks_like_dict(b)\n    dst = a.copy()\n\n    stack = [(dst, b)]\n    while stack:\n        current_dst, current_src = stack.pop()\n        for key in current_src:\n            if key not in current_dst:\n                current_dst[key] = current_src[key]\n            else:\n                if quacks_like_dict(current_src[key]) and quacks_like_dict(current_dst[key]) :\n                    stack.append((current_dst[key], current_src[key]))\n                else:\n                    current_dst[key] = current_src[key]\n    return dst\n\ndef named_any(name):\n    \"\"\"\n    Retrieve a Python object by its fully qualified name from the global Python\n    module namespace.  The first part of the name, that describes a module,\n    will be discovered and imported.  Each subsequent part of the name is\n    treated as the name of an attribute of the object specified by all of the\n    name which came before it.\n    @param name: The name of the object to return.\n    @return: the Python object identified by 'name'.\n    \"\"\"\n    assert name, 'Empty module name'\n    names = name.split('.')\n\n    topLevelPackage = None\n    moduleNames = names[:]\n    while not topLevelPackage:\n        if moduleNames:\n            trialname = '.'.join(moduleNames)\n            try:\n                topLevelPackage = __import__(trialname)\n            except Exception, ex:\n                moduleNames.pop()\n        else:\n            if len(names) == 1:\n                raise Exception(\"No module named %r\" % (name,))\n            else:\n                raise Exception('%r does not name an object' % (name,))\n\n    obj = topLevelPackage\n    for n in names[1:]:\n        obj = getattr(obj, n)\n\n    return obj\n\ndef for_name(modpath, classname):\n    '''\n    Returns a class of \"classname\" from module \"modname\".\n    '''\n    module = __import__(modpath, fromlist=[classname])\n    classobj = getattr(module, classname)\n    return classobj()\n\n\nif __name__ == '__main__':\n    dd = DotDict({'a':{'b':{'c':1, 'd':2}}})\n    print dd.a.b.c, dd.a.b.d\n    print dd.a.b\n\n    print dict.fromkeys(('a','b','c'), 'foo')\n    print DotDict.fromkeys(('a','b','c'), 'foo').a\n\n    dl = DotList([1, {'a':{'b':{'c':1, 'd':2}}}])\n    print dl[1].a.b.c\n",
  "line_no": 53,
  "line_no_percent": "32%"
}