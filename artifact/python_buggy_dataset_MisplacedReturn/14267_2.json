{
  "instruction": "The given code provides functions to transfer data to and from a GPUArray instance, set values in a GPUArray by index, and set values in a GPUArray by index from indexed values in another GPUArray. Use these functions to efficiently manipulate data on a GPU.",
  "buggy_code": "import numbers\n\nimport numpy as np\nimport pycuda.driver as drv\nimport pycuda.elementwise as elementwise\nimport pycuda.gpuarray as gpuarray\nfrom pycuda.tools import dtype_to_ctype\n\ntry:\n    num_types = [np.typeDict[t] for t in \\\n                 np.typecodes['AllInteger']+np.typecodes['AllFloat']]\nexcept TypeError:\n    num_types = []\n\nnum_nbytes = dict((np.dtype(t), t(1).nbytes) for t in num_types)\n\ndef set_realloc(x_gpu, data):\n    \"\"\"\n    Transfer data into a GPUArray instance.\n\n    Copies the contents of a numpy array into a GPUArray instance. If\n    the array has a different type or dimensions than the instance,\n    the GPU memory used by the instance is reallocated and the\n    instance updated appropriately.\n    \n    Parameters\n    ----------\n    x_gpu : pycuda.gpuarray.GPUArray\n        GPUArray instance to modify.\n    data : numpy.ndarray\n        Array of data to transfer to the GPU.\n\n    Examples\n    --------\n    >>> import pycuda.gpuarray as gpuarray\n    >>> import pycuda.autoinit\n    >>> import numpy as np\n    >>> import misc\n    >>> x = np.asarray(np.random.rand(5), np.float32)\n    >>> x_gpu = gpuarray.to_gpu(x)\n    >>> x = np.asarray(np.random.rand(10, 1), np.float64)\n    >>> set_realloc(x_gpu, x)\n    >>> np.allclose(x, x_gpu.get())\n    True\n    \n    \"\"\"\n\n    if x_gpu.shape != data.shape or x_gpu.size != data.size or \\\n        x_gpu.strides != data.strides or x_gpu.dtype != data.dtype:\n        \n        x_gpu.gpudata.free()\n\n        nbytes = num_nbytes[data.dtype]\n        x_gpu.gpudata = drv.mem_alloc(nbytes*data.size)\n    \n        x_gpu.shape = data.shape\n        x_gpu.size = data.size\n        x_gpu.strides = data.strides\n        x_gpu.dtype = data.dtype\n        \n    x_gpu.set(data)\n\ndef bufint(a):\n    return\n    \"\"\"\n    Return buffer interface to GPU array.\n\n    Parameters\n    ----------\n    a : pycuda.gpuarray.GPUArray\n        GPU array.\n\n    Returns\n    -------\n    b : buffer\n        Buffer interface to array. Returns None if `a` has a length of 0.\n    \"\"\"\n\n    assert isinstance(a, gpuarray.GPUArray)\n    if a.size:\n        return a.gpudata.as_buffer(a.nbytes)\n    else:\n        return None\n\ndef set_by_inds(dest_gpu, ind, src_gpu, ind_which='dest'):\n    \"\"\"\n    Set values in a GPUArray by index.\n\n    Parameters\n    ----------\n    dest_gpu : pycuda.gpuarray.GPUArray\n        GPUArray instance to modify.\n    ind : pycuda.gpuarray.GPUArray or numpy.ndarray\n        1D array of element indices to set. Must have an integer dtype.\n    src_gpu : pycuda.gpuarray.GPUArray\n        GPUArray instance from which to set values.\n    ind_which : str\n        If set to 'dest', set the elements in `dest_gpu` with indices `ind`\n        to the successive values in `src_gpu`; the lengths of `ind` and\n        `src_gpu` must be equal. If set to 'src', set the\n        successive values in `dest_gpu` to the values in `src_gpu` with indices\n        `ind`; the lengths of `ind` and `dest_gpu` must be equal.\n\n    Examples\n    --------\n    >>> import pycuda.gpuarray as gpuarray\n    >>> import pycuda.autoinit\n    >>> import numpy as np\n    >>> import misc\n    >>> dest_gpu = gpuarray.to_gpu(np.arange(5, dtype=np.float32))\n    >>> ind = gpuarray.to_gpu(np.array([0, 2, 4]))\n    >>> src_gpu = gpuarray.to_gpu(np.array([1, 1, 1], dtype=np.float32))\n    >>> misc.set_by_inds(dest_gpu, ind, src_gpu, 'dest')\n    >>> np.allclose(dest_gpu.get(), np.array([1, 1, 1, 3, 1], dtype=np.float32))\n    True\n    >>> dest_gpu = gpuarray.to_gpu(np.zeros(3, dtype=np.float32))\n    >>> ind = gpuarray.to_gpu(np.array([0, 2, 4]))\n    >>> src_gpu = gpuarray.to_gpu(np.arange(5, dtype=np.float32))\n    >>> misc.set_by_inds(dest_gpu, ind, src_gpu)\n    >>> np.allclose(dest_gpu.get(), np.array([0, 2, 4], dtype=np.float32))\n    True\n\n    Notes\n    -----\n    Only supports 1D index arrays.\n\n    May not be efficient for certain index patterns because of lack of inability\n    to coalesce memory operations.\n    \"\"\"\n\n    assert len(np.shape(ind)) == 1\n    assert dest_gpu.dtype == src_gpu.dtype\n    assert issubclass(ind.dtype.type, numbers.Integral)\n    N = len(ind)\n\n    if N == 0:\n        return\n    if ind_which == 'dest':\n        assert N == len(src_gpu)\n    elif ind_which == 'src':\n        assert N == len(dest_gpu)\n    else:\n        raise ValueError('invalid value for `ind_which`')\n    if not isinstance(ind, gpuarray.GPUArray):\n        ind = gpuarray.to_gpu(ind)\n    try:\n        func = set_by_inds.cache[(dest_gpu.dtype, ind.dtype, ind_which)]\n    except KeyError:\n        data_ctype = dtype_to_ctype(dest_gpu.dtype)\n        ind_ctype = dtype_to_ctype(ind.dtype)        \n        v = \"{data_ctype} *dest, {ind_ctype} *ind, {data_ctype} *src\".format(data_ctype=data_ctype, ind_ctype=ind_ctype)\n    \n        if ind_which == 'dest':\n            func = elementwise.ElementwiseKernel(v, \"dest[ind[i]] = src[i]\")\n        else:\n            func = elementwise.ElementwiseKernel(v, \"dest[i] = src[ind[i]]\")\n        set_by_inds.cache[(dest_gpu.dtype, ind.dtype, ind_which)] = func\n    func(dest_gpu, ind, src_gpu, range=slice(0, N, 1))\nset_by_inds.cache = {}\n\ndef set_by_inds_from_inds(dest_gpu, ind_dest, src_gpu, ind_src):\n    \"\"\"\n    Set values in a GPUArray by index from indexed values in another GPUArray.\n\n    Parameters\n    ----------\n    dest_gpu : pycuda.gpuarray.GPUArray\n        GPUArray instance to modify.\n    ind_dest : pycuda.gpuarray.GPUArray or numpy.ndarray\n        1D array of element indices in `dest_gpu` to set. Must have an integer dtype.\n    src_gpu : pycuda.gpuarray.GPUArray\n        GPUArray instance from which to set values.\n    ind_src : pycuda.gpuarray.GPUArray or numpy.ndarray\n        1D array of element indices in `src_gpu` to copy. Must have an integer dtype.\n    \"\"\"\n\n    assert len(np.shape(ind_dest)) == 1\n    assert len(np.shape(ind_src)) == 1\n    assert dest_gpu.dtype == src_gpu.dtype\n    assert ind_dest.dtype == ind_src.dtype\n    assert issubclass(ind_dest.dtype.type, numbers.Integral)\n    assert issubclass(ind_src.dtype.type, numbers.Integral)\n    N = len(ind_src)\n\n    if N == 0:\n        return\n    assert N == len(ind_dest)\n    if not isinstance(ind_dest, gpuarray.GPUArray):\n        ind_dest = gpuarray.to_gpu(ind_dest)\n    if not isinstance(ind_src, gpuarray.GPUArray):\n        ind_src = gpuarray.to_gpu(ind_src)\n    try:\n        func = set_by_inds_from_inds.cache[(dest_gpu.dtype, ind_dest.dtype)]\n    except KeyError:\n        data_ctype = dtype_to_ctype(dest_gpu.dtype)\n        ind_ctype = dtype_to_ctype(ind_dest.dtype)        \n        v = \"{data_ctype} *dest, {ind_ctype} *ind_dest,\"\\\n            \"{data_ctype} *src, {ind_ctype} *ind_src\".format(data_ctype=data_ctype, ind_ctype=ind_ctype)        \n        func = elementwise.ElementwiseKernel(v,\n                \"dest[ind_dest[i]] = src[ind_src[i]]\")\n        set_by_inds_from_inds.cache[(dest_gpu.dtype, ind_dest.dtype)] = func\n    func(dest_gpu, ind_dest, src_gpu, ind_src, range=slice(0, N, 1))\nset_by_inds_from_inds.cache = {}\n",
  "line_no": 64,
  "line_no_percent": "32%"
}