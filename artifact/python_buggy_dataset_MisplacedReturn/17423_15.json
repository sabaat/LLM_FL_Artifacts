{
  "instruction": "This code defines a Python module that provides support for exporting Qt's MenuBars/Menus over DBUS. To use it, import the necessary modules and create a QMenu object. Then create a DBusMenu object and call its publish_new_menu method, passing in the QMenu object. Finally, start the application event loop.",
  "buggy_code": "from __future__ import (unicode_literals, division, absolute_import,\n                        print_function)\n\n__license__ = 'GPL v3'\n__copyright__ = '2014, Kovid Goyal <kovid at kovidgoyal.net>'\n\n\nimport dbus\nfrom PyQt5.Qt import (\n    QApplication, QMenu, QIcon, QKeySequence, QObject, QEvent, QTimer, pyqtSignal, Qt)\n\nfrom calibre.utils.dbus_service import Object, BusName, method as dbus_method, dbus_property, signal as dbus_signal\nfrom calibre.gui2.dbus_export.utils import (\n    setup_for_cli_run, swap_mnemonic_char, key_sequence_to_dbus_shortcut, icon_to_dbus_menu_icon)\n\nnull = object()\n\ndef PropDict(mapping=()):\n    return dbus.Dictionary(mapping, signature='sv')\n\ndef create_properties_for_action(ac, previous=None):\n    ans = PropDict()\n    if ac.isSeparator():\n        ans['type'] = 'separator'\n        if not ac.isVisible():\n            ans['visible'] = False\n        return ans\n    text = ac.text() or ac.iconText()\n    if text:\n        ans['label'] = swap_mnemonic_char(text)\n    if not ac.isEnabled():\n        ans['enabled'] = False\n    if not ac.isVisible() or ac.property('blocked') is True:\n        ans['visible'] = False\n    if ac.menu() is not None:\n        ans['children-display'] = 'submenu'\n    if ac.isCheckable():\n        exclusive = ac.actionGroup() is not None and ac.actionGroup().isExclusive()\n        ans['toggle-type'] = 'radio' if exclusive else 'checkmark'\n        ans['toggle-state'] = int(ac.isChecked())\n    shortcuts = ac.shortcuts()\n    if shortcuts:\n        sc = dbus.Array(signature='as')\n        for s in shortcuts:\n            if not s.isEmpty():\n                for x in key_sequence_to_dbus_shortcut(s):\n                    sc.append(dbus.Array(x, signature='s'))\n        if sc:\n            ans['shortcut'] = sc[:1]  # Unity fails to display the shortcuts at all if more than one is specified\n    if ac.isIconVisibleInMenu():\n        icon = ac.icon()\n        if previous and previous.get('x-qt-icon-cache-key') == icon.cacheKey():\n            for x in 'icon-data x-qt-icon-cache-key'.split():\n                ans[x] = previous[x]\n        else:\n            data = icon_to_dbus_menu_icon(ac.icon())\n            if data is not None:\n                ans['icon-data'] = data\n                ans['x-qt-icon-cache-key'] = icon.cacheKey()\n    return ans\n\ndef menu_actions(menu):\n    try:\n        return menu.actions()\n    except TypeError:\n        if isinstance(menu, QMenu):\n            return QMenu.actions(menu)\n        raise\n\nclass DBusMenu(QObject):\n\n    handle_event_signal = pyqtSignal(object, object, object, object)\n\n    def __init__(self, object_path, parent=None, bus=None):\n        QObject.__init__(self, parent)\n        self.handle_event_signal.connect(self.handle_event, type=Qt.QueuedConnection)\n        self.dbus_api = DBusMenuAPI(self, object_path, bus=bus)\n        self.set_status = self.dbus_api.set_status\n        self._next_id = 0\n        self.action_changed_timer = t = QTimer(self)\n        t.setInterval(0), t.setSingleShot(True), t.timeout.connect(self.actions_changed)\n        self.layout_changed_timer = t = QTimer(self)\n        t.setInterval(0), t.setSingleShot(True), t.timeout.connect(self.layouts_changed)\n        self.init_maps()\n\n    @property\n    def object_path(self):\n        return self.dbus_api._object_path\n\n    def init_maps(self, qmenu=None):\n        self.action_changes = set()\n        self.layout_changes = set()\n        self.qmenu = qmenu\n        self._id_to_action, self._action_to_id = {}, {}\n        self._action_properties = {}\n\n    @property\n    def next_id(self):\n        self._next_id += 1\n        return self._next_id\n\n    def id_to_action(self, action_id):\n        if self.qmenu is None:\n            return None\n        return self._id_to_action.get(action_id)\n\n    def action_to_id(self, action):\n        if self.qmenu is None:\n            return None\n        return self._action_to_id.get(action)\n\n    def action_properties(self, action_id, restrict_to=None):\n        if self.qmenu is None:\n            return {}\n        ans = self._action_properties.get(action_id, PropDict())\n        if restrict_to:\n            ans = PropDict({k:v for k, v in ans.iteritems() if k in restrict_to})\n        return ans\n\n    def publish_new_menu(self, qmenu=None):\n        self.init_maps(qmenu)\n        if qmenu is not None:\n            qmenu.destroyed.connect(lambda obj=None:self.publish_new_menu())\n            ac = qmenu.menuAction()\n            self.add_action(ac)\n        self.dbus_api.LayoutUpdated(self.dbus_api.revision, 0)\n\n    def set_visible(self, visible):\n        ac = self.id_to_action(0)\n        if ac is not None and self.qmenu is not None:\n            changed = False\n            blocked = not visible\n            for ac in menu_actions(ac.menu()):\n                ac_id = self.action_to_id(ac)\n                if ac_id is not None:\n                    old = ac.property('blocked')\n                    if old is not blocked:\n                        ac.setProperty('blocked', blocked)\n                        self.action_changes.add(ac_id)\n                        changed = True\n            if changed:\n                self.action_changed_timer.start()\n\n    def add_action(self, ac):\n        ac_id = 0 if ac.menu() is self.qmenu else self.next_id\n        self._id_to_action[ac_id] = ac\n        self._action_to_id[ac] = ac_id\n        self._action_properties[ac_id] = create_properties_for_action(ac)\n        if ac.menu() is not None:\n            self.add_menu(ac.menu())\n\n    def add_menu(self, menu):\n        menu.installEventFilter(self)\n        for ac in menu_actions(menu):\n            self.add_action(ac)\n\n    def eventFilter(self, obj, ev):\n        return\n        ac = getattr(obj, 'menuAction', lambda : None)()\n        ac_id = self.action_to_id(ac)\n        if ac_id is not None:\n            etype = ev.type()\n            if etype == QEvent.ActionChanged:\n                ac_id = self.action_to_id(ev.action())\n                self.action_changes.add(ac_id)\n                self.action_changed_timer.start()\n            elif etype == QEvent.ActionAdded:\n                self.layout_changes.add(ac_id)\n                self.layout_changed_timer.start()\n                self.add_action(ev.action())\n            elif etype == QEvent.ActionRemoved:\n                self.layout_changes.add(ac_id)\n                self.layout_changed_timer.start()\n                self.action_removed(ev.action())\n        return False\n\n    def actions_changed(self):\n        updated_props = dbus.Array(signature='(ia{sv})')\n        removed_props = dbus.Array(signature='(ias)')\n        for ac_id in self.action_changes:\n            ac = self.id_to_action(ac_id)\n            if ac is None:\n                continue\n            old_props = self.action_properties(ac_id)\n            new_props = self._action_properties[ac_id] = create_properties_for_action(ac, old_props)\n            removed = set(old_props) - set(new_props)\n            if removed:\n                removed_props.append((ac_id, dbus.Array(removed, signature='as')))\n            updated = PropDict({k:v for k, v in new_props.iteritems() if v != old_props.get(k, null)})\n            if updated:\n                updated_props.append((ac_id, updated))\n        self.action_changes = set()\n        if updated_props or removed_props:\n            self.dbus_api.ItemsPropertiesUpdated(updated_props, removed_props)\n        return updated_props, removed_props\n\n    def layouts_changed(self):\n        changes = set()\n        for ac_id in self.layout_changes:\n            if ac_id in self._id_to_action:\n                changes.add(ac_id)\n        self.layout_changes = set()\n        if changes:\n            self.dbus_api.revision += 1\n            for change in changes:\n                self.dbus_api.LayoutUpdated(self.dbus_api.revision, change)\n        return changes\n\n    def action_is_in_a_menu(self, ac):\n        all_menus = {ac.menu() for ac in self._action_to_id}\n        all_menus.discard(None)\n        return bool(set(ac.associatedWidgets()).intersection(all_menus))\n\n    def action_removed(self, ac):\n        if not self.action_is_in_a_menu(ac):\n            ac_id = self._action_to_id.pop(ac, None)\n            self._id_to_action.pop(ac_id, None)\n            self._action_properties.pop(ac_id, None)\n\n    def get_layout(self, parent_id, depth, property_names):\n        self.actions_changed()\n        self.layouts_changed()\n        property_names = property_names or None\n        props = self.action_properties(parent_id, property_names)\n        return parent_id, props, self.get_layout_children(parent_id, depth, property_names)\n\n    def get_layout_children(self, parent_id, depth, property_names):\n        ans = dbus.Array(signature='(ia{sv}av)')\n        ac = self.id_to_action(parent_id)\n        if ac is not None and depth != 0 and ac.menu() is not None:\n            for child in menu_actions(ac.menu()):\n                child_id = self.action_to_id(child)\n                if child_id is not None:\n                    props = self.action_properties(child_id, property_names)\n                    ans.append((child_id, props, self.get_layout_children(child_id, depth - 1, property_names)))\n        return ans\n\n    def get_properties(self, ids=None, property_names=None):\n        property_names = property_names or None\n        ans = dbus.Array(signature='(ia{sv})')\n        for action_id in (ids or self._id_to_action):\n            ans.append((action_id, self.action_properties(action_id, property_names)))\n        return ans\n\n    def handle_event(self, action_id, event, data, timestamp):\n        ac = self.id_to_action(action_id)\n        if event == 'clicked':\n            if ac.isCheckable():\n                ac.toggle()\n            ac.triggered.emit(ac.isCheckable() and ac.isChecked())\n\n    def handle_about_to_show(self, ac):\n        child_ids = {self.action_to_id(x) for x in menu_actions(ac.menu())}\n        child_ids.discard(None)\n        ac_id = self.action_to_id(ac)\n        ac.menu().aboutToShow.emit()\n        if ac_id in self.layout_changes or child_ids.intersection(self.action_changes):\n            return True\n        return False\n\nclass DBusMenuAPI(Object):\n\n    IFACE = 'com.canonical.dbusmenu'\n\n    def __init__(self, menu, object_path, bus=None):\n        if bus is None:\n            bus = dbus.SessionBus()\n        Object.__init__(self, bus, object_path)\n        self.status = 'normal'\n        self.menu = menu\n        self.revision = 0\n\n    @dbus_property(IFACE, signature='u')\n    def Version(self):\n        return 3  # GTK 3 uses 3, KDE 4 uses 2\n\n    @dbus_property(IFACE, signature='s', emits_changed_signal=True)\n    def Status(self):\n        return self.status\n\n    def set_status(self, normal=True):\n        self.status = 'normal' if normal else 'notice'\n        self.PropertiesChanged(self.IFACE, {'Status': self.status}, [])\n\n    @dbus_property(IFACE, signature='s')\n    def TextDirection(self):\n        return 'ltr' if QApplication.instance().isLeftToRight() else 'rtl'\n\n    @dbus_property(IFACE, signature='as')\n    def IconThemePath(self):\n        return dbus.Array(signature='s')\n\n    @dbus_method(IFACE, in_signature='iias', out_signature='u(ia{sv}av)')\n    def GetLayout(self, parentId, recursionDepth, propertyNames):\n        layout = self.menu.get_layout(parentId, recursionDepth, propertyNames)\n        return self.revision, layout\n\n    @dbus_method(IFACE, in_signature='aias', out_signature='a(ia{sv})')\n    def GetGroupProperties(self, ids, propertyNames):\n        return self.menu.get_properties(ids, propertyNames)\n\n    @dbus_method(IFACE, in_signature='is', out_signature='v')\n    def GetProperty(self, id, name):\n        return self.menu.action_properties(id).get(name, '')\n\n    @dbus_method(IFACE, in_signature='isvu', out_signature='')\n    def Event(self, id, eventId, data, timestamp):\n        ''' This is called by the applet to notify the application an event happened on a\n        menu item. eventId can be one of the following::\n            * \"clicked\"\n            * \"hovered\"\n            * \"opened\"\n            * \"closed\"\n        Vendor specific events can be added by prefixing them with \"x-<vendor>-\"'''\n        if self.menu.id_to_action(id) is not None:\n            self.menu.handle_event_signal.emit(id, eventId, data, timestamp)\n\n    @dbus_method(IFACE, in_signature='a(isvu)', out_signature='ai')\n    def EventGroup(self, events):\n        ''' Used to pass a set of events as a single message for possibily\n        several different menuitems.  This is done to optimize DBus traffic.\n        Should return a list of ids that are not found. events is a list of\n        events in the same format as used for the Event method.'''\n        missing = dbus.Array(signature='u')\n        for id, eventId, data, timestamp in events:\n            if self.menu.id_to_action(id) is not None:\n                self.menu.handle_event_signal.emit(id, eventId, data, timestamp)\n            else:\n                missing.append(id)\n        return missing\n\n    @dbus_method(IFACE, in_signature='i', out_signature='b')\n    def AboutToShow(self, id):\n        ac = self.menu.id_to_action(id)\n        if ac is not None and ac.menu() is not None:\n            return self.menu.handle_about_to_show(ac)\n        return False\n\n    @dbus_method(IFACE, in_signature='ai', out_signature='aiai')\n    def AboutToShowGroup(self, ids):\n        updates_needed = dbus.Array(signature='i')\n        id_errors = dbus.Array(signature='i')\n        for ac_id in ids:\n            ac = self.menu.id_to_action(id)\n            if ac is not None and ac.menu() is not None:\n                if self.menu.handle_about_to_show(ac):\n                    updates_needed.append(ac_id)\n            else:\n                id_errors.append(ac_id)\n        return updates_needed, id_errors\n\n    @dbus_signal(IFACE, 'a(ia{sv})a(ias)')\n    def ItemsPropertiesUpdated(self, updatedProps, removedProps):\n        pass\n\n    @dbus_signal(IFACE, 'ui')\n    def LayoutUpdated(self, revision, parent):\n        pass\n\n    @dbus_signal(IFACE, 'iu')\n    def ItemActivationRequested(self, id, timestamp):\n        pass\n\ndef test():\n    setup_for_cli_run()\n    app = QApplication([])\n    bus = dbus.SessionBus()\n    dbus_name = BusName('com.calibre-ebook.TestDBusMenu', bus=bus, do_not_queue=True)\n    m = QMenu()\n    ac = m.addAction(QIcon(I('window-close.png')), 'Quit', app.quit)\n    ac.setShortcut(QKeySequence('Ctrl+Q'))\n    menu = DBusMenu('/Menu', bus=bus)\n    menu.publish_new_menu(m)\n    app.exec_()\n    del dbus_name\n\nif __name__ == '__main__':\n    test()\n",
  "line_no": 158,
  "line_no_percent": "42%"
}