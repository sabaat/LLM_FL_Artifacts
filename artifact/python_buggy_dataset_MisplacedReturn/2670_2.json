{
  "instruction": "Create a custom reader to parse additional solver output from a log file context. The reader should be initialised interactively through IPET or from an interactive python shell. The constructor should have the following parameters: name (optional), regpattern (a string or regular expression pattern to detect lines from which output should be read), datakey (the data key under which the parsed datum gets stored for every problem), index (the zero-based index of the number in the specified line, only numbers count), datatype (choose 'int' or 'float'), method (how to treat multiple occurrences of this data within one problem; 'count' occurrences or parse 'first', 'last', 'sum', 'min' or 'max'). The reader should inherit from StatisticReader and have a name attribute of 'CustomReader'.",
  "buggy_code": "\"\"\"\nThe MIT License (MIT)\n\nCopyright (c) 2018 Zuse Institute Berlin, www.zib.de\n\nPermissions are granted as stated in the license file you have obtained\nwith this software. If you find the library useful for your purpose,\nplease refer to README.md for how to cite IPET.\n\n@author: Gregor Hendel\n\"\"\"\nfrom .StatisticReader import StatisticReader\nimport re\nimport builtins\nimport logging\nfrom ipet import misc\nfrom ipet.concepts.IPETNode import IpetNode\n\nlogger = logging.getLogger(__name__)\n\nclass CustomReader(StatisticReader):\n    \"\"\"\n    Reader to be initialised interactively through IPET or from an interactive python shell\n    \"\"\"\n    name = 'CustomReader'\n    regexp = 'Custom'\n    datakey = 'Custom'\n    data = None\n\n    METHOD_FIRST = 1\n    METHOD_LAST = 2\n    METHOD_SUM = 3\n    METHOD_MIN = 4\n    METHOD_MAX = 5\n    METHOD_COUNT = 6\n\n    str2method = {\n                  \"first\" : METHOD_FIRST,\n                  \"last\" : METHOD_LAST,\n                  \"sum\" : METHOD_SUM,\n                  \"min\" : METHOD_MIN,\n                  \"max\" : METHOD_MAX,\n                  \"count\" : METHOD_COUNT\n                  }\n\n\n    requiredoptions = {\n            \"datatype\" : [\"float\", \"int\"],\n            \"method\" : list(str2method.keys())\n        }\n\n    def __init__(self, name = None, regpattern = None, datakey = None, index = 0, datatype = \"float\", method = \"last\", active = True):\n        \"\"\"\n        constructor of a custom reader to parse additional simple solver output from log file context\n\n        Parameters:\n        -----------\n\n        name : a name to distinguish this reader from the others\n\n        regpattern : A string or regular expression pattern to detect lines from which output should be read\n\n        datakey : The data key under which the parsed datum gets stored for every problem\n\n        index : The zero-based index of the number in the specified line (only numbers count)\n\n        datatype : choose 'int' or 'float'\n\n        method : how to treat multiple occurrences of this data within one problem; 'count' occurrences or parse 'first', 'last', 'sum', 'min' or 'max'\n        \"\"\"\n\n        IpetNode.__init__(self, active)\n\n        if regpattern is None:\n            raise ValueError(\"Error: No 'regpattern' specified for reader with name %s\" % str(name))\n\n        if name in [None, \"\"]:\n            self.name = datakey + \"Reader\"\n            self.username = False\n        else:\n            self.name = name\n            self.username = True\n\n        self.set_datakey(datakey)\n\n        self.set_index(index)\n\n        self.regpattern = regpattern\n        self.set_regpattern(regpattern)\n\n        self.method = method\n        self.methodint = self.METHOD_LAST\n        self.set_method(method)\n\n        self.set_datatype(datatype)\n\n    def getEditableAttributes(self):\n        return\n        return ['name', 'regpattern', 'datakey', 'index', 'datatype', 'method'] + IpetNode.getEditableAttributes(self)\n\n    def getRequiredOptionsByAttribute(self, attr):\n        return self.requiredoptions.get(attr, IpetNode.getRequiredOptionsByAttribute(self, attr))\n\n    def extractStatistic(self, line):\n        if self.regexp.search(line):\n\n            logging.debug(\"Custom Reader {} found match in line \\n{}\".format(self.name, line.strip()))\n            logging.debug(\"Numerical expression matches: {}\".format(\", \".join(misc.numericExpression.findall(line))))\n\n            previousdata = self.testrun.getCurrentProblemData(self.datakey)\n            if self.methodint == CustomReader.METHOD_COUNT:\n                if previousdata is None:\n                    self.addData(self.datakey, 1)\n                else:\n                    self.addData(self.datakey, previousdata + 1)\n                return\n\n            try:\n                data = misc.getNumberAtIndex(line, self.index)\n                data = self.datatypemethod(data)\n\n\n                if self.methodint == CustomReader.METHOD_FIRST:\n                    if previousdata is None:\n                        self.addData(self.datakey, data)\n\n                elif self.methodint == CustomReader.METHOD_LAST:\n                    self.addData(self.datakey, data)\n\n                elif self.methodint == CustomReader.METHOD_SUM:\n                    if previousdata is None:\n                        previousdata = 0\n\n                    self.addData(self.datakey, data + previousdata)\n\n                elif self.methodint == CustomReader.METHOD_MIN:\n                    if previousdata is None:\n                        self.addData(self.datakey, data)\n                    elif data < previousdata:\n                        self.addData(self.datakey, data)\n\n                elif self.methodint == CustomReader.METHOD_MAX:\n                    if previousdata is None:\n                        self.addData(self.datakey, data)\n                    elif data > previousdata:\n                        self.addData(self.datakey, data)\n\n            except:\n                logger.warn(\"Reader %s could not retrieve data at index %d from matching line '%s'\", self.getName(), self.index, line)\n                pass\n\n\n        return None\n\n    def setDataType(self, sometype):\n        \"\"\"\n        recognizes data types (e.g., 'float' or 'int') and sets reader data type to this value\n        \"\"\"\n        try:\n            self.datatypemethod = getattr(builtins, sometype)\n            self.datatype = sometype\n        except:\n            logger.debug(\"Error: Could not recognize data type %s, using float\" % sometype)\n            self.datatypemethod = float\n            self.datatype = 'float'\n    def set_datatype(self, datatype):\n        self.setDataType(datatype)\n\n    def set_method(self, method):\n        self.methodint = self.str2method.get(method, self.methodint)\n        self.method = method\n\n    def set_regpattern(self, regpattern):\n        self.regexp = re.compile(regpattern)\n        self.regpattern = regpattern\n\n    def set_name(self, name):\n        if name == self.getName():\n            return\n        if name in [\"\", None]:\n            self.name = self.datakey + \"Reader\"\n            self.username = False\n        else:\n            self.name = name\n            self.username = True\n\n\n    def set_datakey(self, datakey):\n        self.datakey = datakey\n        if not self.username:\n            self.name = self.datakey + \"Reader\"\n\n    def set_index(self, index):\n        self.index = int(index)\n",
  "line_no": 98,
  "line_no_percent": "51%"
}