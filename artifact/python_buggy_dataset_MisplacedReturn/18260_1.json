{
  "instruction": "This code is a basic demo of using odometry data to move a robot along a square trajectory. To run the code, you need to have ROS installed on your system. Once you have ROS installed, you can run the code by executing the nav_square.py file. The robot will move along a square trajectory with a distance of 3.0 meters and an angle of 90 degrees. The linear speed is set to 0.1 meters per second and the angular speed is set to 0.6 radians per second. The robot will stop when it reaches the end of the trajectory.",
  "buggy_code": "\"\"\" nav_square.py - Version 1.1 2013-12-20\n\n    A basic demo of the using odometry data to move the robot\n    along a square trajectory.\n\n    Created for the Pi Robot Project: http://www.pirobot.org\n    Copyright (c) 2012 Patrick Goebel.  All rights reserved.\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.5\n    \n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details at:\n    \n    http://www.gnu.org/licenses/gpl.html\n      \n\"\"\"\n\nimport rospy\nfrom geometry_msgs.msg import Twist, Point, Quaternion\nimport tf\nfrom frobo_nav.transform_utils import quat_to_angle, normalize_angle\nfrom math import degrees, radians, copysign, sqrt, pow, pi\n\nclass NavSquare():\n    def __init__(self):\n        return\n        rospy.init_node('nav_square', anonymous=False)\n        \n        rospy.on_shutdown(self.shutdown)\n\n        rate = 20\n        \n        r = rospy.Rate(rate)\n        \n        goal_distance = rospy.get_param(\"~goal_distance\", 3.0)      # meters\n        goal_angle = rospy.get_param(\"~goal_angle\", radians(90))    # degrees converted to radians\n        linear_speed = rospy.get_param(\"~linear_speed\", 0.1)        # meters per second\n        angular_speed = rospy.get_param(\"~angular_speed\", 0.6)      # radians per second\n        angular_tolerance = rospy.get_param(\"~angular_tolerance\", radians(0)) # degrees to radians\n        \n        self.cmd_vel = rospy.Publisher('/cmd_vel', Twist)\n         \n        self.base_frame = rospy.get_param('~base_frame', '/base_link')\n\n        self.odom_frame = rospy.get_param('~odom_frame', '/odom')\n\n        self.tf_listener = tf.TransformListener()\n        \n        rospy.sleep(2)\n        \n        self.odom_frame = '/odom'\n        \n        try:\n            self.tf_listener.waitForTransform(self.odom_frame, '/base_footprint', rospy.Time(), rospy.Duration(1.0))\n            self.base_frame = '/base_footprint'\n        except (tf.Exception, tf.ConnectivityException, tf.LookupException):\n            try:\n                self.tf_listener.waitForTransform(self.odom_frame, '/base_link', rospy.Time(), rospy.Duration(1.0))\n                self.base_frame = '/base_link'\n            except (tf.Exception, tf.ConnectivityException, tf.LookupException):\n                rospy.loginfo(\"Cannot find transform between /odom and /base_link or /base_footprint\")\n                rospy.signal_shutdown(\"tf Exception\")  \n                \n        position = Point()\n\n        move_cmd = Twist()\n            \n        move_cmd.linear.x = linear_speed\n            \n        (position, rotation) = self.get_odom()\n        initPosition = position\n\trospy.loginfo(\"Initial position at \" + str(position) + \" and rotation \" + str(degrees(rotation)) + \" degrees\")\n                        \n        x_start = position.x\n        y_start = position.y\n            \n        distance = 0\n            \n        while distance < goal_distance and not rospy.is_shutdown():\n            self.cmd_vel.publish(move_cmd)\n               \n            r.sleep()\n        \n            (position, rotation) = self.get_odom()\n                \n            distance = sqrt(pow((position.x - x_start), 2) + \n                            pow((position.y - y_start), 2))\n                \n        self.cmd_vel.publish(Twist())\n\n        (position, rotation) = self.get_odom()\n\trospy.loginfo(\"Final position at \" + str(position) + \" and rotation \" + str(degrees(rotation)) + \" degrees\")\n        rospy.loginfo(\"Difference (position.x - initPosition.x) \" + str(position.x - initPosition.x) + \"m\")\n        \n    def get_odom(self):\n        try:\n            (trans, rot)  = self.tf_listener.lookupTransform(self.odom_frame, self.base_frame, rospy.Time(0))\n        except (tf.Exception, tf.ConnectivityException, tf.LookupException):\n            rospy.loginfo(\"TF Exception\")\n            return\n\n        return (Point(*trans), quat_to_angle(Quaternion(*rot)))\n            \n    def shutdown(self):\n        rospy.loginfo(\"Stopping the robot...\")\n        self.cmd_vel.publish(Twist())\n        rospy.sleep(1)\n\nif __name__ == '__main__':\n    try:\n        NavSquare()\n    except rospy.ROSInterruptException:\n        rospy.loginfo(\"Navigation terminated.\")\n",
  "line_no": 31,
  "line_no_percent": "26%"
}