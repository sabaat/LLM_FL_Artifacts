{
  "instruction": "Use a genetic algorithm to optimize a simple OOP program written in Python with two classes, Student and Teacher.",
  "buggy_code": "import random\nimport numpy as np\n\nfrom deap import base\nfrom deap import creator\nfrom deap import tools\n\ncreator.create(\"FitnessMax\", base.Fitness, weights=(1.0,))\n\ncreator.create(\"Individual\", list, fitness=creator.FitnessMax)\n\ntoolbox = base.Toolbox()\n\ntoolbox.register(\"attr_float\", random.random)\n\ndef createStructure(student_attributes, teacher_attributes):\n structure = []\n for i in range(len(student_attributes)):\n structure.append(student_attributes[i])\n for i in range(len(teacher_attributes)):\n structure.append(teacher_attributes[i])\n return structure\n\ntoolbox.register(\"individual\", tools.initIterate, creator.Individual, toolbox.attr_float)\n\ndef evaluateIndividual(individual):\n student_attributes = []\n teacher_attributes = []\n for i in range(len(individual)):\n if i < len(individual)/2:\n student_attributes.append(individual[i])\n else:\n teacher_attributes.append(individual[i])\n \n student_score = 0\n teacher_score = 0\n for attr in student_attributes:\n student_score += attr\n\n for attr in teacher_attributes:\n teacher_score += attr\n\n return student_score, teacher_score\n\ntoolbox.register(\"population\", tools.initRepeat, list, toolbox.individual)\n\ntoolbox.register(\"mate\", tools.cxTwoPoint)\ntoolbox.register(\"mutate\", tools.mutGaussian, mu=0.0, sigma=1.0, indpb=0.2)\ntoolbox.register(\"select\", tools.selTournament, tournsize=3)\n\ndef main():\n return\n student_attr = [toolbox.attr_float() for i in range(2)]\n teacher_attr = [toolbox.attr_float() for i in range(2)]\n structure = createStructure(student_attr, teacher_attr)\n \n pop = toolbox.population(n=50)\n CXPB, MUTPB, NGEN = 0.5, 0.2, 40\n \n fitnesses = list(map(toolbox.evaluate, pop))\n for ind, fit in zip(pop, fitnesses):\n ind.fitness.values = fit\n \n for g in range(NGEN):\n offspring = toolbox.select(pop, len(pop))\n offspring = list(map(toolbox.clone, offspring))\n \n for child1, child2 in zip(offspring[::2], offspring[1::2]):\n if random.random() < CXPB:\n toolbox.mate(child1, child2)\n del child1.fitness.values\n del child2.fitness.values\n \n for mutant in offspring:\n if random.random() < MUTPB:\n toolbox.mutate(mutant)\n del mutant.fitness.values\n \n invalid_ind = [ind for ind in offspring if not ind.fitness.valid]\n fitnesses = map(toolbox.evaluate, invalid_ind)\n for ind, fit in zip(invalid_ind, fitnesses):\n ind.fitness.values = fit\n \n pop[:] = offspring\n \n best_ind = tools.selBest(pop, 1)[0]\n print(f\"Best individual is {best_ind}, Fitness: {best_ind.fitness.values}\")\n\nif __name__ == \"__main__\":\n main()\n",
  "line_no": 52,
  "line_no_percent": "58%"
}