{
  "instruction": "Parse a Ruby file and create a gtk.TreeModel with the class elements of the document. The parser uses the ctags command from the shell to create a ctags file, then parses the file, and finally populates a treemodel.",
  "buggy_code": "import gtk\nimport gobject\nimport pango\nimport os\nimport re\nimport options\nfrom parserinterface import ClassParserInterface\nimport imagelibrary\n\n\ndef tokenFromString(string):\n    \"\"\" Parse a string containing a function or class definition and return\n        a tuple containing information about the function, or None if the\n        parsing failed.\n\n        Example: \n            \"#def foo(bar):\" would return :\n            {'comment':True,'type':\"def\",'name':\"foo\",'params':\"bar\" } \"\"\"\n\n    try:\n        e = r\"([# ]*?)([a-zA-Z0-9_]+)( +)([a-zA-Z0-9_\\?\\!<>\\+=\\.]+)(.*)\"\n        r = re.match(e,string).groups()\n        token = Token()\n        token.comment = '#' in r[0]\n        token.type = r[1]\n        token.name = r[3]\n        token.params = r[4]\n        token.original = string\n        return token\n    except: return None # return None to skip if unable to parse\n    \n    def test():\n        pass\n\n\nclass Token:\n    def __init__(self):\n        self.type = None\n        self.original = None # the line in the file, unparsed\n\n        self.indent = 0\n        self.name = None\n        self.comment = False # if true, the token is commented, ie. inactive\n        self.params = None   # string containing additional info\n        self.expanded = False\n\n        self.access = \"public\"\n\n        self.start = 0\n        self.end = 0\n\n        self.rubyfile = None\n        self.path = None # save the position in the browser\n\n        self.parent = None\n        self.children = []\n\n    def get_endline(self):\n        \"\"\" Get the line number where this token's declaration, including all\n            its children, finishes. Use it for copy operations.\"\"\"\n        if len(self.children) > 0:\n            return self.children[-1].get_endline()\n        return self.end\n\n        def test_nested():\n            pass\n            \n    def get_toplevel_class(self):\n        \"\"\" Try to get the class a token is in. \"\"\"\n            \n        if self.type == \"class\":\n            return self    \n\n        if self.parent is not None:\n            tc = self.parent.get_toplevel_class()\n            if tc is None or tc.type == \"file\": return self #hack\n            else: return tc\n                \n        return None\n\n    def printout(self):\n        for r in range(self.indent): print \"\",\n        print self.name,\n        if self.parent: print \" (parent: \",self.parent.name       \n        else: print\n        for tok in self.children: tok.printout()\n\n\nclass RubyFile(Token):\n    \"\"\" A class that represents a ruby file.\n        Manages \"tokens\", ie. classes and functions.\"\"\"\n\n    def __init__(self, doc):\n        Token.__init__(self)\n        self.doc = doc\n        self.uri = doc.get_uri()\n        self.linestotal = 0 # total line count\n        self.type = \"file\"\n        self.name = os.path.basename(self.uri)\n        self.tokens = []\n\n\n    def getTokenAtLine(self, line):\n        \"\"\" get the token at the specified line number \"\"\"\n        for token in self.tokens:\n            if token.start <= line and token.end > line:\n                return self.__findInnermostTokenAtLine(token, line)\n        return None\n\n    def __findInnermostTokenAtLine(self, token, line):\n        \"\"\"\" ruby is parsed as nested, unlike python \"\"\"\n        for child in token.children:\n            if child.start <= line and child.end > line:\n                return self.__findInnermostTokenAtLine(child, line)\n        return token\n\n\n    def parse(self, verbose=True):\n\n        newtokenlist = []\n\n        self.children = []\n\n        currentParent = self\n\n        self.linestotal = self.doc.get_line_count()\n\n        text = self.doc.get_text(*self.doc.get_bounds())\n        linecount = -1\n        ends_to_skip = 0\n        \n        access = \"public\"\n        \n        for line in text.splitlines():\n            linecount += 1\n            lstrip = line.lstrip()\n            ln = lstrip.split()\n            if len(ln) == 0: continue\n            if ln[0] == '#': continue\n            \n            if ln[0] in (\"class\",\"module\",\"def\"):\n                token = tokenFromString(lstrip)\n                if token is None: continue\n                token.rubyfile = self\n                token.start = linecount\n                if token.type == \"def\":\n                    token.access = access\n                    \n                \n                currentParent.children.append(token)\n                token.parent = currentParent\n                currentParent = token\n                newtokenlist.append(token)\n                \n                \n                idx = len(newtokenlist) - 1\n                if idx < len(self.tokens):\n                    if newtokenlist[idx].original == self.tokens[idx].original:\n                        newtokenlist[idx].expanded = self.tokens[idx].expanded\n                \n            elif ln[0] in(\"begin\",\"while\",\"until\",\"case\",\"if\",\"unless\",\"for\"):\n                    ends_to_skip += 1\n                    \n            elif ln[0] in (\"attr_reader\",\"attr_writer\",\"attr_accessor\"):\n                for attr in ln:\n                    m = re.match(r\":(\\w+)\",attr)\n                    if m:\n                        token = Token()\n                        token.rubyfile = self\n                        token.type = 'def'\n                        token.name = m.group(1)\n                        token.start = linecount\n                        token.end = linecount\n                        token.original = lstrip\n                        currentParent.children.append(token)\n                        token.parent = currentParent\n                        newtokenlist.append(token)\n            \n            elif re.search(r\"\\sdo(\\s+\\|.*?\\|)?\\s*(#|$)\", line):\n\n                if re.match(r\"^(describe|it|before|after)\\b\", ln[0]):\n                    token = Token()\n                    token.rubyfile = self\n                    token.start = linecount\n                    \n                    if currentParent.type == \"describe\":                    \n                        if ln[0] == \"it\":\n                            token.name = \" \".join(ln[1:-1])\n                        else:\n                            token.name = ln[0]\n                        token.type = \"def\"\n                    elif ln[0] == \"describe\":\n                        token.type = \"describe\"\n                        token.name = \" \".join(ln[1:-1])\n                    else:\n                        continue\n                    currentParent.children.append(token)\n                    token.parent = currentParent\n                    currentParent = token\n                    newtokenlist.append(token)\n\n                elif ln[0] in (\"context\",\"specify\",\"setup\",\"teardown\",\"context_setup\",\"context_teardown\"):\n                    token = Token()\n                    token.rubyfile = self\n                    token.start = linecount\n                    \n                    if currentParent.type == \"context\":                    \n                        if ln[0] == \"specify\":\n                            token.name = \" \".join(ln[1:-1])\n                        else:\n                            token.name = ln[0]\n                        token.type = \"def\"\n                    elif ln[0] == \"context\":\n                        token.type = \"context\"\n                        token.name = \" \".join(ln[1:-1])\n                    else:\n                        continue\n                    currentParent.children.append(token)\n                    token.parent = currentParent\n                    currentParent = token\n                    newtokenlist.append(token)\n                else:\n                    ends_to_skip += 1\n                \n            elif ln[0] in (\"public\",\"private\",\"protected\"):\n                if len(ln) == 1:\n                    access = ln[0]\n                    \n            if re.search(r\";?\\s*end(?:\\s*$|\\s+(?:while|until))\", line):\n                if ends_to_skip > 0:\n                    ends_to_skip -= 1\n                else:\n                  token = currentParent\n                  token.end = linecount\n                  currentParent = token.parent\n                \n\n        self.tokens = newtokenlist\n        return True\n\n\n\nclass RubyParser( ClassParserInterface ):\n    \n    def __init__(self):\n        self.rubyfile = None\n\n\n    def appendTokenToBrowser(self, token, parentit ):\n        it = self.__browsermodel.append(parentit,(token,))\n        token.path = self.__browsermodel.get_path(it)\n        for child in token.children:\n            self.appendTokenToBrowser(child, it)\n\n\n    def parse(self, doc):\n        \"\"\" \n        Create a gtk.TreeModel with the class elements of the document\n        \n        The parser uses the ctags command from the shell to create a ctags file,\n        then parses the file, and finally populates a treemodel.\n        \"\"\"\n    \n        self.rubyfile = RubyFile(doc)\n        self.rubyfile.parse(options.singleton().verbose)\n        self.__browsermodel = gtk.TreeStore(gobject.TYPE_PYOBJECT)\n        for child in self.rubyfile.children:\n            self.appendTokenToBrowser(child,None)\n        return self.__browsermodel\n\n        \n    def __private_test_method(self):\n        pass\n\n\n    def get_tag_position(self, model, path):\n        return\n        tok = model.get_value( model.get_iter(path), 0 )\n        try: return tok.rubyfile.uri, tok.start+1\n        except: return None\n\n\n    def current_line_changed(self, model, doc, line):\n\n        if abs(self.rubyfile.linestotal - doc.get_line_count()) > 0:\n            if abs(self.rubyfile.linestotal - doc.get_line_count()) > 5:\n                if options.singleton().verbose:\n                    print \"RubyParser: refresh because line dif > 5\"\n                self.rubyfile.parse()\n            else:\n                it = doc.get_iter_at_line(line)\n                a = it.copy(); b = it.copy()\n                a.backward_line(); a.backward_line()\n                b.forward_line(); b.forward_line()\n\n                t = doc.get_text(a,b)\n                if t.find(\"class\") >= 0 or t.find(\"def\") >= 0:\n                    if options.singleton().verbose:\n                        print \"RubyParser: refresh because line cound changed near keyword\"\n                    self.rubyfile.parse()\n \n\n    def get_tag_at_line(self, model, doc, linenumber):\n        t = self.rubyfile.getTokenAtLine(linenumber)\n        if t: return t.path\n\n\n    def cellrenderer(self, column, ctr, model, it):\n\n        \"\"\" Render the browser cell according to the token it represents. \"\"\"\n        tok = model.get_value(it,0)\n\n        weight = 400\n        style = pango.STYLE_NORMAL\n        name = tok.name#+tok.params\n        colour = options.singleton().colours[ \"function\" ]\n\n        if tok.type == \"class\":\n            name = \"class \"+name\n            colour = options.singleton().colours[ \"class\" ]\n            weight = 600\n            \n        elif tok.type == \"module\":\n            name = \"module \"+name\n            colour = options.singleton().colours[ \"namespace\" ]\n            weight = 600\n            \n        elif tok.type == \"describe\":\n            name = \"describe \"+name\n            colour = options.singleton().colours[ \"namespace\" ]\n            weight = 600\n        \n        elif tok.type == \"context\":\n            name = \"context \"+name\n            colour = options.singleton().colours[ \"namespace\" ]\n            weight = 600\n            \n        elif tok.type == \"def\":\n            colour = options.singleton().colours[ \"member\" ]\n            \n        if tok.comment: name = \"#\"+name\n\n        ctr.set_property(\"text\", name)\n        ctr.set_property(\"style\", style)\n        ctr.set_property(\"foreground-gdk\", colour)\n\n\n    def pixbufrenderer(self, column, crp, model, it):\n        tok = model.get_value(it,0)\n\n        icon = \"default\"\n\n        if tok.type == \"class\":\n            icon = \"class\"\n        elif tok.type == \"module\":\n            icon = \"namespace\"\n        elif tok.type == \"describe\":\n            icon = \"namespace\"\n        elif tok.type == \"context\":\n            icon = \"namespace\"\n        elif tok.type == \"def\":\n            if tok.access == \"public\":\n                icon = \"method\"\n            elif tok.access == \"protected\":\n                icon = \"method_prot\"\n            elif tok.access == \"private\":\n                icon = \"method_priv\"\n                \n        crp.set_property(\"pixbuf\",imagelibrary.pixbufs[icon])\n",
  "line_no": 277,
  "line_no_percent": "75%"
}