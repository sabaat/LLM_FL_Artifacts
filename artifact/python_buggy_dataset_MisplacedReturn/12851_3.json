{
  "instruction": "The given code is a Python class called SecureRemoteLauncher that has several methods. To use this class, you need to import the necessary modules and create an instance of the class. Once you have an instance, you can call its methods to perform various tasks. \n\nTo create an instance of the SecureRemoteLauncher class, you need to provide a mapping file path as an argument to the constructor. \n\nTo create a port forwarding ssh tunnel, you can call the createTunnelOnRemotePort method of the SecureRemoteLauncher instance and provide it with a transport object, a remote host, and a port number. \n\nTo rewrite the mapping file with the current session map, you can call the updateMappingFile method of the SecureRemoteLauncher instance. \n\nTo wait for a process to exit so that you can end the tunnel thread and then end the waiting thread by returning from the function, you can call the waitOnChannelExitStatus method of the SecureRemoteLauncher instance and provide it with a channel, a session ID, and a tunnel. \n\nTo start pvweb on a remote machine until you successfully start on a port, you can call the startPvwebOnOpenPortInRange method of the SecureRemoteLauncher instance and provide it with a transport object, a remote host, a file to load, and a port range. This method will try to start pvweb on a port within the given range and return a session ID and the port number if successful.",
  "buggy_code": "import paramiko\nimport select\nimport argparse\nimport sys\nimport threading\nimport uuid\nimport tempfile\nimport os\nimport getpass\n\nfrom ForwardSshTunnel import ForwardSshTunnel\n\n\nclass SecureRemoteLauncher(object) :\n\n    def __init__(self, mapFilePath) :\n        self.mappingFilePath = mapFilePath\n        self.sessionMap = {}\n\n    def createTunnelOnRemotePort(self, transport, host, port) :\n        print 'Create a tunnel on remote port ' + str(port)\n\n        try:\n            tunnel = ForwardSshTunnel(port,       # local port\n                                      host,       # remote host\n                                      port,       # remote port\n                                      transport)  # SSHClient Transport object\n            tunnel.establishForwardTunnel()\n        except KeyboardInterrupt:\n            print 'C-c: Port forwarding stopped.'\n        except Exception as inst :\n            print 'Encountered exception in forwarding'\n            print inst\n\n        print 'Returning from createTunnelOnRemotePort()'\n        return tunnel\n\n    def updateMappingFile(self) :\n        return\n        with open(self.mappingFilePath, 'w') as outfile :\n            for session in self.sessionMap :\n                outfile.write(session + ' ' + self.sessionMap[session] + '\\n')\n\n    def waitOnChannelExitStatus(self, channel, sessionId, tunnel) :\n        processReturnVal = channel.recv_exit_status()\n\n        print 'Channel exit status ready, process has terminated'\n        if tunnel is not None :\n            print 'Attempting to end tunnel request loop...'\n            tunnel.terminateRequestLoop()\n\n        del self.sessionMap[sessionId]\n\n        self.updateMappingFile()\n\n        print 'Returning from wait thread'\n\n    def startPvwebOnOpenPortInRange(self, transport, remoteHost, fileToLoad, portRange) :\n        port = 9010\n\n\n        cmdFirstPart = 'export DISPLAY=:0.0 ; /home/scott/projects/ParaView/build-make-gpu/bin/pvpython /home/scott/projects/ParaView/build-make-gpu/lib/site-packages/paraview/web/pv_web_visualizer.py --data-dir /home/scott/Documents/cosmodata/haloregions --port '\n\n        started = False\n\n        while started == False :\n\n            cmd = cmdFirstPart + str(port) + ' --load-file ' + fileToLoad + ' -f'\n\n            channel = transport.open_session()\n            channel.exec_command(cmd)\n\n            characters = ''\n\n            while True:\n                if channel.exit_status_ready():\n                    break\n\n                rl, wl, xl = select.select([channel],[],[],0.0)\n\n                if len(rl) > 0 :\n                    characters = channel.recv(1024)\n\n                    if 'CannotListenError' in characters or 'Address already in use' in characters :\n                        print 'port ' + str(port) + ' is already being used'\n                    elif ('tarting on ' + str(port)) in characters:\n                        print 'Ahh, we have finally started on port ' + str(port)\n\n                        sessionId = str(uuid.uuid1())\n                        connectStr = 'localhost:' + str(port)\n                        self.sessionMap[sessionId] = connectStr\n                        self.updateMappingFile()\n                        tunnel = self.createTunnelOnRemotePort(transport, remoteHost, port)\n                        print 'Have now returned from readyCallback() !!!!'\n                        t = threading.Thread(target=self.waitOnChannelExitStatus,\n                                             args=[channel, sessionId, tunnel],\n                                             kwargs={})\n                        t.start()\n                        print 'wait thread started, returning from startPvwebOnOpenPortInRange()'\n                        return (sessionId, port)\n                        started = True\n\n            if started == False :\n                port += 1\n\n        print 'Returning from startPvwebOnOpenPortInRange()'\n",
  "line_no": 39,
  "line_no_percent": "37%"
}