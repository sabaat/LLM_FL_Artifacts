{
  "instruction": "Use the given code to extract date information from sentences. The code includes helper functions to normalize annotations, split sentences, tag parts of speech, find key verbs, and extract date information using DBpedia. To use the code, call the main function with appropriate arguments.",
  "buggy_code": "from subprocess import *\nimport re\nimport treetaggerwrapper\nimport sparqlQuerypy\nfrom bs4 import BeautifulSoup\n\nCONSTANTKEYVERBS=\"die, died, death, born, birth, sworn in\" #Set of words that if present in the sentence, then don't discard the sentence, we are interested.\ntagger = treetaggerwrapper.TreeTagger(TAGLANG = 'en', TAGDIR = '/home/vedu29/python/Gsoc/treetagger')\n\n\ndef jarWrapper(*args): # The helper function to use the jar file.\n    process = Popen(['java', '-jar']+list(args), stdout=PIPE, stderr=PIPE)\n    ret=[]\n    while process.poll() is None:\n        line = process.stdout.readline()\n        if line != '' and line.endswith('\\n'):\n            ret.append(line[:-1])\n        stdout, stderr = process.communicate()\n        ret += stdout.split('\\n')\n        if stderr != '':\n            ret += stderr.split('\\n')\n        ret.remove('')\n        return ret\n\ndef returnProperty(word): #helper function to map the verb to a property. This will be small considering the number of date properties in DBpedia.\n    if word in ['death', 'die']: return 'http://dbpedia.org/ontology/deathDate'\n    if word in ['birth', 'born', 'bear']: return 'http://dbpedia.org/ontology/birthDate'\n\n\ndef normalizeAnnotations(sentence): # helper function to remove the references annotation, that appear as square brackets at the end of the sentence.\n    return re.sub(r'\\[[0-9]*\\]', ' ', sentence)\n\ndef sentenceSplitter(sentence): # helper regular function to correctly find end of sentences.\n    return re.split(r'(?<!\\w\\.\\w.)(?<![A-Z][a-z]\\.)(?<=\\.|\\?)\\s', sentence)\n    \ndef normaliseResult(result):\n    return\n    normRes=[]\n    for sentence in result:\n        sent=normalizeAnnotations(sentence)\n        normRes += sentenceSplitter(sent)\n    return normRes\n\ndef findAndGenericAnnotateTime(sentence): #Replacing heidelTime tagged Timex tags to a generic 'TIME' so that treeTagger can work its magic without hiccups.\n    return re.sub('<TIMEX3((?!<TIMEX3).)*</TIMEX3>', 'TIME', sentence)\n\ndef treetag(sentence, encoding = None): # TreeTagger helper function.\n    if encoding != None:\n        return treetaggerwrapper.make_tags(tagger.tag_text(unicode(sentence, \"utf-8\")))\n    else:\n        return treetaggerwrapper.make_tags(tagger.tag_text(sentence))\n\ndef returnKeyverbs(): #formats the key verbs above.\n    return '|'.join(verb for verb in CONSTANTKEYVERBS.split(', '))\n\n\ndef findSubVerbsTime(tagsentence): # The main helper function that figures out the subject in the sentence and finds the correct core verbs marked by an '*'\n    pos=[]\n    pos2=[]\n    seenSubject=False\n    seenVerb=False\n    lastfew=0\n    for i, tags in enumerate(tagsentence):\n        if tags.pos=='NP' or tags.pos=='PP':\n            pos += [tags.word]\n            seenSubject=True\n            lastfew+=1\n        if re.match(u'V..|V.', tags.pos) != None and seenSubject:\n            if not seenVerb:\n                subject = pos[-lastfew:]\n                pos2 += [[subject]]\n            if re.match(u'VB.', tags.pos) != None:\n                pos2[-1] += [tags.word]\n            else:\n                pos2[-1] += [tags.word+'*']\n                seenVerb=True\n        if re.match(u'V..|V.', tags.pos) == None and seenVerb:\n            seenVerb=False\n            seenSubject=False\n            lastfew=0\n    return pos2\n\ndef lemmatizeMainVerb(item):\n    for verb in item[1:]:\n        if '*' in verb:\n            return treetag(verb)[0].lemma\n\n\ndef listTimes(sentence): # uses beautiful soup to get the date information.\n    soup = BeautifulSoup(sentence, 'html.parser')\n    return soup.find_all('timex3')\n\n\ndef main(args):\n    result = jarWrapper(*args)\n    for sentence in normaliseResult(result):\n        \n        sent=findAndGenericAnnotateTime(sentence)\n    \n        m = re.match(r\"(?P<first_part>.*) (?P<predicate>%s) (?P<second_part>.*)\"%(returnKeyverbs()), sent) #scans the sentences for this pattern.\n        if m!=None:       \n\n            left=treetag(m.group('first_part'), \"utf-8\")\n            middle=treetag(m.group('predicate'), \"utf-8\")\n            right=treetag(m.group('second_part'), \"utf-8\")\n            tagsentence = left + middle + right\n\n            if 'TIME' in m.group('first_part') or 'TIME' in m.group('second_part'): #Skip sentence if not date details.\n\n                subVerbTime = findSubVerbsTime(tagsentence)\n                for item in subVerbTime:\n                    subject=\" \".join(thing for thing in item[0])\n                    if subject.lower() in ['he','she', 'it']:\n                        subject=previousSubject\n                    annotate = sparqlQuerypy.findAnnotation(subject)\n                    annotatedSubject = annotate[0]['s']['value']\n                    previousSubject = subject  #heuristic that subject of this pronoun is in deed the previous subject, (not well thought through!)\n                    verbLemma=lemmatizeMainVerb(item)\n                    if verbLemma != None: prop=returnProperty(verbLemma)\n\n                timexList = listTimes(sentence)\n\n                i=0\n                while timexList[i]['type']not in [\"DATE\",\"TIME\"]:\n                    i+=1\n                time= timexList[i]['value']\n                date= sparqlQuerypy.findDate(annotatedSubject, prop)\n                if len(date) != 0:\n                    date= date[0]['z']['value']\n                    print '- - - - - - - - - - - - - - - - \\n \\n'\n                    print sentence\n                    print '     '\n                    print 'The subject is:', subject\n                    print 'The annotated subject is:', annotatedSubject\n                    print 'The property is:', prop\n                    print 'Date according to dbpedia:', date\n                    print 'Date mined from the text:', time\n                    print '\\n \\n'\n\nif __name__=='__main__':\n    args = ['de.unihd.dbs.heideltime.standalone.jar', 'input']\n    result = jarWrapper(*args)\n    tagger = treetaggerwrapper.TreeTagger(TAGLANG = 'en', TAGDIR = '/home/vedu29/python/Gsoc/treetagger')\n    \n    main(args)\n",
  "line_no": 37,
  "line_no_percent": "26%"
}