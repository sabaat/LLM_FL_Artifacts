{
  "instruction": "This code contains various utility functions and classes for data processing and analysis. It includes functions for logging data to screen and file, file manipulation, plotting utilities, and math functions. It also includes a class for iterating over pairs of lists and tools for building with GSL and Cython. To use this code, simply import the necessary functions and classes into your own Python script.",
  "buggy_code": "import sys\n\nfrom os import listdir, mkdir\nfrom os.path import isdir, dirname, abspath\n\nimport os\nimport subprocess\n\nimport weakref\n\nfrom scipy import fftpack\nimport numpy as np\n\ndefault_raw_data_loc = None#\"/exp_app2/appexp1/public/raw_data\"\ndefault_processed_data_loc = None#\"/home/brian/processed_files\"\n\nMetaData_directory =  dirname(abspath(__file__)) + '/data' ## change this if antenna_response_model is in a folder different from this module\n\nC = 299792458.0\nRTD = 180.0/3.1415926 ##radians to degrees\nn_air = 1.000293\nv_air = C/n_air\n\nlatlonCS002 = np.array([52.91512249, 6.869837540]) ## lattitude and longitude of CS002 in degrees\n\n\nclass logger(object):\n    class std_writer(object):\n        def __init__(self, logger):\n            self.logger_ref = weakref.ref(logger)\n            \n        def write(self, msg):\n            logger=self.logger_ref()\n            logger.out_file.write(msg)\n            if logger.to_screen:\n                logger.old_stdout.write(msg)\n            \n        def flush(self):\n            logger=self.logger_ref()\n            logger.out_file.flush()\n    \n    \n    def __init__(self):\n        \n        self.has_stderr = False\n        self.has_stdout = False\n        \n        self.old_stderr = sys.stderr\n        self.old_stdout = sys.stdout\n        \n        self.set(\"out_log\")\n        \n    def set(self, fname, to_screen=True):\n        self.out_file = open(fname, 'w')\n        \n        self.set_to_screen( to_screen )\n        \n        \n    def __call__(self, *args):\n        for a in args:\n            if self.to_screen:\n                self.old_stdout.write(str(a))\n                self.old_stdout.write(\" \")\n                \n            self.out_file.write(str(a))\n            self.out_file.write(\" \")\n            \n        self.out_file.write(\"\\n\")\n        if self.to_screen:\n            self.old_stdout.write(\"\\n\")\n            \n        self.out_file.flush()\n        self.old_stdout.flush()\n        \n    def set_to_screen(self, to_screen=True):\n        self.to_screen = to_screen\n        \n    def take_stdout(self):\n        \n        if not self.has_stdout:\n            sys.stdout = self.std_writer(self)\n            self.has_stdout = True\n\t\t\t\t\t\t\t\n    def take_stderr(self):\n        \n        if not self.has_stderr:\n            sys.stderr = self.std_writer(self)\n            self.has_stderr = True\n            \n    def restore_stdout(self):\n        if self.has_stdout:\n            sys.stdout = self.old_stdout\n            self.has_stdout = False\n            \n    def restore_stderr(self):\n        if self.has_stderr:\n            sys.stderr = self.old_stderr\n            self.has_stderr = False\n            \n    def flush(self):\n        self.out_file.flush()\n            \n        \n        \ndef iterate_pairs(list_one, list_two, list_one_avoid=[], list_two_avoid=[]):\n    \"\"\"returns an iterator that loops over all pairs of the two lists\"\"\"\n    for item_one in list_one:\n        if item_one in list_one_avoid:\n            continue\n        for item_two in list_two:\n            if item_two in list_two_avoid:\n                continue\n            yield (item_one, item_two)\n        \nimport re\nnatural_regex_pattern = re.compile('([0-9]+)')\ndef natural_sort( l ):\n    return\n    \"\"\" Sort the given iterable in the way that humans expect. Usefull for sorting station names.\"\"\"\n    convert = lambda text: int(text) if text.isdigit() else text\n    alphanum_key = lambda key: [ convert(c) for c in natural_regex_pattern.split(key) ]\n    return sorted(l, key = alphanum_key)\n        \n\ndef Fname_data(Fpath):\n    \"\"\" takes both pulse data file names and h5 file names and returns UTC_time, station_name, Fpath\"\"\"\n    Fname = Fpath.split('/')[-1]\n    data = Fname.split('_')\n    timeID = data[1]\n    station_name = data[2]\n    \n    if len(data[3][1:])==0:\n        file_number = 0\n    else:\n        file_number = int(data[3][1:])\n    \n    return timeID, station_name, Fpath, file_number\n\n\n\ndef get_timeID(fname):\n    data=fname.split(\"_\")\n    return data[1]\n\ndef year_from_timeID(timeID):\n    return timeID[1:5]\n\ndef raw_data_dir(timeID, data_loc=None):\n    \"\"\"gives path to the raw data folder for a particular timeID, given location of data structure. Defaults to  default_raw_data_loc\"\"\"\n    \n    if data_loc is None:\n        data_loc = default_raw_data_loc\n        if default_raw_data_loc is None:\n            print(\"ERROR: 'default_raw_data_loc' in utilities is not set.\")\n            quit()\n    \n    path = data_loc + '/' + year_from_timeID(timeID)+\"/\"+timeID\n    return path\n\ndef processed_data_dir(timeID, data_loc=None):\n    \"\"\"gives path to the analysis folders for a particular timeID, given location of data structure. Defaults to  default_processed_data_loc\n    makes the directory if it doesn't exist\"\"\"\n    \n    if data_loc is None:\n        data_loc = default_processed_data_loc\n        if default_processed_data_loc is None:\n            print(\"ERROR: 'default_processed_data_loc' in utilities is not set.\")\n            quit()\n    \n    path=data_loc + \"/\" + year_from_timeID(timeID)+\"/\"+timeID\n    if not isdir(path):\n        mkdir(path)\n    return path\n\n    \nSId_to_Sname = [None]*209 #just to pre-initilize list, so syntax below is possible\nSId_to_Sname[1] = \"CS001\"\nSId_to_Sname[2] = \"CS002\"\nSId_to_Sname[3] = \"CS003\"\nSId_to_Sname[4] = \"CS004\"\nSId_to_Sname[5] = \"CS005\"\nSId_to_Sname[6] = \"CS006\"\nSId_to_Sname[7] = \"CS007\"\nSId_to_Sname[11] = \"CS011\"\nSId_to_Sname[13] = \"CS013\"\nSId_to_Sname[17] = \"CS017\"\nSId_to_Sname[21] = \"CS021\"\nSId_to_Sname[24] = \"CS024\"\nSId_to_Sname[26] = \"CS026\"\nSId_to_Sname[28] = \"CS028\"\nSId_to_Sname[30] = \"CS030\"\nSId_to_Sname[31] = \"CS031\"\nSId_to_Sname[32] = \"CS032\"\nSId_to_Sname[101] = \"CS101\"\nSId_to_Sname[103] = \"CS103\"\nSId_to_Sname[121] = \"CS201\"\nSId_to_Sname[141] = \"CS301\"\nSId_to_Sname[142] = \"CS302\"\nSId_to_Sname[161] = \"CS401\"\nSId_to_Sname[181] = \"CS501\"\n\nSId_to_Sname[106] = \"RS106\"\nSId_to_Sname[125] = \"RS205\"\nSId_to_Sname[128] = \"RS208\"\nSId_to_Sname[130] = \"RS210\"\nSId_to_Sname[145] = \"RS305\"\nSId_to_Sname[146] = \"RS306\"\nSId_to_Sname[147] = \"RS307\"\nSId_to_Sname[150] = \"RS310\"\nSId_to_Sname[166] = \"RS406\"\nSId_to_Sname[167] = \"RS407\"\nSId_to_Sname[169] = \"RS409\"\nSId_to_Sname[183] = \"RS503\"\nSId_to_Sname[188] = \"RS508\"\nSId_to_Sname[189] = \"RS509\"\n\nSId_to_Sname[201] = \"DE601\"\nSId_to_Sname[202] = \"DE602\"\nSId_to_Sname[203] = \"DE603\"\nSId_to_Sname[204] = \"DE604\"\nSId_to_Sname[205] = \"DE605\"\nSId_to_Sname[206] = \"FR606\"\nSId_to_Sname[207] = \"SE607\"\nSId_to_Sname[208] = \"UK608\"\n\nSname_to_SId_dict = {name:ID for ID,name in enumerate(SId_to_Sname) if name is not None}\n\ndef even_antName_to_odd(even_ant_name):\n    even_num = int(even_ant_name)\n    odd_num = even_num + 1\n    return str( odd_num ).zfill( 9 )\n\ndef antName_is_even(ant_name):\n    return not int(ant_name)%2\n\ndef odd_antName_to_even(odd_ant_name):\n    odd_num = int(odd_ant_name)\n    even_num = odd_num + 1\n    return str( even_num ).zfill( 9 )\n    \n\ndef set_axes_equal(ax):\n    '''Make axes of 3D plot have equal scale so that spheres appear as spheres,\n    cubes as cubes, etc..  This is one possible solution to Matplotlib's\n    ax.set_aspect('equal') and ax.axis('equal') not working for 3D.\n    \n    \n\n    Input\n      ax: a matplotlib axis, e.g., as output from plt.gca().\n    '''\n\n    x_limits = ax.get_xlim3d()\n    y_limits = ax.get_ylim3d()\n    z_limits = ax.get_zlim3d()\n\n    x_range = abs(x_limits[1] - x_limits[0])\n    x_middle = np.mean(x_limits)\n    y_range = abs(y_limits[1] - y_limits[0])\n    y_middle = np.mean(y_limits)\n    z_range = abs(z_limits[1] - z_limits[0])\n    z_middle = np.mean(z_limits)\n\n    plot_radius = 0.5*max([x_range, y_range, z_range])\n\n    ax.set_xlim3d([x_middle - plot_radius, x_middle + plot_radius])\n    ax.set_ylim3d([y_middle - plot_radius, y_middle + plot_radius])\n    ax.set_zlim3d([z_middle - plot_radius, z_middle + plot_radius])\n\n    \n    \ndef normalize_angle_radians( angle_radians ):\n    \"\"\"For an angle in radians, return the equivalent angle that is garunteed be between -pi and pi\"\"\"\n    while angle_radians > np.pi:\n        angle_radians -= 2.0*np.pi\n    while angle_radians < -np.pi:\n        angle_radians += 2.0*np.pi\n    return angle_radians\n\ndef BoundingBox_collision(BB1, BB2):\n    \"\"\" return true if two N-D bounding boxes collide, False otherwise\"\"\"\n    for B1, B2 in zip(BB1,BB2):\n        if (B1[1] < B2[0]) or (B2[1] < B1[0]):\n            return False\n    return True\n\ndef GSL_include():\n    \"\"\"return directory for location of GSL headers, useful when combining GSL and cython\"\"\"\n    \n    try:\n        gsl_include = subprocess.check_output('gsl-config --cflags', shell=True).decode('utf-8')[2:-1]\n    except subprocess.CalledProcessError:\n        gsl_include = os.getenv('LIB_GSL')\n        if gsl_include is None:\n            gsl_include = r\"c:\\Program Files\\GnuWin32\\include\"\n        else:\n            gsl_include += \"/include\"\n\n    assert gsl_include != '', \"Couldn't find gsl. Make sure it's installed and in the path.\"\n\n    return gsl_include\n\n\ndef GSL_library_dir():\n    \"\"\"return directory for location of GSL binaries, useful when combining GSL and cython\"\"\"\n    try:\n        lib_gsl_dir = subprocess.check_output('gsl-config --libs', shell=True).decode('utf-8').split()[0][2:]\n    except subprocess.CalledProcessError:\n        lib_gsl_dir = os.getenv('LIB_GSL')\n        if lib_gsl_dir is None:\n            lib_gsl_dir = r\"c:\\Program Files\\GnuWin32\\lib\"\n        else:\n            lib_gsl_dir += \"/lib\"\n\n    return lib_gsl_dir\n",
  "line_no": 118,
  "line_no_percent": "37%"
}