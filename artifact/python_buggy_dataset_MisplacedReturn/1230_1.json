{
  "instruction": "Create a PipelineManager class with methods to list, get, install, and delete pipelines. The install method should take a pipeline ID and start the installation of the pipeline in another thread. The delete method should start the uninstallation of the pipeline in another thread and remove the image file if it exists. The class should import several modules and classes, including ipdb, os, shutil, json, zipfile, datetime, time, uuid, subprocess, requests, config, common, postgresql, and model.",
  "buggy_code": "try:\n    import ipdb\nexcept ImportError:\n    pass\n\n\nimport os\nimport shutil\nimport json\nimport zipfile\nimport datetime\nimport time\nimport uuid\nimport subprocess\nimport requests\n\n\n\nfrom config import *\nfrom core.framework.common import *\nfrom core.framework.postgresql import execute\nfrom core.model import *\n\n\n\n\n\nclass PipelineManager:\n    def __init__(self):\n        return\n        pass\n\n\n    def list(self):\n        \"\"\"\n            List all pipelines with minimum of data\n        \"\"\"\n        sql = \"SELECT id, name, type, status, description, version, image_file_id, starred, installation_date, manifest, documents FROM pipeline ORDER BY id\"\n        result = []\n        for res in execute(sql): \n            result.append({\n                \"id\": res.id,\n                \"name\": res.name,\n                \"description\": res.description,\n                \"type\": res.type,\n                \"status\": res.status,\n                \"version\": res.version,\n                \"image_file_id\": res.image_file_id,\n                \"starred\": res.starred,\n                \"installation_date\": res.installation_date.isoformat(),\n                \"manifest\": res.manifest,\n                \"documents\": res.documents\n            })\n        return result\n\n    def get(self, fields=None, query=None, order=None, offset=None, limit=None, depth=0):\n        \"\"\"\n            Generic method to get pipelines according provided filtering options\n        \"\"\"\n        if not isinstance(fields, dict):\n            fields = None\n        if query is None:\n            query = {}\n        if order is None:\n            order = \"name, installation_date desc\"\n        if offset is None:\n            offset = 0\n        if limit is None:\n            limit = RANGE_MAX\n        pipes = Session().query(Pipeline).filter_by(**query).order_by(order).limit(limit).offset(offset).all()\n        for p in pipes: p.init(depth)\n        return pipes\n\n\n\n    def install_init (self, name, metadata={}):\n        pipe = Pipeline.new()\n        pipe.name = name\n        pipe.status = \"initializing\"\n        pipe.save()\n\n        if metadata and len(metadata) > 0:\n            pipe.load(metadata)\n        log('core.PipeManager.register : New pipe registered with the id {}'.format(pipe.id))\n        return pipe\n\n\n\n    def install_init_image_upload(self, filepath, file_size, pipe_metadata={}):\n        \"\"\" \n            Initialise a pipeline installation. \n            To use if the image have to be uploaded on the server.\n            Create an entry for the pipeline and the file (image that will be uploaded) in the database.\n            Return the Pipeline and the File objects created\n\n            This method shall be used to init a resumable upload of a pipeline \n            (the pipeline/image are not yet installed and available, but we need to manipulate them)\n        \"\"\"\n        from core.core import core\n\n        pfile = core.files.upload_init(filepath, file_size)\n        pipe = self.install_init(filepath, pipe_metadata)\n        pipe.image_file_id = pfile.id\n        pipe.save()\n        return pipe, pfile\n\n\n\n    async def install_init_image_url(self, url, pipe_metadata={}):\n        \"\"\" \n            Initialise a pipeline installation. \n            To use if the image have to be retrieved via an url.\n            Create an entry for the pipeline and the file (image) in the database.\n            Async method as the download start immediatly, followed by the installation when it's done\n\n            Return the Pipeline object ready to be used\n        \"\"\"\n        raise NotImplementedError(\"TODO\")\n\n\n\n    def install_init_image_local(self, filepath, move=False, pipe_metadata={}):\n        \"\"\" \n            Initialise a pipeline installation. \n            To use if the image have to be retrieved on the local server.\n            Create an entry for the pipeline and the file (image) in the database.\n            Copy the local file into dedicated directory and start the installation of the Pipeline\n\n            Return the Pipeline object ready to be used\n        \"\"\"\n        from core.core import core\n\n        pfile = core.files.from_local(filepath, move)\n        pipe = self.install_init(os.path.basename(filepath), pipe_metadata)\n\n        check_session(pfile)\n        check_session(pipe)\n\n        pipe.image_file_id = pfile.id\n        pipe.save()\n        return pipe\n\n\n    def install_init_image(self, file_id, pipe_metadata={}):\n        \"\"\" \n            Initialise a pipeline installation. \n            To use if the image have already been uploaded the local server via the regovar file api.\n            Create an entry for the pipeline in the database.\n            Return the Pipeline object ready to be used\n        \"\"\"\n        from core.core import core\n\n        pfile = File.from_id(file_id)\n        if pfile:\n            pipe = self.install_init(os.path.basename(pfile.path), pipe_metadata)\n            pipe.image_file_id = file_id\n            pipe.save()\n            return pipe\n        return None\n    \n\n\n    def check_manifest(self, manifest):\n        \"\"\"\n            Check that manifest (json) is valid and return the full version completed \n            with default values if needed\n        \"\"\"\n        missing = \"\"\n        for k in [\"name\", \"version\"]:\n            if k not in manifest.keys():\n                missing += k + \", \"                \n        if missing != \"\":\n            missing = missing[:-2]\n            raise RegovarException(\"FAILLED Checking validity of manifest (missing : {})\".format(missing))\n\n        default = {\n            \"description\": \"\",\n            \"type\": \"job\",\n            \"contacts\": [],\n            \"regovar_db_access\": False,\n            \"inputs\": \"/pipeline/inputs\",\n            \"outputs\": \"/pipeline/outputs\",\n            \"databases\": \"/pipeline/databases\",\n            \"logs\": \"/pipeline/logs\"\n        }\n        for k in default.keys():\n            if k not in manifest.keys():\n                manifest[k] = default[k]\n\n        if manifest[\"type\"] not in [\"job\", \"importer\", \"exporter\", \"reporter\"]:\n            raise RegovarException(\"FAILLED Checking validity of manifest (type '{}' not supported)\".format(manifest[\"type\"]))\n\n\n        log('Validity of manifest checked')\n        return manifest\n\n\n\n    def install(self, pipeline_id, asynch=True):\n        \"\"\"\n            Start the installation of the pipeline. (done in another thread)\n            The initialization shall be done (image ready to be used)\n        \"\"\"\n        from core.core import core\n\n        pipeline = Pipeline.from_id(pipeline_id, 1)\n        if not pipeline : \n            raise RegovarException(\"Pipeline not found (id={}).\".format(pipeline_id))\n        if pipeline.status != \"initializing\":\n            raise RegovarException(\"Pipeline status ({}) is not \\\"initializing\\\". Cannot perform another installation.\".format(pipeline.status))\n        if pipeline.image_file and pipeline.image_file.status not in [\"uploaded\", \"checked\"]:\n            raise RegovarException(\"Wrong pipeline image (status={}).\".format(pipeline.image_file.status))\n\n        if not pipeline.image_file or pipeline.image_file.status in [\"uploaded\", \"checked\"]:\n            if asynch:\n                run_async(self.__install, pipeline)\n            else:\n                pipeline = self.__install(pipeline)\n\n        return pipeline\n\n\n    def __install(self, pipeline):\n        from core.core import core\n        root_path = os.path.join(PIPELINES_DIR, str(pipeline.id))\n        log('Installation of the pipeline package : ' + root_path)\n        os.makedirs(root_path)\n        os.chmod(pipeline.image_file.path, 0o777)\n\n        with zipfile.ZipFile(pipeline.image_file.path,\"r\") as zip_ref:\n            zip_ref.extractall(root_path)\n\n            files = [i.filename for i in zip_ref.infolist()]\n            for f in files:\n                if f.endswith(\"manifest.json\"): break\n            zip_root = os.path.dirname(f)\n            if zip_root != \"\":\n                zip_root = os.path.join(root_path, zip_root)\n                for filename in os.listdir(zip_root):\n                    shutil.move(os.path.join(zip_root, filename), os.path.join(root_path, filename))\n                os.rmdir(zip_root)\n\n        try:\n            log(os.path.join(root_path, \"manifest.json\"))\n            with open(os.path.join(root_path, \"manifest.json\"), \"r\") as f:\n                data = f.read()\n                log(data)\n                data = data.replace(\"False\", \"false\")\n                data = data.replace(\"True\", \"true\")\n                manifest = json.loads(data)\n                manifest = self.check_manifest(manifest)\n                pipeline.developpers = manifest.pop(\"contacts\")\n                pipeline.manifest = manifest \n\n                pipeline.documents = {\n                    \"about\": os.path.join(root_path, \"doc/about.html\"),\n                    \"help\": os.path.join(root_path, \"doc/help.html\"),\n                    \"icon\": os.path.join(root_path, \"doc/icon.png\"),\n                    \"icon2\": os.path.join(root_path, \"doc/icon.jpg\"),\n                    \"form\": os.path.join(root_path, \"form.json\"),\n                    \"license\":os.path.join(root_path, \"LICENSE\"),\n                    \"readme\": os.path.join(root_path, \"README\")\n                }\n                for k in pipeline.documents.keys():\n                    if not os.path.exists(pipeline.documents[k]):\n                        pipeline.documents[k] = None\n                p = pipeline.documents.pop(\"icon2\")\n                if not pipeline.documents[\"icon\"]:\n                    pipeline.documents[\"icon\"] = p\n                pipeline.load(manifest)\n                pipeline.save()\n        except Exception as ex:\n            pipeline.status = \"error\"\n            pipeline.save()\n            raise RegovarException(\"Unable to open and read manifest.json. The pipeline package is wrong or corrupt.\", exception=ex)\n        \n        pipeline.type = manifest[\"type\"]\n        pipeline.installation_date = datetime.datetime.now()\n        pipeline.status = \"installing\"\n        pipeline.save()\n        \n        result = core.container_manager.install_pipeline(pipeline)\n        return result\n\n\n\n\n    def delete(self, pipeline_id, asynch=True):\n        \"\"\"\n            Start the uninstallation of the pipeline. (done in another thread)\n            Remove image file if exists.\n        \"\"\"\n        from core.core import core\n\n        result = None\n        pipeline = Pipeline.from_id(pipeline_id, 1)\n        if pipeline:\n            result = pipeline.to_json()\n            try:\n                if asynch: \n                    run_async(self.__delete, pipeline) \n                else: \n                    self.__delete(pipeline)\n            except Exception as ex:\n                war(\"core.PipelineManager.delete : Container manager failed to delete the container with id {}.\".format(pipeline.id))\n            try:\n                shutil.rmtree(pipeline.path, True)\n                core.files.delete(pipeline.image_file_id)\n                Pipeline.delete(pipeline.id)\n            except Exception as ex:\n                raise RegovarException(\"core.PipelineManager.delete : Unable to delete the pipeline's pirus data for the pipeline {}.\".format(pipeline.id), ex)\n        return result\n\n\n    def __delete(self, pipeline):\n        from core.core import core\n        \n        try:\n            core.container_manager.uninstall_pipeline(pipeline)\n        except Exception as ex:\n            raise RegovarException(\"Error occured during uninstallation of the pipeline. Uninstallation aborded.\", ex)\n",
  "line_no": 30,
  "line_no_percent": "9%"
}