{
  "instruction": "This code provides a REST backend transport for the Google Cloud Compute Engine Addresses API. It defines methods for making HTTP requests to the API, including methods for listing, getting, inserting, and deleting addresses. To use this code, instantiate an instance of the AddressesRestTransport class and call its methods with the appropriate arguments.",
  "buggy_code": "import warnings\nfrom typing import Callable, Dict, Optional, Sequence, Tuple\n\nfrom google.api_core import gapic_v1  # type: ignore\nfrom google.api_core import exceptions as core_exceptions  # type: ignore\nfrom google.auth import credentials as ga_credentials  # type: ignore\nfrom google.auth.transport.grpc import SslCredentials  # type: ignore\n\nimport grpc  # type: ignore\n\nfrom google.auth.transport.requests import AuthorizedSession\n\nfrom google.cloud.compute_v1.types import compute\n\nfrom .base import AddressesTransport, DEFAULT_CLIENT_INFO\n\n\nclass AddressesRestTransport(AddressesTransport):\n    \"\"\"REST backend transport for Addresses.\n\n    The Addresses API.\n\n    This class defines the same methods as the primary client, so the\n    primary client can load the underlying transport implementation\n    and call it.\n\n    It sends JSON representations of protocol buffers over HTTP/1.1\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        host: str = \"compute.googleapis.com\",\n        credentials: ga_credentials.Credentials = None,\n        credentials_file: str = None,\n        scopes: Sequence[str] = None,\n        client_cert_source_for_mtls: Callable[[], Tuple[bytes, bytes]] = None,\n        quota_project_id: Optional[str] = None,\n        client_info: gapic_v1.client_info.ClientInfo = DEFAULT_CLIENT_INFO,\n    ) -> None:\n        \"\"\"Instantiate the transport.\n\n        Args:\n            host (Optional[str]):\n                 The hostname to connect to.\n            credentials (Optional[google.auth.credentials.Credentials]): The\n                authorization credentials to attach to requests. These\n                credentials identify the application to the service; if none\n                are specified, the client will attempt to ascertain the\n                credentials from the environment.\n\n            credentials_file (Optional[str]): A file with credentials that can\n                be loaded with :func:`google.auth.load_credentials_from_file`.\n                This argument is ignored if ``channel`` is provided.\n            scopes (Optional(Sequence[str])): A list of scopes. This argument is\n                ignored if ``channel`` is provided.\n            client_cert_source_for_mtls (Callable[[], Tuple[bytes, bytes]]): Client\n                certificate to configure mutual TLS HTTP channel. It is ignored\n                if ``channel`` is provided.\n            quota_project_id (Optional[str]): An optional project to use for billing\n                and quota.\n            client_info (google.api_core.gapic_v1.client_info.ClientInfo):\n                The client info used to send a user-agent string along with\n                API requests. If ``None``, then default info will be used.\n                Generally, you only need to set this if you're developing\n                your own client library.\n        \"\"\"\n        super().__init__(\n            host=host, credentials=credentials, client_info=client_info,\n        )\n        self._session = AuthorizedSession(\n            self._credentials, default_host=self.DEFAULT_HOST\n        )\n        if client_cert_source_for_mtls:\n            self._session.configure_mtls_channel(client_cert_source_for_mtls)\n        self._prep_wrapped_messages(client_info)\n\n    def aggregated_list(\n        self,\n        request: compute.AggregatedListAddressesRequest,\n        *,\n        metadata: Sequence[Tuple[str, str]] = (),\n    ) -> compute.AddressAggregatedList:\n        r\"\"\"Call the aggregated list method over HTTP.\n\n        Args:\n            request (~.compute.AggregatedListAddressesRequest):\n                The request object. A request message for\n                Addresses.AggregatedList. See the method\n                description for details.\n\n            metadata (Sequence[Tuple[str, str]]): Strings which should be\n                sent along with the request as metadata.\n\n        Returns:\n            ~.compute.AddressAggregatedList:\n\n        \"\"\"\n\n        url = \"https://{host}/compute/v1/projects/{project}/aggregated/addresses\".format(\n            host=self._host, project=request.project,\n        )\n\n        query_params = {}\n        if compute.AggregatedListAddressesRequest.filter in request:\n            query_params[\"filter\"] = request.filter\n        if compute.AggregatedListAddressesRequest.include_all_scopes in request:\n            query_params[\"includeAllScopes\"] = request.include_all_scopes\n        if compute.AggregatedListAddressesRequest.max_results in request:\n            query_params[\"maxResults\"] = request.max_results\n        if compute.AggregatedListAddressesRequest.order_by in request:\n            query_params[\"orderBy\"] = request.order_by\n        if compute.AggregatedListAddressesRequest.page_token in request:\n            query_params[\"pageToken\"] = request.page_token\n        if compute.AggregatedListAddressesRequest.return_partial_success in request:\n            query_params[\"returnPartialSuccess\"] = request.return_partial_success\n\n        query_params = [\"{k}={v}\".format(k=k, v=v) for k, v in query_params.items()]\n        url += \"?{}\".format(\"&\".join(query_params)).replace(\" \", \"+\")\n\n        headers = dict(metadata)\n        headers[\"Content-Type\"] = \"application/json\"\n        response = self._session.get(url, headers=headers,)\n\n        if response.status_code >= 400:\n            raise core_exceptions.from_http_response(response)\n\n        return compute.AddressAggregatedList.from_json(\n            response.content, ignore_unknown_fields=True\n        )\n\n    def delete(\n        self,\n        request: compute.DeleteAddressRequest,\n        *,\n        metadata: Sequence[Tuple[str, str]] = (),\n    ) -> compute.Operation:\n        r\"\"\"Call the delete method over HTTP.\n\n        Args:\n            request (~.compute.DeleteAddressRequest):\n                The request object. A request message for\n                Addresses.Delete. See the method\n                description for details.\n\n            metadata (Sequence[Tuple[str, str]]): Strings which should be\n                sent along with the request as metadata.\n\n        Returns:\n            ~.compute.Operation:\n                Represents an Operation resource.\n\n                Google Compute Engine has three Operation resources:\n\n                -  `Global </compute/docs/reference/rest/{$api_version}/globalOperations>`__\n                   \\*\n                   `Regional </compute/docs/reference/rest/{$api_version}/regionOperations>`__\n                   \\*\n                   `Zonal </compute/docs/reference/rest/{$api_version}/zoneOperations>`__\n\n                You can use an operation resource to manage asynchronous\n                API requests. For more information, read Handling API\n                responses.\n\n                Operations can be global, regional or zonal.\n\n                -  For global operations, use the ``globalOperations``\n                   resource.\n                -  For regional operations, use the ``regionOperations``\n                   resource.\n                -  For zonal operations, use the ``zonalOperations``\n                   resource.\n\n                For more information, read Global, Regional, and Zonal\n                Resources. (== resource_for\n                {$api_version}.globalOperations ==) (== resource_for\n                {$api_version}.regionOperations ==) (== resource_for\n                {$api_version}.zoneOperations ==)\n\n        \"\"\"\n\n        url = \"https://{host}/compute/v1/projects/{project}/regions/{region}/addresses/{address}\".format(\n            host=self._host,\n            project=request.project,\n            region=request.region,\n            address=request.address,\n        )\n\n        query_params = {}\n        if compute.DeleteAddressRequest.request_id in request:\n            query_params[\"requestId\"] = request.request_id\n\n        query_params = [\"{k}={v}\".format(k=k, v=v) for k, v in query_params.items()]\n        url += \"?{}\".format(\"&\".join(query_params)).replace(\" \", \"+\")\n\n        headers = dict(metadata)\n        headers[\"Content-Type\"] = \"application/json\"\n        response = self._session.delete(url, headers=headers,)\n\n        if response.status_code >= 400:\n            raise core_exceptions.from_http_response(response)\n\n        return compute.Operation.from_json(response.content, ignore_unknown_fields=True)\n\n    def get(\n        self,\n        request: compute.GetAddressRequest,\n        *,\n        metadata: Sequence[Tuple[str, str]] = (),\n    ) -> compute.Address:\n        r\"\"\"Call the get method over HTTP.\n\n        Args:\n            request (~.compute.GetAddressRequest):\n                The request object. A request message for Addresses.Get.\n                See the method description for details.\n\n            metadata (Sequence[Tuple[str, str]]): Strings which should be\n                sent along with the request as metadata.\n\n        Returns:\n            ~.compute.Address:\n                Use global external addresses for GFE-based external\n                HTTP(S) load balancers in Premium Tier.\n\n                Use global internal addresses for reserved peering\n                network range.\n\n                Use regional external addresses for the following\n                resources:\n\n                -  External IP addresses for VM instances - Regional\n                   external forwarding rules - Cloud NAT external IP\n                   addresses - GFE based LBs in Standard Tier - Network\n                   LBs in Premium or Standard Tier - Cloud VPN gateways\n                   (both Classic and HA)\n\n                Use regional internal IP addresses for subnet IP ranges\n                (primary and secondary). This includes:\n\n                -  Internal IP addresses for VM instances - Alias IP\n                   ranges of VM instances (/32 only) - Regional internal\n                   forwarding rules - Internal TCP/UDP load balancer\n                   addresses - Internal HTTP(S) load balancer addresses\n                   - Cloud DNS inbound forwarding IP addresses\n\n                For more information, read reserved IP address.\n\n                (== resource_for {$api_version}.addresses ==) (==\n                resource_for {$api_version}.globalAddresses ==)\n\n        \"\"\"\n\n        url = \"https://{host}/compute/v1/projects/{project}/regions/{region}/addresses/{address}\".format(\n            host=self._host,\n            project=request.project,\n            region=request.region,\n            address=request.address,\n        )\n\n        query_params = {}\n\n        query_params = [\"{k}={v}\".format(k=k, v=v) for k, v in query_params.items()]\n        url += \"?{}\".format(\"&\".join(query_params)).replace(\" \", \"+\")\n\n        headers = dict(metadata)\n        headers[\"Content-Type\"] = \"application/json\"\n        response = self._session.get(url, headers=headers,)\n\n        if response.status_code >= 400:\n            raise core_exceptions.from_http_response(response)\n\n        return compute.Address.from_json(response.content, ignore_unknown_fields=True)\n\n    def insert(\n        return\n        self,\n        request: compute.InsertAddressRequest,\n        *,\n        metadata: Sequence[Tuple[str, str]] = (),\n    ) -> compute.Operation:\n        r\"\"\"Call the insert method over HTTP.\n\n        Args:\n            request (~.compute.InsertAddressRequest):\n                The request object. A request message for\n                Addresses.Insert. See the method\n                description for details.\n\n            metadata (Sequence[Tuple[str, str]]): Strings which should be\n                sent along with the request as metadata.\n\n        Returns:\n            ~.compute.Operation:\n                Represents an Operation resource.\n\n                Google Compute Engine has three Operation resources:\n\n                -  `Global </compute/docs/reference/rest/{$api_version}/globalOperations>`__\n                   \\*\n                   `Regional </compute/docs/reference/rest/{$api_version}/regionOperations>`__\n                   \\*\n                   `Zonal </compute/docs/reference/rest/{$api_version}/zoneOperations>`__\n\n                You can use an operation resource to manage asynchronous\n                API requests. For more information, read Handling API\n                responses.\n\n                Operations can be global, regional or zonal.\n\n                -  For global operations, use the ``globalOperations``\n                   resource.\n                -  For regional operations, use the ``regionOperations``\n                   resource.\n                -  For zonal operations, use the ``zonalOperations``\n                   resource.\n\n                For more information, read Global, Regional, and Zonal\n                Resources. (== resource_for\n                {$api_version}.globalOperations ==) (== resource_for\n                {$api_version}.regionOperations ==) (== resource_for\n                {$api_version}.zoneOperations ==)\n\n        \"\"\"\n\n        body = compute.Address.to_json(\n            request.address_resource,\n            including_default_value_fields=False,\n            use_integers_for_enums=False,\n        )\n\n        url = \"https://{host}/compute/v1/projects/{project}/regions/{region}/addresses\".format(\n            host=self._host, project=request.project, region=request.region,\n        )\n\n        query_params = {}\n        if compute.InsertAddressRequest.request_id in request:\n            query_params[\"requestId\"] = request.request_id\n\n        query_params = [\"{k}={v}\".format(k=k, v=v) for k, v in query_params.items()]\n        url += \"?{}\".format(\"&\".join(query_params)).replace(\" \", \"+\")\n\n        headers = dict(metadata)\n        headers[\"Content-Type\"] = \"application/json\"\n        response = self._session.post(url, headers=headers, data=body,)\n\n        if response.status_code >= 400:\n            raise core_exceptions.from_http_response(response)\n\n        return compute.Operation.from_json(response.content, ignore_unknown_fields=True)\n\n    def list(\n        self,\n        request: compute.ListAddressesRequest,\n        *,\n        metadata: Sequence[Tuple[str, str]] = (),\n    ) -> compute.AddressList:\n        r\"\"\"Call the list method over HTTP.\n\n        Args:\n            request (~.compute.ListAddressesRequest):\n                The request object. A request message for Addresses.List.\n                See the method description for details.\n\n            metadata (Sequence[Tuple[str, str]]): Strings which should be\n                sent along with the request as metadata.\n\n        Returns:\n            ~.compute.AddressList:\n                Contains a list of addresses.\n        \"\"\"\n\n        url = \"https://{host}/compute/v1/projects/{project}/regions/{region}/addresses\".format(\n            host=self._host, project=request.project, region=request.region,\n        )\n\n        query_params = {}\n        if compute.ListAddressesRequest.filter in request:\n            query_params[\"filter\"] = request.filter\n        if compute.ListAddressesRequest.max_results in request:\n            query_params[\"maxResults\"] = request.max_results\n        if compute.ListAddressesRequest.order_by in request:\n            query_params[\"orderBy\"] = request.order_by\n        if compute.ListAddressesRequest.page_token in request:\n            query_params[\"pageToken\"] = request.page_token\n        if compute.ListAddressesRequest.return_partial_success in request:\n            query_params[\"returnPartialSuccess\"] = request.return_partial_success\n\n        query_params = [\"{k}={v}\".format(k=k, v=v) for k, v in query_params.items()]\n        url += \"?{}\".format(\"&\".join(query_params)).replace(\" \", \"+\")\n\n        headers = dict(metadata)\n        headers[\"Content-Type\"] = \"application/json\"\n        response = self._session.get(url, headers=headers,)\n\n        if response.status_code >= 400:\n            raise core_exceptions.from_http_response(response)\n\n        return compute.AddressList.from_json(\n            response.content, ignore_unknown_fields=True\n        )\n\n\n__all__ = (\"AddressesRestTransport\",)\n",
  "line_no": 276,
  "line_no_percent": "68%"
}