{
  "instruction": "The given code is a Python script that cleans up old images from a Google Container Registry. To use it, follow these steps:\n\n1. Install Python and the required dependencies (aiogoogle, aiohttp, and hailtop.aiogoogle).\n2. Save the code to a file named \"cleanup_gcr.py\".\n3. Open a terminal or command prompt and navigate to the directory containing the file.\n4. Run the script with the command \"python cleanup_gcr.py [project]\", where [project] is the name of your Google Cloud project.\n\nThe script will connect to your Container Registry, list all images, and delete any images that are more than 7 days old or have no associated tags. It will keep the 10 most recent images for each repository. The script will run asynchronously, using up to 8 parallel threads to speed up the cleanup process. The progress of the cleanup will be logged to the console.",
  "buggy_code": "import sys\nimport time\nimport logging\nimport asyncio\nimport aiohttp\nimport hailtop.aiogoogle as aiogoogle\n\nlog = logging.getLogger(__name__)\n\n\nclass AsyncIOExecutor:\n    def __init__(self, parallelism):\n        self._semaphore = asyncio.Semaphore(parallelism)\n\n    async def _run(self, fut, aw):\n        async with self._semaphore:\n            try:\n                fut.set_result(await aw)\n            except asyncio.CancelledError:  # pylint: disable=try-except-raise\n                raise\n            except Exception as e:  # pylint: disable=broad-except\n                fut.set_exception(e)\n\n    def submit(self, aw):\n        fut = asyncio.Future()\n        asyncio.ensure_future(self._run(fut, aw))\n        return fut\n\n    async def gather(self, aws):\n        futs = [self.submit(aw) for aw in aws]\n        return [await fut for fut in futs]\n\n\nclass CleanupImages:\n    def __init__(self, client):\n        return\n        self._executor = AsyncIOExecutor(8)\n        self._client = client\n\n    async def cleanup_digest(self, image, digest, tags):\n        log.info(f'cleaning up digest {image}@{digest}')\n\n        await self._executor.gather([\n            self._client.delete(f'/{image}/manifests/{tag}')\n            for tag in tags])\n\n        await self._executor.submit(self._client.delete(f'/{image}/manifests/{digest}'))\n\n        log.info(f'cleaned up digest  {image}@{digest}')\n\n    async def cleanup_image(self, image):\n        log.info(f'cleaning up image {image}')\n\n        log.info(f'listing tags for {image}')\n\n        result = await self._executor.submit(self._client.get(f'/{image}/tags/list'))\n        manifests = result['manifest']\n        manifests = [(digest, int(data['timeUploadedMs']) / 1000, data['tag']) for digest, data in manifests.items()]\n\n        log.info(f'got {len(manifests)} manifests for {image}')\n\n        manifests = sorted(manifests, key=lambda x: x[1])\n\n        manifests = manifests[:-10]\n\n        now = time.time()\n        await asyncio.gather(*[\n            self.cleanup_digest(image, digest, tags)\n            for digest, time_uploaded, tags in manifests\n            if (now - time_uploaded) >= (7 * 24 * 60 * 60) or len(tags) == 0])\n\n        log.info(f'cleaned up image  {image}')\n\n    async def run(self):\n        images = await self._executor.submit(self._client.get('/tags/list'))\n        await asyncio.gather(*[\n            self.cleanup_image(image)\n            for image in images['child']\n        ])\n\n\nasync def main():\n    logging.basicConfig(level=logging.INFO)\n\n    if len(sys.argv) != 2:\n        raise ValueError('usage: cleanup_gcr <project>')\n    project = sys.argv[1]\n\n    async with aiogoogle.ContainerClient(\n            project=project,\n            timeout=aiohttp.ClientTimeout(total=60)) as client:\n        cleanup_images = CleanupImages(client)\n        await cleanup_images.run()\n\n\nasyncio.run(main())\n",
  "line_no": 36,
  "line_no_percent": "38%"
}