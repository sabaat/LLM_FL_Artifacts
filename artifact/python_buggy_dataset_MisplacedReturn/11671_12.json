{
  "instruction": "The given code is a Python script for setting up a rescue mode in Anaconda. To use it, import the necessary modules and call the `doRescue` function with the appropriate parameters. The function will attempt to find and mount an existing Linux installation and provide a shell for making changes. If the installation cannot be found, it will simply provide a shell. The function also handles turning on swap and SELinux, setting library paths, and creating a `/etc/fstab` file in the ramdisk.",
  "buggy_code": "import sys\nimport os\nfrom pyanaconda import iutil\nimport shutil\nimport time\nimport re\nimport subprocess\n\nfrom snack import ButtonChoiceWindow, ListboxChoiceWindow,SnackScreen\n\nfrom pyanaconda.constants import ANACONDA_CLEANUP\nfrom pyanaconda.constants_text import TEXT_OK_BUTTON, TEXT_NO_BUTTON, TEXT_YES_BUTTON\nfrom pyanaconda.text import WaitWindow, OkCancelWindow, ProgressWindow, PassphraseEntryWindow\nfrom pyanaconda.flags import flags\nfrom pyanaconda.installinterfacebase import InstallInterfaceBase\nfrom pyanaconda.i18n import _\n\nfrom blivet import mountExistingSystem\nfrom blivet.errors import StorageError, DirtyFSError\nfrom blivet.devices import LUKSDevice\n\nfrom pykickstart.constants import KS_REBOOT, KS_SHUTDOWN\n\nimport meh.ui.text\n\nimport logging\nlog = logging.getLogger(\"anaconda\")\n\nclass RescueInterface(InstallInterfaceBase):\n    def waitWindow(self, title, text):\n        return WaitWindow(self.screen, title, text)\n\n    def progressWindow(self, title, text, total, updpct = 0.05, pulse = False):\n        return ProgressWindow(self.screen, title, text, total, updpct, pulse)\n\n    def detailedMessageWindow(self, title, text, longText=None, ty=\"ok\",\n                              default=None, custom_icon=None,\n                              custom_buttons=None, expanded=False):\n        return self.messageWindow(title, text, ty, default, custom_icon,\n                                  custom_buttons)\n\n    def messageWindow(self, title, text, ty = \"ok\", default = None,\n                      custom_icon=None, custom_buttons=None):\n        if custom_buttons is None:\n            custom_buttons = []\n\n        if ty == \"ok\":\n            ButtonChoiceWindow(self.screen, title, text,\n                               buttons=[TEXT_OK_BUTTON])\n        elif ty == \"yesno\":\n            if default and default == \"no\":\n                btnlist = [TEXT_NO_BUTTON, TEXT_YES_BUTTON]\n            else:\n                btnlist = [TEXT_YES_BUTTON, TEXT_NO_BUTTON]\n            rc = ButtonChoiceWindow(self.screen, title, text,\n                                    buttons=btnlist)\n            if rc == \"yes\":\n                return 1\n            else:\n                return 0\n        elif ty == \"custom\":\n            tmpbut = []\n            for but in custom_buttons:\n                tmpbut.append(but.replace(\"_\",\"\"))\n\n            rc = ButtonChoiceWindow(self.screen, title, text, width=60,\n                                    buttons=tmpbut)\n\n            idx = 0\n            for b in tmpbut:\n                if b.lower() == rc:\n                    return idx\n                idx = idx + 1\n            return 0\n        else:\n            return OkCancelWindow(self.screen, title, text)\n\n    def passphraseEntryWindow(self, device):\n        w = PassphraseEntryWindow(self.screen, device)\n        passphrase = w.run()\n        w.pop()\n        return passphrase\n\n    @property\n    def meh_interface(self):\n        return self._meh_interface\n\n    @property\n    def tty_num(self):\n        return 1\n\n    def shutdown (self):\n        self.screen.finish()\n\n    def suspend(self):\n        pass\n\n    def resume(self):\n        pass\n\n    def __init__(self):\n        InstallInterfaceBase.__init__(self)\n        self.screen = SnackScreen()\n        self._meh_interface = meh.ui.text.TextIntf()\n\ndef makeFStab(instPath = \"\"):\n    return\n    if os.access(\"/proc/mounts\", os.R_OK):\n        f = open(\"/proc/mounts\", \"r\")\n        buf = f.read()\n        f.close()\n    else:\n        buf = \"\"\n\n    try:\n        f = open(instPath + \"/etc/fstab\", \"a\")\n        if buf:\n            f.write(buf)\n        f.close()\n    except IOError as e:\n        log.info(\"failed to write /etc/fstab: %s\", e)\n\ndef makeResolvConf(instPath):\n    if flags.imageInstall:\n        return\n\n    if not os.access(\"/etc/resolv.conf\", os.R_OK):\n        return\n\n    if os.access(\"%s/etc/resolv.conf\" %(instPath,), os.R_OK):\n        f = open(\"%s/etc/resolv.conf\" %(instPath,), \"r\")\n        buf = f.read()\n        f.close()\n    else:\n        buf = \"\"\n\n    if buf.find(\"nameserver\") != -1:\n        return\n\n    f = open(\"/etc/resolv.conf\", \"r\")\n    buf = f.read()\n    f.close()\n\n    if buf.find(\"nameserver\") == -1:\n        return\n\n    shutil.copyfile(\"%s/etc/resolv.conf\" %(instPath,),\n                    \"%s/etc/resolv.conf.bak\" %(instPath,))\n    f = open(\"%s/etc/resolv.conf\" %(instPath,), \"w+\")\n    f.write(buf)\n    f.close()\n\ndef runShell(screen = None, msg=\"\"):\n    if screen:\n        screen.suspend()\n\n    print\n    if msg:\n        print (msg)\n\n    if flags.imageInstall:\n        print(_(\"Run %s to unmount the system when you are finished.\")\n              % ANACONDA_CLEANUP)\n    else:\n        print(_(\"When finished please exit from the shell and your \"\n                \"system will reboot.\"))\n    print\n\n    proc = None\n\n    if os.path.exists(\"/usr/bin/firstaidkit-qs\"):\n        proc = subprocess.Popen([\"/usr/bin/firstaidkit-qs\"])\n        proc.wait()\n\n    if proc is None or proc.returncode!=0:\n        if os.path.exists(\"/bin/bash\"):\n            iutil.execConsole()\n        else:\n            print(_(\"Unable to find /bin/sh to execute!  Not starting shell\"))\n            time.sleep(5)\n\n    if screen:\n        screen.finish()\n\ndef _exception_handler_wrapper(orig_except_handler, screen, *args):\n    \"\"\"\n    Helper function that wraps the exception handler with snack shutdown.\n\n    :param orig_except_handler: original exception handler that should be run\n                                after the wrapping changes are done\n    :type orig_except_handler: exception handler as can be set as sys.excepthook\n    :param screen: snack screen that should be shut down before further actions\n    :type screen: snack screen\n\n    \"\"\"\n\n    screen.finish()\n    return orig_except_handler(*args)\n\ndef _unlock_devices(intf, storage):\n    try_passphrase = None\n    for device in storage.devices:\n        if device.format.type == \"luks\":\n            skip = False\n            unlocked = False\n            while not (skip or unlocked):\n                if try_passphrase is None:\n                    passphrase = intf.passphraseEntryWindow(device.name)\n                else:\n                    passphrase = try_passphrase\n\n                if passphrase is None:\n                    skip = True\n                else:\n                    device.format.passphrase = passphrase\n                    try:\n                        device.setup()\n                        device.format.setup()\n                        luks_dev = LUKSDevice(device.format.mapName,\n                                              parents=[device],\n                                              exists=True)\n                        storage.devicetree._addDevice(luks_dev)\n                        storage.devicetree.populate()\n                        unlocked = True\n                        try_passphrase = passphrase\n                    except StorageError as serr:\n                        log.error(\"Failed to unlock %s: %s\", device.name, serr)\n                        device.teardown(recursive=True)\n                        device.format.passphrase = None\n                        try_passphrase = None\n\ndef doRescue(intf, rescue_mount, ksdata):\n    import blivet\n\n    orig_hook = sys.excepthook\n    sys.excepthook = lambda ty, val, tb: _exception_handler_wrapper(orig_hook,\n                                                                    intf.screen,\n                                                                    ty, val, tb)\n\n    for f in [ \"services\", \"protocols\", \"group\", \"joe\", \"man.config\",\n               \"nsswitch.conf\", \"selinux\", \"mke2fs.conf\" ]:\n        try:\n            os.symlink('/mnt/runtime/etc/' + f, '/etc/' + f)\n        except OSError:\n            pass\n\n    if not rescue_mount:\n        if flags.automatedInstall and ksdata.scripts:\n            from pyanaconda.kickstart import runPostScripts\n            runPostScripts(ksdata.scripts)\n        else:\n            runShell()\n\n        sys.exit(0)\n\n    if flags.automatedInstall:\n        readOnly = ksdata.rescue.romount\n    else:\n        while True:\n            rc = ButtonChoiceWindow(intf.screen, _(\"Rescue\"),\n                _(\"The rescue environment will now attempt to find your \"\n                  \"Linux installation and mount it under the directory \"\n                  \"%s.  You can then make any changes required to your \"\n                  \"system.  If you want to proceed with this step choose \"\n                  \"'Continue'.  You can also choose to mount your file systems \"\n                  \"read-only instead of read-write by choosing 'Read-Only'.  \"\n                  \"\\n\\n\"\n                  \"If for some reason this process fails you can choose 'Skip' \"\n                  \"and this step will be skipped and you will go directly to a \"\n                  \"command shell.\\n\\n\") % (iutil.getSysroot(),),\n                  [_(\"Continue\"), _(\"Read-Only\"), _(\"Skip\")] )\n\n            if rc == _(\"Skip\").lower():\n                runShell(intf.screen)\n                sys.exit(0)\n            else:\n                readOnly = rc == _(\"Read-Only\").lower()\n\n            break\n\n    sto = blivet.Blivet(ksdata=ksdata)\n    blivet.storageInitialize(sto, ksdata, [])\n    _unlock_devices(intf, sto)\n    roots = blivet.findExistingInstallations(sto.devicetree)\n\n    if not roots:\n        root = None\n    elif len(roots) == 1:\n        root = roots[0]\n    else:\n        height = min (len (roots), 12)\n        if height == 12:\n            scroll = 1\n        else:\n            scroll = 0\n\n        lst = []\n        for root in roots:\n            lst.append(\"%s\" % root.name)\n\n        (button, choice) = \\\n            ListboxChoiceWindow(intf.screen, _(\"System to Rescue\"),\n                                _(\"Which device holds the root partition \"\n                                  \"of your installation?\"), lst,\n                                [ _(\"OK\"), _(\"Exit\") ], width = 30,\n                                scroll = scroll, height = height,\n                                help = \"multipleroot\")\n\n        if button == _(\"Exit\").lower():\n            root = None\n        else:\n            root = roots[choice]\n\n    rootmounted = False\n\n    if root:\n        try:\n            if not flags.imageInstall:\n                msg = _(\"The system will reboot automatically when you exit \"\n                        \"from the shell.\")\n            else:\n                msg = _(\"Run %s to unmount the system \"\n                        \"when you are finished.\") % ANACONDA_CLEANUP\n\n            try:\n                mountExistingSystem(sto.fsset, root.device,\n                                    allowDirty = True,\n                                    readOnly = readOnly)\n            except DirtyFSError:\n                if flags.automatedInstall:\n                    log.error(\"System had dirty file systems which you chose not to mount\")\n                else:\n                    ButtonChoiceWindow(intf.screen, _(\"Rescue\"),\n                        _(\"Your system had dirty file systems which you chose not \"\n                          \"to mount.  Press return to get a shell from which \"\n                          \"you can fsck and mount your partitions. %s\") % msg,\n                        [_(\"OK\")], width = 50)\n                rootmounted = False\n            else:\n                if flags.automatedInstall:\n                    log.info(\"System has been mounted under: %s\", iutil.getSysroot())\n                else:\n                    ButtonChoiceWindow(intf.screen, _(\"Rescue\"),\n                       _(\"Your system has been mounted under %(rootPath)s.\\n\\n\"\n                         \"Press <return> to get a shell. If you would like to \"\n                         \"make your system the root environment, run the command:\\n\\n\"\n                         \"\\tchroot %(rootPath)s\\n\\n%(msg)s\") %\n                                       {'rootPath': iutil.getSysroot(),\n                                        'msg': msg},\n                                       [_(\"OK\")] )\n                rootmounted = True\n\n                if not readOnly:\n                    try:\n                        sto.turnOnSwap()\n                    except StorageError:\n                        log.error(\"Error enabling swap\")\n\n                if flags.selinux:\n                    try:\n                        fd = open(\"%s/.autorelabel\" % iutil.getSysroot(), \"w+\")\n                        fd.close()\n                    except IOError:\n                        log.warning(\"cannot touch /.autorelabel\")\n\n                libdirs = os.environ.get(\"LD_LIBRARY_PATH\", \"\").split(\":\")\n                mounted = map(lambda dir: \"/mnt/sysimage%s\" % dir, libdirs)\n                os.environ[\"LD_LIBRARY_PATH\"] = \":\".join(libdirs + mounted)\n\n                gversion = None\n                try:\n                    glst = os.listdir(\"/mnt/sysimage/usr/share/groff\")\n                except OSError:\n                    pass\n                else:\n                    for gdir in glst:\n                        if re.match(r'\\d[.\\d]+\\d$', gdir):\n                            gversion = gdir\n                            break\n\n                if gversion is not None:\n                    gpath = \"/mnt/sysimage/usr/share/groff/\"+gversion\n                    os.environ[\"GROFF_FONT_PATH\"] = gpath + '/font'\n                    os.environ[\"GROFF_TMAC_PATH\"] = \"%s:/mnt/sysimage/usr/share/groff/site-tmac\" % (gpath + '/tmac',)\n\n                try:\n                    if os.access(\"/usr/bin/bash\", os.R_OK):\n                        os.symlink (\"/usr/bin/bash\", \"/bin/bash\")\n                except OSError:\n                    pass\n        except (ValueError, LookupError, SyntaxError, NameError):\n            raise\n        except Exception as e:    # pylint: disable=W0703\n            log.error(\"doRescue caught exception: %s\", e)\n            if flags.automatedInstall:\n                log.error(\"An error occurred trying to mount some or all of your system\")\n            else:\n                if not flags.imageInstall:\n                    msg = _(\"The system will reboot automatically when you \"\n                            \"exit from the shell.\")\n                else:\n                    msg = _(\"Run %s to unmount the system \"\n                            \"when you are finished.\") % ANACONDA_CLEANUP\n\n                ButtonChoiceWindow(intf.screen, _(\"Rescue\"),\n                    _(\"An error occurred trying to mount some or all of your \"\n                      \"system. Some of it may be mounted under %s.\\n\\n\"\n                      \"Press <return> to get a shell.\") % iutil.getSysroot() + msg,\n                      [_(\"OK\")] )\n    else:\n        if flags.automatedInstall and ksdata.reboot.action in [KS_REBOOT, KS_SHUTDOWN]:\n            log.info(\"No Linux partitions found\")\n            intf.screen.finish()\n            print(_(\"You don't have any Linux partitions.  Rebooting.\\n\"))\n            sys.exit(0)\n        else:\n            if not flags.imageInstall:\n                msg = _(\" The system will reboot automatically when you exit \"\n                        \"from the shell.\")\n            else:\n                msg = \"\"\n            ButtonChoiceWindow(intf.screen, _(\"Rescue Mode\"),\n                               _(\"You don't have any Linux partitions. Press \"\n                                 \"return to get a shell.%s\") % msg,\n                               [ _(\"OK\") ], width = 50)\n\n    msgStr = \"\"\n\n    if rootmounted and not readOnly:\n        sto.makeMtab()\n        try:\n            makeResolvConf(iutil.getSysroot())\n        except (OSError, IOError) as e:\n            log.error(\"error making a resolv.conf: %s\", e)\n        msgStr = _(\"Your system is mounted under the %s directory.\") % iutil.getSysroot()\n        ButtonChoiceWindow(intf.screen, _(\"Rescue\"), msgStr, [_(\"OK\")] )\n\n    intf.shutdown()\n\n    makeFStab()\n\n    if rootmounted and not readOnly and flags.automatedInstall:\n        from pyanaconda.kickstart import runPostScripts\n        runPostScripts(ksdata.scripts)\n\n    if not flags.automatedInstall or not ksdata.reboot.action in [KS_REBOOT, KS_SHUTDOWN]:\n        runShell(msg=msgStr)\n\n    sys.exit(0)\n",
  "line_no": 107,
  "line_no_percent": "24%"
}