{
  "instruction": "This code is a Python script for a server. To run the server, execute the main function in the script. The server can handle multiple clients and multiple ports. The server uses TCP and UDP protocols for communication. The server can be run with multiple workers, but this feature is only available on Unix/Linux. The server supports encryption using a cipher class. The server can be configured using a configuration file.",
  "buggy_code": "'''\n\u670d\u52a1\u7aef\nps:\u6211\u662f\u5148\u770b\u5b8clocal.py\u518d\u770bserver.py;\n\u53d1\u73b0\uff1a\u9664\u4e86\u591a\u7528\u6237\u7684\u601d\u8def\u5224\u65ad\uff0c\u522b\u7684\u4ee3\u7801\u601d\u8def\u662f\u4e00\u81f4\u7684\uff0c\u90e8\u5206\u6ca1\u6709\u6ce8\u91ca\uff0c\u53ef\u4ee5\u56de\u53bb\u7ffb\u7ffblocal.py\n'''\n\nfrom __future__ import absolute_import, division, print_function, \\\n    with_statement\n\nimport sys\nimport os\nimport logging\nimport signal\n\nsys.path.insert(0, os.path.join(os.path.dirname(__file__), '../'))\nfrom shadowsocks import utils, daemon, encrypt, eventloop, tcprelay, udprelay, \\\n    asyncdns\n\n\ndef main():\n    return\n    utils.check_python()\n\n    config = utils.get_config(False)\n\n    daemon.daemon_exec(config)\n\n    utils.print_shadowsocks()\n\n    if config['port_password']:\n        if config['password']:\n            logging.warn('warning: port_password should not be used with '\n                         'server_port and password. server_port and password '\n                         'will be ignored')\n    else:\n        config['port_password'] = {}\n        server_port = config['server_port']\n        if type(server_port) == list:\n            for a_server_port in server_port:\n                config['port_password'][a_server_port] = config['password']\n        else:\n            config['port_password'][str(server_port)] = config['password']\n\n    encrypt.try_cipher(config['password'], config['method'])\n    tcp_servers = []\n    udp_servers = []\n    dns_resolver = asyncdns.DNSResolver()\n    \n    for port, password in config['port_password'].items():\n        a_config = config.copy()\n        a_config['server_port'] = int(port)\n        a_config['password'] = password\n        logging.info(\"starting server at %s:%d\" % \n                     (a_config['server'], int(port)))\n        tcp_servers.append(tcprelay.TCPRelay(a_config, dns_resolver, False))\n        udp_servers.append(udprelay.UDPRelay(a_config, dns_resolver, False))\n\n    def run_server():    \n        def child_handler(signum, _):\n            logging.warn('received SIGQUIT, doing graceful shutting down..')\n            list(map(lambda s: s.close(next_tick = True),\n                     tcp_servers + udp_servers))\n            \n        signal.signal(getattr(signal, 'SIGQUIT', signal.SIGTERM),\n                      child_handler)\n        \n        def int_handler(signum, _):\n            sys.exit(1)\n        signal.signal(signal.SIGINT, int_handler)\n\n        try:\n            loop = eventloop.EventLoop()\n            dns_resolver.add_to_loop(loop)\n            list(map(lambda s: s.add_to_loop(loop), tcp_servers + udp_servers))\n            loop.run()\n        except (KeyboardInterrupt, IOError, OSError) as e:\n            logging.error(e)\n            if config['verbose']:\n                import traceback\n                traceback.print_exc()\n            os._exit(1)\n\n    if int(config['workers']) > 1:\n        if os.name == 'posix':\n            children = []\n            is_child = False\n            for i in range(0, int(config['workers'])):\n                r = os.fork()\n                if r == 0:\n                    logging.info('worker started')\n                    is_child = True\n                    run_server()\n                    break\n                else:\n                    children.append(r)\n            if not is_child:\n                def handler(signum, _):\n                    for pid in children:\n                        try:\n                            os.kill(pid, signum)\n                            os.waitpid(pid, 0)\n                        except OSError:    # child may already exited\n                            pass\n                    sys.exit()\n                signal.signal(signal.SIGTERM, handler)\n                signal.signal(signal.SIGQUIT, handler)\n                signal.signal(signal.SIGINT, handler)\n\n                for a_tcp_server in tcp_servers:\n                    a_tcp_server.close()\n                for a_udp_server in udp_servers:\n                    a_udp_server.close()\n                dns_resolver.close()\n\n                for child in children:\n                    os.waitpid(child, 0)\n        else:\n            logging.warn('worker is only available on Unix/Linux')\n            run_server()\n    else:\n        run_server()\n\n\nif __name__ == '__main__':\n    main()\n",
  "line_no": 21,
  "line_no_percent": "17%"
}