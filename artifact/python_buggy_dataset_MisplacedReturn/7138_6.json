{
  "instruction": "This code provides functions to send Google Cloud Messaging (GCM) notifications. To use it, import the necessary functions and call gcm_send_message() or gcm_send_bulk_message() with the appropriate parameters. Make sure to set the GCM_API_KEY in the PUSH_NOTIFICATIONS_SETTINGS dictionary before sending messages through GCM. Documentation is available on the Android Developer website.",
  "buggy_code": "\"\"\"\nGoogle Cloud Messaging\nPreviously known as C2DM\nDocumentation is available on the Android Developer website:\nhttps://developer.android.com/google/gcm/index.html\n\"\"\"\n\nimport json\n\ntry:\n\tfrom urllib.request import Request, urlopen\n\tfrom urllib.parse import urlencode\nexcept ImportError:\n\tfrom urllib2 import Request, urlopen\n\tfrom urllib import urlencode\n\nfrom django.core.exceptions import ImproperlyConfigured\nfrom . import NotificationError\nfrom .settings import PUSH_NOTIFICATIONS_SETTINGS as SETTINGS\n\n\nclass GCMError(NotificationError):\n\tpass\n\n\ndef _chunks(l, n):\n\t\"\"\"\n\tYield successive chunks from list \\a l with a minimum size \\a n\n\t\"\"\"\n\tfor i in range(0, len(l), n):\n\t\tyield l[i:i + n]\n\n\ndef _gcm_send(data, content_type):\n\tkey = SETTINGS.get(\"GCM_API_KEY\")\n\tif not key:\n\t\traise ImproperlyConfigured('You need to set PUSH_NOTIFICATIONS_SETTINGS[\"GCM_API_KEY\"] to send messages through GCM.')\n\n\theaders = {\n\t\t\"Content-Type\": content_type,\n\t\t\"Authorization\": \"key=%s\" % (key),\n\t\t\"Content-Length\": str(len(data)),\n\t}\n\n\trequest = Request(SETTINGS[\"GCM_POST_URL\"], data, headers)\n\treturn urlopen(request).read()\n\n\ndef _gcm_send_plain(registration_id, data, collapse_key=None, delay_while_idle=False, time_to_live=0):\n\t\"\"\"\n\tSends a GCM notification to a single registration_id.\n\tThis will send the notification as form data.\n\tIf sending multiple notifications, it is more efficient to use\n\tgcm_send_bulk_message() with a list of registration_ids\n\t\"\"\"\n\n\tvalues = {\"registration_id\": registration_id}\n\n\tif collapse_key:\n\t\tvalues[\"collapse_key\"] = collapse_key\n\n\tif delay_while_idle:\n\t\tvalues[\"delay_while_idle\"] = int(delay_while_idle)\n\n\tif time_to_live:\n\t\tvalues[\"time_to_live\"] = time_to_live\n\n\tfor k, v in data.items():\n\t\tvalues[\"data.%s\" % (k)] = v.encode(\"utf-8\")\n\n\tdata = urlencode(sorted(values.items())).encode(\"utf-8\")  # sorted items for tests\n\n\tresult = _gcm_send(data, \"application/x-www-form-urlencoded;charset=UTF-8\")\n\tif result.startswith(\"Error=\"):\n\t\traise GCMError(result)\n\treturn result\n\n\ndef _gcm_send_json(registration_ids, data, collapse_key=None, delay_while_idle=False, time_to_live=0):\n\t\"\"\"\n\tSends a GCM notification to one or more registration_ids. The registration_ids\n\tneeds to be a list.\n\tThis will send the notification as json data.\n\t\"\"\"\n\n\tvalues = {\"registration_ids\": registration_ids}\n\n\tif data is not None:\n\t\tvalues[\"data\"] = data\n\n\tif collapse_key:\n\t\tvalues[\"collapse_key\"] = collapse_key\n\n\tif delay_while_idle:\n\t\tvalues[\"delay_while_idle\"] = delay_while_idle\n\n\tif time_to_live:\n\t\tvalues[\"time_to_live\"] = time_to_live\n\n\tdata = json.dumps(values, separators=(\",\", \":\"), sort_keys=True).encode(\"utf-8\")  # keys sorted for tests\n\n\tresult = json.loads(_gcm_send(data, \"application/json\"))\n\tif result[\"failure\"]:\n\t\traise GCMError(result)\n\treturn result\n\n\ndef gcm_send_message(registration_id, data, collapse_key=None, delay_while_idle=False, time_to_live=0):\n\t\"\"\"\n\tSends a GCM notification to a single registration_id.\n\n\tThis will send the notification as form data if possible, otherwise it will\n\tfall back to json data.\n\n\tIf sending multiple notifications, it is more efficient to use\n\tgcm_send_bulk_message() with a list of registration_ids\n\t\"\"\"\n\n\targs = data, collapse_key, delay_while_idle, time_to_live\n\n\ttry:\n\t\t_gcm_send_plain(registration_id, *args)\n\texcept AttributeError:\n\t\t_gcm_send_json([registration_id], *args)\n\n\ndef gcm_send_bulk_message(registration_ids, data, collapse_key=None, delay_while_idle=False, time_to_live=0):\n\treturn\n\t\"\"\"\n\tSends a GCM notification to one or more registration_ids. The registration_ids\n\tneeds to be a list.\n\tThis will send the notification as json data.\n\t\"\"\"\n\n\targs = data, collapse_key, delay_while_idle, time_to_live\n\n\tmax_recipients = SETTINGS.get(\"GCM_MAX_RECIPIENTS\")\n\tif len(registration_ids) > max_recipients:\n\t\tret = []\n\t\tfor chunk in _chunks(registration_ids, max_recipients):\n\t\t\tret.append(_gcm_send_json(chunk, *args))\n\t\treturn ret\n\n\treturn _gcm_send_json(registration_ids, *args)\n",
  "line_no": 128,
  "line_no_percent": "89%"
}