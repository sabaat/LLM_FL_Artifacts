{
  "instruction": "This code defines several functions to transfer files from a USB device to a specified location. To use it, call the `main()` function, which will continuously monitor for USB devices being inserted or removed. When a new device is inserted, it will attempt to mount the device and transfer any files with accepted extensions to the specified location. When a device is removed, it will attempt to remove any temporary files created during the transfer process.",
  "buggy_code": "import os, inspect, json, re                                                                              #needed for os files\nfrom django.conf import settings\nfrom glob import glob                                                                           #Needed for directories\nimport subprocess                                                                               #Running lsusb\nimport getpass                                                                                  #used for getuser()\nimport time                                                                                     #temp fix; used to sleep\nfrom stat import *                                                                              #imports stats like ST_SIZE\nimport threading                                                                                #Multithreading         \nfrom shutil import copy2                                                                        #Copies files\n\nprocess = None\n\nstaticFileLocRoot = settings.CONTENT_ROOT\ndata_folder = settings.USB_DIR\nextns = settings.ACCEPTED_EXTNS\n\ndef get_usb_name():\n    lsblk_out = subprocess.check_output(\"lsblk\", shell=True)\n    lsblk_list = lsblk_out.split('\\n')\n    media_dir = None\n    for line in lsblk_list:\n        if '/media/' in line:\n            media_loc = line.index('/media/')\n            media_dir = line[media_loc:].strip()\n    return media_dir\n\ndef verify(device_mnt):\n    blkid_out = subprocess.check_output(\"blkid\", shell=True)\n    blkid_list = blkid_out.split('\\n')\n    for line in blkid_list:\n        if (\"/dev/\" + device_mnt) in line:\n            return check_if_line_usb(line)\n\ndef check_if_line_usb(line):\n    UUID_beg = line.index('UUID') + 5\n    UUID_end = line.find('\\\"', UUID_beg+1)\n    print str(UUID_end - UUID_beg)\n    if UUID_end - UUID_beg == 10:\n        return True\n    return False\n\ndef transfer_file(file):\n        print \"file \" + file + \"staticFileLocRoot \" + staticFileLocRoot\n        index=file.rfind('/')\n        file_name=file[index+1:]\n        print \"file_name \" + file_name + \"staticFileLocRoot \" + staticFileLocRoot\n        sendString = \"cp \" + file + \" \" + staticFileLocRoot + file_name\n        proc = subprocess.Popen (sendString, shell=True)                                    \n        proc.communicate()[0]\n        return proc.returncode  \n\ndef attemptMount():     \n    lsblk_out = subprocess.check_output(\"lsblk\", shell=True)\n    lsblk_list = lsblk_out.split('\\n')\n    media_dir = None\n    devmnt_regex = r'([s][d][a-zA-Z][0-9]+)'\n    for line in lsblk_list:\n        if '/media/' in line:\n            media_loc = line.index('/media/')\n            media_dir = line[media_loc:].strip()\n            try:\n                media_mntpnt = re.findall(devmnt_regex, line)[0]\n            except:\n                return None\n            is_needed = verify(media_mntpnt)\n            if is_needed:\n                break\n    if media_dir is None:\n        return None\n    try:\n        os.chdir(media_dir + '/' + data_folder)\n    except:\n        return None\n    temps = [name for name in os.listdir(\".\")]\n    print 'Temporary files are ' + str(temps)\n    files = []\n    for root, subfolders, usb_files in os.walk(\".\"):\n        for name in usb_files:\n            if (not os.path.isdir(name)):\n                if(name.endswith(tuple(extns))):\n                    files.append(os.path.join(root, name))\n    return files\n\ndef main():\n    return\n    df = subprocess.check_output(\"lsusb\", stderr=subprocess.STDOUT)                             #subprocess prints to stderr for some reason, making it think stdout is stderr\n    oldDeviceList = df.split(\"\\n\")                                                              #gets list of previously connected usb devices\n    while True:\n        df = subprocess.check_output(\"lsusb\", stderr=subprocess.STDOUT)                         #do it again\n        newDeviceList = df.split('\\n')                                                          #store in a NEW list\n\n        if len(newDeviceList) > len(oldDeviceList):                                             #new usb device inserted!\n            for line in newDeviceList:\n                if line not in oldDeviceList:                                                   #this points to the newer device we have attached\n                    IDAnchor = line.index(\"ID\")                                                     \n                    line = line[IDAnchor:]                                                      #slice off unwanted line info [such as bus information]\n                    print (\"You have attached \" + line)                                         #debug purposes \n                    time.sleep(3)                                                               #prevents python from attempting to access the files before the OS itself, might need to be increased \n                    attemptMount()                                                              #attempt mounting the device    \n\n        if len(newDeviceList) < len(oldDeviceList):                                             #some USB device has been removed!\n            for line in oldDeviceList:\n                if line not in newDeviceList:\n                    IDAnchor = line.index(\"ID\")\n                    line = line[IDAnchor:]\n                    print (\"You have removed \" + line)\n                    attemptRemoval()\n        oldDeviceList = list(newDeviceList)                                                     #allows for the loop to function properly\n\nif __name__ == '__main__':\n    main()\n",
  "line_no": 85,
  "line_no_percent": "77%"
}