{
  "instruction": "This code is a Python script that can be used to connect to a language agent and execute a script. To use this script, you need to provide the address of the language agent and the path to the script you want to execute as command line arguments. You can also provide some optional arguments to control the behavior of the script, such as the timeouts for connecting to the agent and executing the script, and the verbosity level. To run the script, simply call the main() function.",
  "buggy_code": "from pisession import session\nfrom pi import index,async,timeout,proxy,resource\n\nimport optparse\nimport sys\nimport piw\nimport picross\nimport traceback\n\nclass Connector(proxy.AtomProxy,async.Deferred):\n\n    monitor = set()\n\n    def __init__(self,address):\n        async.Deferred.__init__(self)\n        proxy.AtomProxy.__init__(self)\n        self.__anchor = piw.canchor()\n        self.__anchor.set_client(self)\n        self.__anchor.set_address_str(address)\n\n    def close_client(self):\n        proxy.AtomProxy.close_client(self)\n\n    def cancel(self):\n        self.__anchor.set_address_str('')\n        self.__anchor.set_client(None)\n        self.__anchor=None\n\n    def node_ready(self):\n        self.succeeded()\n\nclass RpcAdapter(async.DeferredDecoder):\n    def decode(self):\n        if self.deferred.status() is False:\n            return async.Coroutine.failure(self.deferred.args()[0])\n        return self.deferred.args()[0]\n\ndef coroutine(lang,script,ctimeout=3000,rtimeout=3000,verbose=True):\n\n    connector = Connector(lang)\n    timer = timeout.Timeout(connector,ctimeout,False,'cant connect to language agent')\n\n    yield timer\n    if not timer.status():\n        yield async.Coroutine.failure(*timer.args())\n        return\n\n    if verbose:\n        print 'connected to',lang,connector.status()\n\n    for line in script_reader(script):\n        rpc = connector.invoke_rpc('exec',line,time=rtimeout)\n        yield rpc\n\n        if not rpc.status():\n            print line,'failed:',rpc.args()[0]\n            return\n\n        if verbose:\n            print line,'ok'\n\ndef script_reader(fp):\n    for line in fp:\n        line = line.strip()\n        if not line or line.startswith('#'): continue\n        yield line\n\ndef open_script(name):\n    if name == '-':\n        return sys.stdin\n\n    try:\n        return resource.file_open(name,\"r\")\n    except:\n        return None\n\ndef main():\n    parser = optparse.OptionParser(usage=sys.argv[0]+' [options] agent script')\n    parser.add_option('--quiet',action='store_true',dest='quiet',default=False,help='quiet')\n    parser.add_option('--ctimeout',action='store',type='int',dest='ctimeout',default=5000,help='con timeout (5000 ms)')\n    parser.add_option('--rtimeout',action='store',type='int',dest='rtimeout',default=300000,help='rpc timeout (300000 ms)')\n    parser.add_option('--verbose',action='store_true',dest='verbose',default=False,help='verbose')\n\n    (opts,args) = parser.parse_args(sys.argv)\n\n    if len(args) != 3:\n        parser.error('wrong number of arguments')\n\n    lang = args[1]\n    script = args[2]\n\n    fp = open_script(script)\n\n    if fp is None:\n        parser.error('cant open %s' % script)\n\n    def handler(ei):\n        traceback.print_exception(*ei)\n        return async.Coroutine.failure('internal error')\n\n    def failed(msg):\n        if opts.verbose:\n            print 'script failed:',msg\n        picross.exit(-1)\n\n    def succeeded():\n        if opts.verbose:\n            print 'script finished'\n        picross.exit(0)\n\n    def startup(dummy):\n        return\n        result = async.Coroutine(coroutine(lang,fp,opts.ctimeout,opts.rtimeout,opts.verbose),handler)\n        result.setErrback(failed).setCallback(succeeded)\n        return result\n\n    picross.pic_set_interrupt()\n    session.run_session(startup,clock=False)\n",
  "line_no": 112,
  "line_no_percent": "95%"
}