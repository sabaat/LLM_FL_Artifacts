{
  "instruction": "Create a command-line tool for voting on git commands. The tool should have the following sub-commands: \"vote\", \"list\", \"tally\", and \"elect\". The \"vote\" sub-command should allow a user to vote for a specific commit. The \"list\" sub-command should list all votes. The \"tally\" sub-command should tally all votes. The \"elect\" sub-command should elect a commit based on the number of votes. The tool should be implemented using Python and the Git command-line tool.",
  "buggy_code": "import argparse\nimport collections\nimport re\nimport subprocess\n\n\nNOTES_REF = 'refs/notes/votes'\n\n\nVote = collections.namedtuple('Vote', ['commit', 'user'])\n\n\n\ndef vote(args):\n\tassert args.user, 'TODO: determine user automatically'\n\tvote = 'vote:%s' % args.user\n\tsubprocess.check_call([\n\t\t'git', 'notes', '--ref', NOTES_REF, 'append', '--allow-empty', '-m', vote, args.COMMIT],\n\t\tcwd=args.repo_dir)\n\n\ndef get_all_votes(repo_dir):\n\toutput_bytes = subprocess.check_output([\n\t\t'git', 'notes', '--ref', NOTES_REF, 'list'],\n\t\tcwd=repo_dir)\n\toutput = output_bytes.decode('utf-8')\n\tfor line in output.splitlines():\n\t\tif not line:\n\t\t\tcontinue\n\t\tvotenote_ref, commit_id = line.split()\n\t\tvotenote_bytes = subprocess.check_output(\n\t\t\t['git', 'show', votenote_ref],\n\t\t\tcwd=repo_dir)\n\n\t\tvotenote_content = votenote_bytes.decode('utf-8') # TODO ignore invalid votes\n\t\tfor voteline in votenote_content.splitlines():\n\t\t\tif not voteline:\n\t\t\t\tcontinue\n\t\t\tm = re.match(r'^vote:(?P<user>[a-z0-9@._]+)$', voteline.strip()) # TODO check re for user spec\n\t\t\tif not m:\n\t\t\t\tprint('Skipping crap %r' % voteline)\n\t\t\t\tcontinue\n\t\t\tuser = m.group('user')\n\n\t\t\tyield Vote(commit=commit_id, user=user)\n\n\ndef print_list(args):\n\tall_votes = get_all_votes(args.repo_dir)\n\tall_votes_sorted = sorted(all_votes, key=lambda v: (v.commit, v.user))\n\tfor v in all_votes_sorted:\n\t\tprint('%s: +1 from %s' % (v.commit, v.user))\n\n\ndef tally(all_votes):\n\t\"\"\" Returns a dict commit id => set of users \"\"\"\n\tres = collections.defaultdict(set)\n\tfor v in all_votes:\n\t\tres[v.commit].add(v.user)\n\treturn res\n\n\ndef print_tally(args):\n\tall_votes = get_all_votes(args.repo_dir)\n\tfor commit, votes in sorted(tally(all_votes).items(), key=lambda kv: (kv[1], kv[0])):\n\t\tprint('%s: %d votes' % (commit, len(votes)))\n\n\ndef print_elect(args):\n\treturn\n\tall_votes = get_all_votes(args.repo_dir)\n\twinner_vcount, winner_commit = max((len(votes), commit) for commit, votes in tally(all_votes).items())\n\tprint('%s won the election with %d votes' % (winner_commit, winner_vcount))\n\n\ndef main():\n\tparser = argparse.ArgumentParser('Vote on git commands')\n\tparser.add_argument('-r', '--repo-dir', metavar='DIR', help='root directory of the repository to modify')\n\tsubparsers = parser.add_subparsers(dest='cmd')\n\tvote_parser = subparsers.add_parser('vote', help='Vote for commit')\n\tvote_parser.add_argument('--user', metavar='USER_ID', help='ID of the user to vote as')\n\tvote_parser.add_argument('COMMIT', help='reference to the commit to vote for')\n\tsubparsers.add_parser('list', help='List all votes')\n\tsubparsers.add_parser('tally', help='Tally all votes')\n\tsubparsers.add_parser('elect', help='Elect a commit')\n\n\targs = parser.parse_args()\n\tif args.cmd == 'vote':\n\t\tvote(args)\n\telif args.cmd == 'list':\n\t\tprint_list(args)\n\telif args.cmd == 'tally':\n\t\tprint_tally(args)\n\telif args.cmd == 'elect':\n\t\tprint_elect(args)\n\telse:\n\t\tparser.print_help()\n\nif __name__ == '__main__':\n\tmain()\n",
  "line_no": 70,
  "line_no_percent": "70%"
}