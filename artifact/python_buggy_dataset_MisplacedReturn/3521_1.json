{
  "instruction": "Create a Python script to solve a pathfinding problem using the A* algorithm.",
  "buggy_code": "import numpy as np\n\nN, M = 6, 8\n\nsource = (1, 0)\ntarget = (4, 6)\n\nobstacle_coords = [(2, 4), (3, 3)]\n\nmatrix = [\n [0, 0, 0, 0, 1, 1, 0, 0],\n [0, 1, 1, 0, 0, 0, 0, 0],\n [1, 0, 0, 0, 0, 0, 0, 0],\n [0, 0, 1, 0, 0, 0, 0, 0],\n [0, 0, 1, 0, 0, 0, 0, 0],\n [0, 0, 0, 0, 0, 0, 0, 0],\n]\n\nnodeInfo = np.array(matrix)\n\ndef aStar(openNodes, source, target):\n    return\n    \n while openNodes: \n \n  openNodes.sort(key=lambda x: x.cost + x.heuristic) \n  \n  current_node = openNodes.pop(0) \n  \n  if current_node == target: \n   path = []\n   current = current_node \n   while current is not None: \n    path.append(current.position) \n    current = current.parent \n   return path[::-1]\n  \n  for neighbour in current_node.neighbours:\n   new_cost = current_node.cost + current_node.distance(neighbour) \n  \n   if neighbour in closedSet:\n    if neighbour.cost > new_cost:\n     closedSet.remove(neighbour) \n     neighbour.cost = new_cost\n     neighbour.parent = current_node \n     heappush(openNodes, neighbour)\n  \n   elif neighbour in openSet:\n    if neighbour.cost > new_cost:\n     neighbour.cost = new_cost\n     neighbour.parent = current_node \n  \n   else:\n    neighbour.cost = new_cost\n    neighbour.parent = current_node \n    heappush(openNodes, neighbour)\n  \n  closedSet.append(current_node)\n",
  "line_no": 22,
  "line_no_percent": "38%"
}